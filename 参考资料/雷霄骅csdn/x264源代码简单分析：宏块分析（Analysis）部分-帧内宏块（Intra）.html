<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/45917757"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文记录x264的 x264_slice_write()函数中调用的x264_macroblock_analyse()的源代码。x264_macroblock_analyse()对应着x264中的分析模块。分析模块主要完成了下面2个方面的功能：
（1）对于帧内宏块，分析帧内预测模式
（2）对于帧间宏块，进行运动估计，分析帧间预测模式" />
    <meta name="keywords" content="x264,帧内编码" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra） - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45917757"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年05月22日 16:08:02</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：9528</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p></p><p>=====================================================</p><p>H.264源代码分析文章列表：</p><p>【编码 - x264】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45536607">x264源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45583217">x264源代码简单分析：x264命令行工具（x264.exe）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45644367">x264源代码简单分析：编码器主干部分-1</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45719905">x264源代码简单分析：编码器主干部分-2</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45790195">x264源代码简单分析：x264_slice_write()</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45870269">x264源代码简单分析：滤波（Filter）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45917757">x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45936267">x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45938927">x264源代码简单分析：宏块编码（Encode）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45944811">x264源代码简单分析：熵编码（Entropy Encoding）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45960409">FFmpeg与libx264接口源代码简单分析</a></p><p>【解码 - libavcodec H.264 解码器】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">FFmpeg的H.264解码器源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45001033">FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45042755">FFmpeg的H.264解码器源代码简单分析：解码器主干部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45114453">FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45143075">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45195291">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45224579">FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分</a></p><p>=====================================================</p><br /><p>本文记录x264的 x264_slice_write()函数中调用的x264_macroblock_analyse()的源代码。x264_macroblock_analyse()对应着x264中的分析模块。分析模块主要完成了下面2个方面的功能：</p><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）对于帧内宏块，分析帧内预测模式<br />（2）对于帧间宏块，进行运动估计，分析帧间预测模式</blockquote>由于分析模块比较复杂，因此分成两篇文章记录其中的源代码：本文记录帧内宏块预测模式的分析，下一篇文章记录帧间宏块预测模式的分析。<br /><br /><br /><h2>函数调用关系图</h2><p>宏块分析（Analysis）部分的源代码在整个x264中的位置如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201505/06/1430897637_6272.jpg"><img src="http://img.blog.csdn.net/20150522152810071" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1807927">单击查看更清晰的图片</a></div><br /><p>宏块分析（Analysis）部分的函数调用关系如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201505/22/1432283073_8698.jpg"><img src="http://img.blog.csdn.net/20150522152910053" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1808725">单击查看更清晰的图片</a></div><br />从图中可以看出，分析模块的x264_macroblock_analyse()调用了如下函数（只列举了几个有代表性的函数）：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">x264_mb_analyse_init()：Analysis模块初始化。<br />x264_mb_analyse_intra()：Intra宏块帧内预测模式分析。<br />x264_macroblock_probe_pskip()：分析是否是skip模式。<br />x264_mb_analyse_inter_p16x16()：P16x16宏块帧间预测模式分析。<br />x264_mb_analyse_inter_p8x8()：P8x8宏块帧间预测模式分析。<br />x264_mb_analyse_inter_p16x8()：P16x8宏块帧间预测模式分析。<br />x264_mb_analyse_inter_b16x16()：B16x16宏块帧间预测模式分析。<br />x264_mb_analyse_inter_b8x8()：B8x8宏块帧间预测模式分析。<br />x264_mb_analyse_inter_b16x8()：B16x8宏块帧间预测模式分析。</blockquote>本文重点分析其中帧内宏块（Intra宏块）的分析函数x264_mb_analyse_intra()。下一篇文章再对x264_mb_analyse_inter_p16x16()等一系列帧间宏块的分析函数。<br /><br /><br /><h2>x264_slice_write()</h2>x264_slice_write()是x264项目的核心，它完成了编码了一个Slice的工作。有关该函数的分析可以参考文章《<a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45790195">x264源代码简单分析：x264_slice_write()</a>》。本文分析其调用的x264_mb_analyse()函数。<br /><br /><br /><h2>x264_macroblock_analyse()</h2>x264_macroblock_analyse()用于分析宏块的预测模式。该函数的定义位于encoder\analyse.c，如下所示。<br /><pre name="code" class="cpp">/****************************************************************************
 * 分析-帧内预测模式选择、帧间运动估计等
 *
 * 注释和处理：雷霄骅
 * http://blog.csdn.net/leixiaohua1020
 * leixiaohua1020@126.com
 ****************************************************************************/
void x264_macroblock_analyse( x264_t *h )
{
    x264_mb_analysis_t analysis;
    int i_cost = COST_MAX;
    //通过码率控制方法，获取本宏块QP
    h-&gt;mb.i_qp = x264_ratecontrol_mb_qp( h );
    /* If the QP of this MB is within 1 of the previous MB, code the same QP as the previous MB,
     * to lower the bit cost of the qp_delta.  Don't do this if QPRD is enabled. */
    if( h-&gt;param.rc.i_aq_mode &amp;&amp; h-&gt;param.analyse.i_subpel_refine &lt; 10 )
        h-&gt;mb.i_qp = abs(h-&gt;mb.i_qp - h-&gt;mb.i_last_qp) == 1 ? h-&gt;mb.i_last_qp : h-&gt;mb.i_qp;

    if( h-&gt;param.analyse.b_mb_info )
        h-&gt;fdec-&gt;effective_qp[h-&gt;mb.i_mb_xy] = h-&gt;mb.i_qp; /* Store the real analysis QP. */
    //初始化
    x264_mb_analyse_init( h, &amp;analysis, h-&gt;mb.i_qp );

    /*--------------------------- Do the analysis ---------------------------*/
    //I帧：只使用帧内预测，分别计算亮度16x16（4种）和4x4（9种）所有模式的代价值，选出代价最小的模式

    //P帧：计算帧内模式和帧间模式（ P Slice允许有Intra宏块和P宏块；同理B帧也支持Intra宏块）。
    //对P帧的每一种分割进行帧间预测，得到最佳的运动矢量及最佳匹配块。
    //帧间预测过程：选出最佳矢量——&gt;找到最佳的整像素点——&gt;找到最佳的二分之一像素点——&gt;找到最佳的1/4像素点
    //然后取代价最小的为最佳MV和分割方式
    //最后从帧内模式和帧间模式中选择代价比较小的方式（有可能没有找到很好的匹配块，这时候就直接使用帧内预测而不是帧间预测）。

    if( h-&gt;sh.i_type == SLICE_TYPE_I )
    {
    	//I slice
    	//通过一系列帧内预测模式（16x16的4种,4x4的9种）代价的计算得出代价最小的最优模式
intra_analysis:
        if( analysis.i_mbrd )
            x264_mb_init_fenc_cache( h, analysis.i_mbrd &gt;= 2 );
        //帧内预测分析
        //从16×16的SAD,4个8×8的SAD和，16个4×4SAD中选出最优方式
        x264_mb_analyse_intra( h, &amp;analysis, COST_MAX );
        if( analysis.i_mbrd )
            x264_intra_rd( h, &amp;analysis, COST_MAX );
        //分析结果都存储在analysis结构体中
        //开销
        i_cost = analysis.i_satd_i16x16;
        h-&gt;mb.i_type = I_16x16;
        //如果I4x4或者I8x8开销更小的话就拷贝
        //copy if little
        COPY2_IF_LT( i_cost, analysis.i_satd_i4x4, h-&gt;mb.i_type, I_4x4 );
        COPY2_IF_LT( i_cost, analysis.i_satd_i8x8, h-&gt;mb.i_type, I_8x8 );
        //画面极其特殊的时候，才有可能用到PCM
        if( analysis.i_satd_pcm &lt; i_cost )
            h-&gt;mb.i_type = I_PCM;

        else if( analysis.i_mbrd &gt;= 2 )
            x264_intra_rd_refine( h, &amp;analysis );
    }
    else if( h-&gt;sh.i_type == SLICE_TYPE_P )
    {
    	//P slice

        int b_skip = 0;

        h-&gt;mc.prefetch_ref( h-&gt;mb.pic.p_fref[0][0][h-&gt;mb.i_mb_x&amp;3], h-&gt;mb.pic.i_stride[0], 0 );

        analysis.b_try_skip = 0;
        if( analysis.b_force_intra )
        {
            if( !h-&gt;param.analyse.b_psy )
            {
                x264_mb_analyse_init_qp( h, &amp;analysis, X264_MAX( h-&gt;mb.i_qp - h-&gt;mb.ip_offset, h-&gt;param.rc.i_qp_min ) );
                goto intra_analysis;
            }
        }
        else
        {
            /* Special fast-skip logic using information from mb_info. */
            if( h-&gt;fdec-&gt;mb_info &amp;&amp; (h-&gt;fdec-&gt;mb_info[h-&gt;mb.i_mb_xy]&amp;X264_MBINFO_CONSTANT) )
            {
                if( !SLICE_MBAFF &amp;&amp; (h-&gt;fdec-&gt;i_frame - h-&gt;fref[0][0]-&gt;i_frame) == 1 &amp;&amp; !h-&gt;sh.b_weighted_pred &amp;&amp;
                    h-&gt;fref[0][0]-&gt;effective_qp[h-&gt;mb.i_mb_xy] &lt;= h-&gt;mb.i_qp )
                {
                    h-&gt;mb.i_partition = D_16x16;
                    /* Use the P-SKIP MV if we can... */
                    if( !M32(h-&gt;mb.cache.pskip_mv) )
                    {
                        b_skip = 1;
                        h-&gt;mb.i_type = P_SKIP;
                    }
                    /* Otherwise, just force a 16x16 block. */
                    else
                    {
                        h-&gt;mb.i_type = P_L0;
                        analysis.l0.me16x16.i_ref = 0;
                        M32( analysis.l0.me16x16.mv ) = 0;
                    }
                    goto skip_analysis;
                }
                /* Reset the information accordingly */
                else if( h-&gt;param.analyse.b_mb_info_update )
                    h-&gt;fdec-&gt;mb_info[h-&gt;mb.i_mb_xy] &amp;= ~X264_MBINFO_CONSTANT;
            }

            int skip_invalid = h-&gt;i_thread_frames &gt; 1 &amp;&amp; h-&gt;mb.cache.pskip_mv[1] &gt; h-&gt;mb.mv_max_spel[1];
            /* If the current macroblock is off the frame, just skip it. */
            if( HAVE_INTERLACED &amp;&amp; !MB_INTERLACED &amp;&amp; h-&gt;mb.i_mb_y * 16 &gt;= h-&gt;param.i_height &amp;&amp; !skip_invalid )
                b_skip = 1;
            /* Fast P_SKIP detection */
            else if( h-&gt;param.analyse.b_fast_pskip )
            {
                if( skip_invalid )
                    // FIXME don't need to check this if the reference frame is done
                    {}
                else if( h-&gt;param.analyse.i_subpel_refine &gt;= 3 )
                    analysis.b_try_skip = 1;
                else if( h-&gt;mb.i_mb_type_left[0] == P_SKIP ||
                         h-&gt;mb.i_mb_type_top == P_SKIP ||
                         h-&gt;mb.i_mb_type_topleft == P_SKIP ||
                         h-&gt;mb.i_mb_type_topright == P_SKIP )
                    b_skip = x264_macroblock_probe_pskip( h );//检查是否是Skip类型
            }
        }

        h-&gt;mc.prefetch_ref( h-&gt;mb.pic.p_fref[0][0][h-&gt;mb.i_mb_x&amp;3], h-&gt;mb.pic.i_stride[0], 1 );

        if( b_skip )
        {
            h-&gt;mb.i_type = P_SKIP;
            h-&gt;mb.i_partition = D_16x16;
            assert( h-&gt;mb.cache.pskip_mv[1] &lt;= h-&gt;mb.mv_max_spel[1] || h-&gt;i_thread_frames == 1 );
skip_analysis:
            /* Set up MVs for future predictors */
            for( int i = 0; i &lt; h-&gt;mb.pic.i_fref[0]; i++ )
                M32( h-&gt;mb.mvr[0][i][h-&gt;mb.i_mb_xy] ) = 0;
        }
        else
        {
            const unsigned int flags = h-&gt;param.analyse.inter;
            int i_type;
            int i_partition;
            int i_satd_inter, i_satd_intra;

            x264_mb_analyse_load_costs( h, &amp;analysis );
        	/*
        	 * 16x16 帧间预测宏块分析-P
        	 *
        	 * +--------+--------+
        	 * |                 |
        	 * |                 |
        	 * |                 |
        	 * +        +        +
        	 * |                 |
        	 * |                 |
        	 * |                 |
        	 * +--------+--------+
        	 *
        	 */
            x264_mb_analyse_inter_p16x16( h, &amp;analysis );

            if( h-&gt;mb.i_type == P_SKIP )
            {
                for( int i = 1; i &lt; h-&gt;mb.pic.i_fref[0]; i++ )
                    M32( h-&gt;mb.mvr[0][i][h-&gt;mb.i_mb_xy] ) = 0;
                return;
            }

            if( flags &amp; X264_ANALYSE_PSUB16x16 )
            {
                if( h-&gt;param.analyse.b_mixed_references )
                    x264_mb_analyse_inter_p8x8_mixed_ref( h, &amp;analysis );
                else{
                	/*
                	 * 8x8帧间预测宏块分析-P
					 * +--------+
					 * |        |
					 * |        |
					 * |        |
					 * +--------+
                	 */
                    x264_mb_analyse_inter_p8x8( h, &amp;analysis );
                }
            }

            /* Select best inter mode */
            i_type = P_L0;
            i_partition = D_16x16;
            i_cost = analysis.l0.me16x16.cost;

            //如果8x8的代价值小于16x16
            //则进行8x8子块分割的处理

            //处理的数据源自于l0
            if( ( flags &amp; X264_ANALYSE_PSUB16x16 ) &amp;&amp; (!analysis.b_early_terminate ||
                analysis.l0.i_cost8x8 &lt; analysis.l0.me16x16.cost) )
            {
                i_type = P_8x8;
                i_partition = D_8x8;
                i_cost = analysis.l0.i_cost8x8;

                /* Do sub 8x8 */
                if( flags &amp; X264_ANALYSE_PSUB8x8 )
                {
                    for( int i = 0; i &lt; 4; i++ )
                    {
                    	//8x8块的子块的分析
                    	/*
                    	 * 4x4
        				 * +----+----+
        				 * |    |    |
        				 * +----+----+
        				 * |    |    |
        				 * +----+----+
        				 *
        				 */
                        x264_mb_analyse_inter_p4x4( h, &amp;analysis, i );
                        int i_thresh8x4 = analysis.l0.me4x4[i][1].cost_mv + analysis.l0.me4x4[i][2].cost_mv;
                        //如果4x4小于8x8
                        //则再分析8x4，4x8的代价
                        if( !analysis.b_early_terminate || analysis.l0.i_cost4x4[i] &lt; analysis.l0.me8x8[i].cost + i_thresh8x4 )
                        {
                            int i_cost8x8 = analysis.l0.i_cost4x4[i];
                            h-&gt;mb.i_sub_partition[i] = D_L0_4x4;
                            /*
							 * 8x4
							 * +----+----+
							 * |         |
							 * +----+----+
							 * |         |
							 * +----+----+
							 *
							 */
                            //如果8x4小于8x8
                            x264_mb_analyse_inter_p8x4( h, &amp;analysis, i );
                            COPY2_IF_LT( i_cost8x8, analysis.l0.i_cost8x4[i],
                                         h-&gt;mb.i_sub_partition[i], D_L0_8x4 );
                        	/*
                        	 * 4x8
            				 * +----+----+
            				 * |    |    |
            				 * +    +    +
            				 * |    |    |
            				 * +----+----+
            				 *
            				 */
                            //如果4x8小于8x8
                            x264_mb_analyse_inter_p4x8( h, &amp;analysis, i );
                            COPY2_IF_LT( i_cost8x8, analysis.l0.i_cost4x8[i],
                                         h-&gt;mb.i_sub_partition[i], D_L0_4x8 );

                            i_cost += i_cost8x8 - analysis.l0.me8x8[i].cost;
                        }
                        x264_mb_cache_mv_p8x8( h, &amp;analysis, i );
                    }
                    analysis.l0.i_cost8x8 = i_cost;
                }
            }

            /* Now do 16x8/8x16 */
            int i_thresh16x8 = analysis.l0.me8x8[1].cost_mv + analysis.l0.me8x8[2].cost_mv;

            //前提要求8x8的代价值小于16x16
            if( ( flags &amp; X264_ANALYSE_PSUB16x16 ) &amp;&amp; (!analysis.b_early_terminate ||
                analysis.l0.i_cost8x8 &lt; analysis.l0.me16x16.cost + i_thresh16x8) )
            {
                int i_avg_mv_ref_cost = (analysis.l0.me8x8[2].cost_mv + analysis.l0.me8x8[2].i_ref_cost
                                      + analysis.l0.me8x8[3].cost_mv + analysis.l0.me8x8[3].i_ref_cost + 1) &gt;&gt; 1;
                analysis.i_cost_est16x8[1] = analysis.i_satd8x8[0][2] + analysis.i_satd8x8[0][3] + i_avg_mv_ref_cost;
            	/*
            	 * 16x8 宏块划分
            	 *
            	 * +--------+--------+
            	 * |        |        |
            	 * |        |        |
            	 * |        |        |
            	 * +--------+--------+
            	 *
            	 */
                x264_mb_analyse_inter_p16x8( h, &amp;analysis, i_cost );
                COPY3_IF_LT( i_cost, analysis.l0.i_cost16x8, i_type, P_L0, i_partition, D_16x8 );

                i_avg_mv_ref_cost = (analysis.l0.me8x8[1].cost_mv + analysis.l0.me8x8[1].i_ref_cost
                                  + analysis.l0.me8x8[3].cost_mv + analysis.l0.me8x8[3].i_ref_cost + 1) &gt;&gt; 1;
                analysis.i_cost_est8x16[1] = analysis.i_satd8x8[0][1] + analysis.i_satd8x8[0][3] + i_avg_mv_ref_cost;
            	/*
            	 * 8x16 宏块划分
            	 *
            	 * +--------+
            	 * |        |
            	 * |        |
            	 * |        |
            	 * +--------+
            	 * |        |
            	 * |        |
            	 * |        |
            	 * +--------+
            	 *
            	 */
                x264_mb_analyse_inter_p8x16( h, &amp;analysis, i_cost );
                COPY3_IF_LT( i_cost, analysis.l0.i_cost8x16, i_type, P_L0, i_partition, D_8x16 );
            }

            h-&gt;mb.i_partition = i_partition;

            /* refine qpel */
            //亚像素精度搜索
            //FIXME mb_type costs?
            if( analysis.i_mbrd || !h-&gt;mb.i_subpel_refine )
            {
                /* refine later */
            }
            else if( i_partition == D_16x16 )
            {
                x264_me_refine_qpel( h, &amp;analysis.l0.me16x16 );
                i_cost = analysis.l0.me16x16.cost;
            }
            else if( i_partition == D_16x8 )
            {
                x264_me_refine_qpel( h, &amp;analysis.l0.me16x8[0] );
                x264_me_refine_qpel( h, &amp;analysis.l0.me16x8[1] );
                i_cost = analysis.l0.me16x8[0].cost + analysis.l0.me16x8[1].cost;
            }
            else if( i_partition == D_8x16 )
            {
                x264_me_refine_qpel( h, &amp;analysis.l0.me8x16[0] );
                x264_me_refine_qpel( h, &amp;analysis.l0.me8x16[1] );
                i_cost = analysis.l0.me8x16[0].cost + analysis.l0.me8x16[1].cost;
            }
            else if( i_partition == D_8x8 )
            {
                i_cost = 0;
                for( int i8x8 = 0; i8x8 &lt; 4; i8x8++ )
                {
                    switch( h-&gt;mb.i_sub_partition[i8x8] )
                    {
                        case D_L0_8x8:
                            x264_me_refine_qpel( h, &amp;analysis.l0.me8x8[i8x8] );
                            i_cost += analysis.l0.me8x8[i8x8].cost;
                            break;
                        case D_L0_8x4:
                            x264_me_refine_qpel( h, &amp;analysis.l0.me8x4[i8x8][0] );
                            x264_me_refine_qpel( h, &amp;analysis.l0.me8x4[i8x8][1] );
                            i_cost += analysis.l0.me8x4[i8x8][0].cost +
                                      analysis.l0.me8x4[i8x8][1].cost;
                            break;
                        case D_L0_4x8:
                            x264_me_refine_qpel( h, &amp;analysis.l0.me4x8[i8x8][0] );
                            x264_me_refine_qpel( h, &amp;analysis.l0.me4x8[i8x8][1] );
                            i_cost += analysis.l0.me4x8[i8x8][0].cost +
                                      analysis.l0.me4x8[i8x8][1].cost;
                            break;

                        case D_L0_4x4:
                            x264_me_refine_qpel( h, &amp;analysis.l0.me4x4[i8x8][0] );
                            x264_me_refine_qpel( h, &amp;analysis.l0.me4x4[i8x8][1] );
                            x264_me_refine_qpel( h, &amp;analysis.l0.me4x4[i8x8][2] );
                            x264_me_refine_qpel( h, &amp;analysis.l0.me4x4[i8x8][3] );
                            i_cost += analysis.l0.me4x4[i8x8][0].cost +
                                      analysis.l0.me4x4[i8x8][1].cost +
                                      analysis.l0.me4x4[i8x8][2].cost +
                                      analysis.l0.me4x4[i8x8][3].cost;
                            break;
                        default:
                            x264_log( h, X264_LOG_ERROR, &quot;internal error (!8x8 &amp;&amp; !4x4)\n&quot; );
                            break;
                    }
                }
            }

            if( h-&gt;mb.b_chroma_me )
            {
                if( CHROMA444 )
                {
                    x264_mb_analyse_intra( h, &amp;analysis, i_cost );
                    x264_mb_analyse_intra_chroma( h, &amp;analysis );
                }
                else
                {
                    x264_mb_analyse_intra_chroma( h, &amp;analysis );
                    x264_mb_analyse_intra( h, &amp;analysis, i_cost - analysis.i_satd_chroma );
                }
                analysis.i_satd_i16x16 += analysis.i_satd_chroma;
                analysis.i_satd_i8x8   += analysis.i_satd_chroma;
                analysis.i_satd_i4x4   += analysis.i_satd_chroma;
            }
            else
                x264_mb_analyse_intra( h, &amp;analysis, i_cost );//P Slice中也允许有Intra宏块，所以也要进行分析

            i_satd_inter = i_cost;
            i_satd_intra = X264_MIN3( analysis.i_satd_i16x16,
                                      analysis.i_satd_i8x8,
                                      analysis.i_satd_i4x4 );

            if( analysis.i_mbrd )
            {
                x264_mb_analyse_p_rd( h, &amp;analysis, X264_MIN(i_satd_inter, i_satd_intra) );
                i_type = P_L0;
                i_partition = D_16x16;
                i_cost = analysis.l0.i_rd16x16;
                COPY2_IF_LT( i_cost, analysis.l0.i_cost16x8, i_partition, D_16x8 );
                COPY2_IF_LT( i_cost, analysis.l0.i_cost8x16, i_partition, D_8x16 );
                COPY3_IF_LT( i_cost, analysis.l0.i_cost8x8, i_partition, D_8x8, i_type, P_8x8 );
                h-&gt;mb.i_type = i_type;
                h-&gt;mb.i_partition = i_partition;
                if( i_cost &lt; COST_MAX )
                    x264_mb_analyse_transform_rd( h, &amp;analysis, &amp;i_satd_inter, &amp;i_cost );
                x264_intra_rd( h, &amp;analysis, i_satd_inter * 5/4 + 1 );
            }
            //获取最小的代价
            COPY2_IF_LT( i_cost, analysis.i_satd_i16x16, i_type, I_16x16 );
            COPY2_IF_LT( i_cost, analysis.i_satd_i8x8, i_type, I_8x8 );
            COPY2_IF_LT( i_cost, analysis.i_satd_i4x4, i_type, I_4x4 );
            COPY2_IF_LT( i_cost, analysis.i_satd_pcm, i_type, I_PCM );

            h-&gt;mb.i_type = i_type;

            if( analysis.b_force_intra &amp;&amp; !IS_INTRA(i_type) )
            {
                /* Intra masking: copy fdec to fenc and re-encode the block as intra in order to make it appear as if
                 * it was an inter block. */
                x264_analyse_update_cache( h, &amp;analysis );
                x264_macroblock_encode( h );
                for( int p = 0; p &lt; (CHROMA444 ? 3 : 1); p++ )
                    h-&gt;mc.copy[PIXEL_16x16]( h-&gt;mb.pic.p_fenc[p], FENC_STRIDE, h-&gt;mb.pic.p_fdec[p], FDEC_STRIDE, 16 );
                if( !CHROMA444 )
                {
                    int height = 16 &gt;&gt; CHROMA_V_SHIFT;
                    h-&gt;mc.copy[PIXEL_8x8]  ( h-&gt;mb.pic.p_fenc[1], FENC_STRIDE, h-&gt;mb.pic.p_fdec[1], FDEC_STRIDE, height );
                    h-&gt;mc.copy[PIXEL_8x8]  ( h-&gt;mb.pic.p_fenc[2], FENC_STRIDE, h-&gt;mb.pic.p_fdec[2], FDEC_STRIDE, height );
                }
                x264_mb_analyse_init_qp( h, &amp;analysis, X264_MAX( h-&gt;mb.i_qp - h-&gt;mb.ip_offset, h-&gt;param.rc.i_qp_min ) );
                goto intra_analysis;
            }

            if( analysis.i_mbrd &gt;= 2 &amp;&amp; h-&gt;mb.i_type != I_PCM )
            {
                if( IS_INTRA( h-&gt;mb.i_type ) )
                {
                    x264_intra_rd_refine( h, &amp;analysis );
                }
                else if( i_partition == D_16x16 )
                {
                    x264_macroblock_cache_ref( h, 0, 0, 4, 4, 0, analysis.l0.me16x16.i_ref );
                    analysis.l0.me16x16.cost = i_cost;
                    x264_me_refine_qpel_rd( h, &amp;analysis.l0.me16x16, analysis.i_lambda2, 0, 0 );
                }
                else if( i_partition == D_16x8 )
                {
                    h-&gt;mb.i_sub_partition[0] = h-&gt;mb.i_sub_partition[1] =
                    h-&gt;mb.i_sub_partition[2] = h-&gt;mb.i_sub_partition[3] = D_L0_8x8;
                    x264_macroblock_cache_ref( h, 0, 0, 4, 2, 0, analysis.l0.me16x8[0].i_ref );
                    x264_macroblock_cache_ref( h, 0, 2, 4, 2, 0, analysis.l0.me16x8[1].i_ref );
                    x264_me_refine_qpel_rd( h, &amp;analysis.l0.me16x8[0], analysis.i_lambda2, 0, 0 );
                    x264_me_refine_qpel_rd( h, &amp;analysis.l0.me16x8[1], analysis.i_lambda2, 8, 0 );
                }
                else if( i_partition == D_8x16 )
                {
                    h-&gt;mb.i_sub_partition[0] = h-&gt;mb.i_sub_partition[1] =
                    h-&gt;mb.i_sub_partition[2] = h-&gt;mb.i_sub_partition[3] = D_L0_8x8;
                    x264_macroblock_cache_ref( h, 0, 0, 2, 4, 0, analysis.l0.me8x16[0].i_ref );
                    x264_macroblock_cache_ref( h, 2, 0, 2, 4, 0, analysis.l0.me8x16[1].i_ref );
                    x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x16[0], analysis.i_lambda2, 0, 0 );
                    x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x16[1], analysis.i_lambda2, 4, 0 );
                }
                else if( i_partition == D_8x8 )
                {
                    x264_analyse_update_cache( h, &amp;analysis );
                    for( int i8x8 = 0; i8x8 &lt; 4; i8x8++ )
                    {
                        if( h-&gt;mb.i_sub_partition[i8x8] == D_L0_8x8 )
                        {
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x8[i8x8], analysis.i_lambda2, i8x8*4, 0 );
                        }
                        else if( h-&gt;mb.i_sub_partition[i8x8] == D_L0_8x4 )
                        {
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x4[i8x8][0], analysis.i_lambda2, i8x8*4+0, 0 );
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x4[i8x8][1], analysis.i_lambda2, i8x8*4+2, 0 );
                        }
                        else if( h-&gt;mb.i_sub_partition[i8x8] == D_L0_4x8 )
                        {
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me4x8[i8x8][0], analysis.i_lambda2, i8x8*4+0, 0 );
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me4x8[i8x8][1], analysis.i_lambda2, i8x8*4+1, 0 );
                        }
                        else if( h-&gt;mb.i_sub_partition[i8x8] == D_L0_4x4 )
                        {
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me4x4[i8x8][0], analysis.i_lambda2, i8x8*4+0, 0 );
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me4x4[i8x8][1], analysis.i_lambda2, i8x8*4+1, 0 );
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me4x4[i8x8][2], analysis.i_lambda2, i8x8*4+2, 0 );
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me4x4[i8x8][3], analysis.i_lambda2, i8x8*4+3, 0 );
                        }
                    }
                }
            }
        }
    }
    else if( h-&gt;sh.i_type == SLICE_TYPE_B )//B Slice的时候
    {
        int i_bskip_cost = COST_MAX;
        int b_skip = 0;

        if( analysis.i_mbrd )
            x264_mb_init_fenc_cache( h, analysis.i_mbrd &gt;= 2 );

        h-&gt;mb.i_type = B_SKIP;
        if( h-&gt;mb.b_direct_auto_write )
        {
            /* direct=auto heuristic: prefer whichever mode allows more Skip macroblocks */
            for( int i = 0; i &lt; 2; i++ )
            {
                int b_changed = 1;
                h-&gt;sh.b_direct_spatial_mv_pred ^= 1;
                analysis.b_direct_available = x264_mb_predict_mv_direct16x16( h, i &amp;&amp; analysis.b_direct_available ? &amp;b_changed : NULL );
                if( analysis.b_direct_available )
                {
                    if( b_changed )
                    {
                        x264_mb_mc( h );
                        b_skip = x264_macroblock_probe_bskip( h );
                    }
                    h-&gt;stat.frame.i_direct_score[ h-&gt;sh.b_direct_spatial_mv_pred ] += b_skip;
                }
                else
                    b_skip = 0;
            }
        }
        else
            analysis.b_direct_available = x264_mb_predict_mv_direct16x16( h, NULL );

        analysis.b_try_skip = 0;
        if( analysis.b_direct_available )
        {
            if( !h-&gt;mb.b_direct_auto_write )
                x264_mb_mc( h );
            /* If the current macroblock is off the frame, just skip it. */
            if( HAVE_INTERLACED &amp;&amp; !MB_INTERLACED &amp;&amp; h-&gt;mb.i_mb_y * 16 &gt;= h-&gt;param.i_height )
                b_skip = 1;
            else if( analysis.i_mbrd )
            {
                i_bskip_cost = ssd_mb( h );
                /* 6 = minimum cavlc cost of a non-skipped MB */
                b_skip = h-&gt;mb.b_skip_mc = i_bskip_cost &lt;= ((6 * analysis.i_lambda2 + 128) &gt;&gt; 8);
            }
            else if( !h-&gt;mb.b_direct_auto_write )
            {
                /* Conditioning the probe on neighboring block types
                 * doesn't seem to help speed or quality. */
                analysis.b_try_skip = x264_macroblock_probe_bskip( h );
                if( h-&gt;param.analyse.i_subpel_refine &lt; 3 )
                    b_skip = analysis.b_try_skip;
            }
            /* Set up MVs for future predictors */
            if( b_skip )
            {
                for( int i = 0; i &lt; h-&gt;mb.pic.i_fref[0]; i++ )
                    M32( h-&gt;mb.mvr[0][i][h-&gt;mb.i_mb_xy] ) = 0;
                for( int i = 0; i &lt; h-&gt;mb.pic.i_fref[1]; i++ )
                    M32( h-&gt;mb.mvr[1][i][h-&gt;mb.i_mb_xy] ) = 0;
            }
        }

        if( !b_skip )
        {
            const unsigned int flags = h-&gt;param.analyse.inter;
            int i_type;
            int i_partition;
            int i_satd_inter;
            h-&gt;mb.b_skip_mc = 0;
            h-&gt;mb.i_type = B_DIRECT;

            x264_mb_analyse_load_costs( h, &amp;analysis );

            /* select best inter mode */
            /* direct must be first */
            if( analysis.b_direct_available )
                x264_mb_analyse_inter_direct( h, &amp;analysis );
        	/*
        	 * 16x16 帧间预测宏块分析-B
        	 *
        	 * +--------+--------+
        	 * |                 |
        	 * |                 |
        	 * |                 |
        	 * +        +        +
        	 * |                 |
        	 * |                 |
        	 * |                 |
        	 * +--------+--------+
        	 *
        	 */
            x264_mb_analyse_inter_b16x16( h, &amp;analysis );

            if( h-&gt;mb.i_type == B_SKIP )
            {
                for( int i = 1; i &lt; h-&gt;mb.pic.i_fref[0]; i++ )
                    M32( h-&gt;mb.mvr[0][i][h-&gt;mb.i_mb_xy] ) = 0;
                for( int i = 1; i &lt; h-&gt;mb.pic.i_fref[1]; i++ )
                    M32( h-&gt;mb.mvr[1][i][h-&gt;mb.i_mb_xy] ) = 0;
                return;
            }

            i_type = B_L0_L0;
            i_partition = D_16x16;
            i_cost = analysis.l0.me16x16.cost;
            COPY2_IF_LT( i_cost, analysis.l1.me16x16.cost, i_type, B_L1_L1 );
            COPY2_IF_LT( i_cost, analysis.i_cost16x16bi, i_type, B_BI_BI );
            COPY2_IF_LT( i_cost, analysis.i_cost16x16direct, i_type, B_DIRECT );

            if( analysis.i_mbrd &amp;&amp; analysis.b_early_terminate &amp;&amp; analysis.i_cost16x16direct &lt;= i_cost * 33/32 )
            {
                x264_mb_analyse_b_rd( h, &amp;analysis, i_cost );
                if( i_bskip_cost &lt; analysis.i_rd16x16direct &amp;&amp;
                    i_bskip_cost &lt; analysis.i_rd16x16bi &amp;&amp;
                    i_bskip_cost &lt; analysis.l0.i_rd16x16 &amp;&amp;
                    i_bskip_cost &lt; analysis.l1.i_rd16x16 )
                {
                    h-&gt;mb.i_type = B_SKIP;
                    x264_analyse_update_cache( h, &amp;analysis );
                    return;
                }
            }

            if( flags &amp; X264_ANALYSE_BSUB16x16 )
            {

            	/*
				 * 8x8 帧间预测宏块分析-B
				 * +--------+
				 * |        |
				 * |        |
				 * |        |
				 * +--------+
				 *
				 */

                if( h-&gt;param.analyse.b_mixed_references )
                    x264_mb_analyse_inter_b8x8_mixed_ref( h, &amp;analysis );
                else
                    x264_mb_analyse_inter_b8x8( h, &amp;analysis );

                COPY3_IF_LT( i_cost, analysis.i_cost8x8bi, i_type, B_8x8, i_partition, D_8x8 );

                /* Try to estimate the cost of b16x8/b8x16 based on the satd scores of the b8x8 modes */
                int i_cost_est16x8bi_total = 0, i_cost_est8x16bi_total = 0;
                int i_mb_type, i_partition16x8[2], i_partition8x16[2];
                for( int i = 0; i &lt; 2; i++ )
                {
                    int avg_l0_mv_ref_cost, avg_l1_mv_ref_cost;
                    int i_l0_satd, i_l1_satd, i_bi_satd, i_best_cost;
                    // 16x8
                    i_best_cost = COST_MAX;
                    i_l0_satd = analysis.i_satd8x8[0][i*2] + analysis.i_satd8x8[0][i*2+1];
                    i_l1_satd = analysis.i_satd8x8[1][i*2] + analysis.i_satd8x8[1][i*2+1];
                    i_bi_satd = analysis.i_satd8x8[2][i*2] + analysis.i_satd8x8[2][i*2+1];
                    avg_l0_mv_ref_cost = ( analysis.l0.me8x8[i*2].cost_mv + analysis.l0.me8x8[i*2].i_ref_cost
                                         + analysis.l0.me8x8[i*2+1].cost_mv + analysis.l0.me8x8[i*2+1].i_ref_cost + 1 ) &gt;&gt; 1;
                    avg_l1_mv_ref_cost = ( analysis.l1.me8x8[i*2].cost_mv + analysis.l1.me8x8[i*2].i_ref_cost
                                         + analysis.l1.me8x8[i*2+1].cost_mv + analysis.l1.me8x8[i*2+1].i_ref_cost + 1 ) &gt;&gt; 1;
                    COPY2_IF_LT( i_best_cost, i_l0_satd + avg_l0_mv_ref_cost, i_partition16x8[i], D_L0_8x8 );
                    COPY2_IF_LT( i_best_cost, i_l1_satd + avg_l1_mv_ref_cost, i_partition16x8[i], D_L1_8x8 );
                    COPY2_IF_LT( i_best_cost, i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost, i_partition16x8[i], D_BI_8x8 );
                    analysis.i_cost_est16x8[i] = i_best_cost;

                    // 8x16
                    i_best_cost = COST_MAX;
                    i_l0_satd = analysis.i_satd8x8[0][i] + analysis.i_satd8x8[0][i+2];
                    i_l1_satd = analysis.i_satd8x8[1][i] + analysis.i_satd8x8[1][i+2];
                    i_bi_satd = analysis.i_satd8x8[2][i] + analysis.i_satd8x8[2][i+2];
                    avg_l0_mv_ref_cost = ( analysis.l0.me8x8[i].cost_mv + analysis.l0.me8x8[i].i_ref_cost
                                         + analysis.l0.me8x8[i+2].cost_mv + analysis.l0.me8x8[i+2].i_ref_cost + 1 ) &gt;&gt; 1;
                    avg_l1_mv_ref_cost = ( analysis.l1.me8x8[i].cost_mv + analysis.l1.me8x8[i].i_ref_cost
                                         + analysis.l1.me8x8[i+2].cost_mv + analysis.l1.me8x8[i+2].i_ref_cost + 1 ) &gt;&gt; 1;
                    COPY2_IF_LT( i_best_cost, i_l0_satd + avg_l0_mv_ref_cost, i_partition8x16[i], D_L0_8x8 );
                    COPY2_IF_LT( i_best_cost, i_l1_satd + avg_l1_mv_ref_cost, i_partition8x16[i], D_L1_8x8 );
                    COPY2_IF_LT( i_best_cost, i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost, i_partition8x16[i], D_BI_8x8 );
                    analysis.i_cost_est8x16[i] = i_best_cost;
                }
                i_mb_type = B_L0_L0 + (i_partition16x8[0]&gt;&gt;2) * 3 + (i_partition16x8[1]&gt;&gt;2);
                analysis.i_cost_est16x8[1] += analysis.i_lambda * i_mb_b16x8_cost_table[i_mb_type];
                i_cost_est16x8bi_total = analysis.i_cost_est16x8[0] + analysis.i_cost_est16x8[1];
                i_mb_type = B_L0_L0 + (i_partition8x16[0]&gt;&gt;2) * 3 + (i_partition8x16[1]&gt;&gt;2);
                analysis.i_cost_est8x16[1] += analysis.i_lambda * i_mb_b16x8_cost_table[i_mb_type];
                i_cost_est8x16bi_total = analysis.i_cost_est8x16[0] + analysis.i_cost_est8x16[1];

                /* We can gain a little speed by checking the mode with the lowest estimated cost first */
                int try_16x8_first = i_cost_est16x8bi_total &lt; i_cost_est8x16bi_total;
                if( try_16x8_first &amp;&amp; (!analysis.b_early_terminate || i_cost_est16x8bi_total &lt; i_cost) )
                {
                    x264_mb_analyse_inter_b16x8( h, &amp;analysis, i_cost );
                    COPY3_IF_LT( i_cost, analysis.i_cost16x8bi, i_type, analysis.i_mb_type16x8, i_partition, D_16x8 );
                }
                if( !analysis.b_early_terminate || i_cost_est8x16bi_total &lt; i_cost )
                {
                    x264_mb_analyse_inter_b8x16( h, &amp;analysis, i_cost );
                    COPY3_IF_LT( i_cost, analysis.i_cost8x16bi, i_type, analysis.i_mb_type8x16, i_partition, D_8x16 );
                }
                if( !try_16x8_first &amp;&amp; (!analysis.b_early_terminate || i_cost_est16x8bi_total &lt; i_cost) )
                {
                    x264_mb_analyse_inter_b16x8( h, &amp;analysis, i_cost );
                    COPY3_IF_LT( i_cost, analysis.i_cost16x8bi, i_type, analysis.i_mb_type16x8, i_partition, D_16x8 );
                }
            }

            if( analysis.i_mbrd || !h-&gt;mb.i_subpel_refine )
            {
                /* refine later */
            }
            /* refine qpel */
            else if( i_partition == D_16x16 )
            {
                analysis.l0.me16x16.cost -= analysis.i_lambda * i_mb_b_cost_table[B_L0_L0];
                analysis.l1.me16x16.cost -= analysis.i_lambda * i_mb_b_cost_table[B_L1_L1];
                if( i_type == B_L0_L0 )
                {
                    x264_me_refine_qpel( h, &amp;analysis.l0.me16x16 );
                    i_cost = analysis.l0.me16x16.cost
                           + analysis.i_lambda * i_mb_b_cost_table[B_L0_L0];
                }
                else if( i_type == B_L1_L1 )
                {
                    x264_me_refine_qpel( h, &amp;analysis.l1.me16x16 );
                    i_cost = analysis.l1.me16x16.cost
                           + analysis.i_lambda * i_mb_b_cost_table[B_L1_L1];
                }
                else if( i_type == B_BI_BI )
                {
                    x264_me_refine_qpel( h, &amp;analysis.l0.bi16x16 );
                    x264_me_refine_qpel( h, &amp;analysis.l1.bi16x16 );
                }
            }
            else if( i_partition == D_16x8 )
            {
                for( int i = 0; i &lt; 2; i++ )
                {
                    if( analysis.i_mb_partition16x8[i] != D_L1_8x8 )
                        x264_me_refine_qpel( h, &amp;analysis.l0.me16x8[i] );
                    if( analysis.i_mb_partition16x8[i] != D_L0_8x8 )
                        x264_me_refine_qpel( h, &amp;analysis.l1.me16x8[i] );
                }
            }
            else if( i_partition == D_8x16 )
            {
                for( int i = 0; i &lt; 2; i++ )
                {
                    if( analysis.i_mb_partition8x16[i] != D_L1_8x8 )
                        x264_me_refine_qpel( h, &amp;analysis.l0.me8x16[i] );
                    if( analysis.i_mb_partition8x16[i] != D_L0_8x8 )
                        x264_me_refine_qpel( h, &amp;analysis.l1.me8x16[i] );
                }
            }
            else if( i_partition == D_8x8 )
            {
                for( int i = 0; i &lt; 4; i++ )
                {
                    x264_me_t *m;
                    int i_part_cost_old;
                    int i_type_cost;
                    int i_part_type = h-&gt;mb.i_sub_partition[i];
                    int b_bidir = (i_part_type == D_BI_8x8);

                    if( i_part_type == D_DIRECT_8x8 )
                        continue;
                    if( x264_mb_partition_listX_table[0][i_part_type] )
                    {
                        m = &amp;analysis.l0.me8x8[i];
                        i_part_cost_old = m-&gt;cost;
                        i_type_cost = analysis.i_lambda * i_sub_mb_b_cost_table[D_L0_8x8];
                        m-&gt;cost -= i_type_cost;
                        x264_me_refine_qpel( h, m );
                        if( !b_bidir )
                            analysis.i_cost8x8bi += m-&gt;cost + i_type_cost - i_part_cost_old;
                    }
                    if( x264_mb_partition_listX_table[1][i_part_type] )
                    {
                        m = &amp;analysis.l1.me8x8[i];
                        i_part_cost_old = m-&gt;cost;
                        i_type_cost = analysis.i_lambda * i_sub_mb_b_cost_table[D_L1_8x8];
                        m-&gt;cost -= i_type_cost;
                        x264_me_refine_qpel( h, m );
                        if( !b_bidir )
                            analysis.i_cost8x8bi += m-&gt;cost + i_type_cost - i_part_cost_old;
                    }
                    /* TODO: update mvp? */
                }
            }

            i_satd_inter = i_cost;

            if( analysis.i_mbrd )
            {
                x264_mb_analyse_b_rd( h, &amp;analysis, i_satd_inter );
                i_type = B_SKIP;
                i_cost = i_bskip_cost;
                i_partition = D_16x16;
                COPY2_IF_LT( i_cost, analysis.l0.i_rd16x16, i_type, B_L0_L0 );
                COPY2_IF_LT( i_cost, analysis.l1.i_rd16x16, i_type, B_L1_L1 );
                COPY2_IF_LT( i_cost, analysis.i_rd16x16bi, i_type, B_BI_BI );
                COPY2_IF_LT( i_cost, analysis.i_rd16x16direct, i_type, B_DIRECT );
                COPY3_IF_LT( i_cost, analysis.i_rd16x8bi, i_type, analysis.i_mb_type16x8, i_partition, D_16x8 );
                COPY3_IF_LT( i_cost, analysis.i_rd8x16bi, i_type, analysis.i_mb_type8x16, i_partition, D_8x16 );
                COPY3_IF_LT( i_cost, analysis.i_rd8x8bi, i_type, B_8x8, i_partition, D_8x8 );

                h-&gt;mb.i_type = i_type;
                h-&gt;mb.i_partition = i_partition;
            }

            if( h-&gt;mb.b_chroma_me )
            {
                if( CHROMA444 )
                {
                    x264_mb_analyse_intra( h, &amp;analysis, i_satd_inter );
                    x264_mb_analyse_intra_chroma( h, &amp;analysis );
                }
                else
                {
                    x264_mb_analyse_intra_chroma( h, &amp;analysis );
                    x264_mb_analyse_intra( h, &amp;analysis, i_satd_inter - analysis.i_satd_chroma );
                }
                analysis.i_satd_i16x16 += analysis.i_satd_chroma;
                analysis.i_satd_i8x8   += analysis.i_satd_chroma;
                analysis.i_satd_i4x4   += analysis.i_satd_chroma;
            }
            else
                x264_mb_analyse_intra( h, &amp;analysis, i_satd_inter );

            if( analysis.i_mbrd )
            {
                x264_mb_analyse_transform_rd( h, &amp;analysis, &amp;i_satd_inter, &amp;i_cost );
                x264_intra_rd( h, &amp;analysis, i_satd_inter * 17/16 + 1 );
            }

            COPY2_IF_LT( i_cost, analysis.i_satd_i16x16, i_type, I_16x16 );
            COPY2_IF_LT( i_cost, analysis.i_satd_i8x8, i_type, I_8x8 );
            COPY2_IF_LT( i_cost, analysis.i_satd_i4x4, i_type, I_4x4 );
            COPY2_IF_LT( i_cost, analysis.i_satd_pcm, i_type, I_PCM );

            h-&gt;mb.i_type = i_type;
            h-&gt;mb.i_partition = i_partition;

            if( analysis.i_mbrd &gt;= 2 &amp;&amp; IS_INTRA( i_type ) &amp;&amp; i_type != I_PCM )
                x264_intra_rd_refine( h, &amp;analysis );
            if( h-&gt;mb.i_subpel_refine &gt;= 5 )
                x264_refine_bidir( h, &amp;analysis );

            if( analysis.i_mbrd &gt;= 2 &amp;&amp; i_type &gt; B_DIRECT &amp;&amp; i_type &lt; B_SKIP )
            {
                int i_biweight;
                x264_analyse_update_cache( h, &amp;analysis );

                if( i_partition == D_16x16 )
                {
                    if( i_type == B_L0_L0 )
                    {
                        analysis.l0.me16x16.cost = i_cost;
                        x264_me_refine_qpel_rd( h, &amp;analysis.l0.me16x16, analysis.i_lambda2, 0, 0 );
                    }
                    else if( i_type == B_L1_L1 )
                    {
                        analysis.l1.me16x16.cost = i_cost;
                        x264_me_refine_qpel_rd( h, &amp;analysis.l1.me16x16, analysis.i_lambda2, 0, 1 );
                    }
                    else if( i_type == B_BI_BI )
                    {
                        i_biweight = h-&gt;mb.bipred_weight[analysis.l0.bi16x16.i_ref][analysis.l1.bi16x16.i_ref];
                        x264_me_refine_bidir_rd( h, &amp;analysis.l0.bi16x16, &amp;analysis.l1.bi16x16, i_biweight, 0, analysis.i_lambda2 );
                    }
                }
                else if( i_partition == D_16x8 )
                {
                    for( int i = 0; i &lt; 2; i++ )
                    {
                        h-&gt;mb.i_sub_partition[i*2] = h-&gt;mb.i_sub_partition[i*2+1] = analysis.i_mb_partition16x8[i];
                        if( analysis.i_mb_partition16x8[i] == D_L0_8x8 )
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me16x8[i], analysis.i_lambda2, i*8, 0 );
                        else if( analysis.i_mb_partition16x8[i] == D_L1_8x8 )
                            x264_me_refine_qpel_rd( h, &amp;analysis.l1.me16x8[i], analysis.i_lambda2, i*8, 1 );
                        else if( analysis.i_mb_partition16x8[i] == D_BI_8x8 )
                        {
                            i_biweight = h-&gt;mb.bipred_weight[analysis.l0.me16x8[i].i_ref][analysis.l1.me16x8[i].i_ref];
                            x264_me_refine_bidir_rd( h, &amp;analysis.l0.me16x8[i], &amp;analysis.l1.me16x8[i], i_biweight, i*2, analysis.i_lambda2 );
                        }
                    }
                }
                else if( i_partition == D_8x16 )
                {
                    for( int i = 0; i &lt; 2; i++ )
                    {
                        h-&gt;mb.i_sub_partition[i] = h-&gt;mb.i_sub_partition[i+2] = analysis.i_mb_partition8x16[i];
                        if( analysis.i_mb_partition8x16[i] == D_L0_8x8 )
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x16[i], analysis.i_lambda2, i*4, 0 );
                        else if( analysis.i_mb_partition8x16[i] == D_L1_8x8 )
                            x264_me_refine_qpel_rd( h, &amp;analysis.l1.me8x16[i], analysis.i_lambda2, i*4, 1 );
                        else if( analysis.i_mb_partition8x16[i] == D_BI_8x8 )
                        {
                            i_biweight = h-&gt;mb.bipred_weight[analysis.l0.me8x16[i].i_ref][analysis.l1.me8x16[i].i_ref];
                            x264_me_refine_bidir_rd( h, &amp;analysis.l0.me8x16[i], &amp;analysis.l1.me8x16[i], i_biweight, i, analysis.i_lambda2 );
                        }
                    }
                }
                else if( i_partition == D_8x8 )
                {
                    for( int i = 0; i &lt; 4; i++ )
                    {
                        if( h-&gt;mb.i_sub_partition[i] == D_L0_8x8 )
                            x264_me_refine_qpel_rd( h, &amp;analysis.l0.me8x8[i], analysis.i_lambda2, i*4, 0 );
                        else if( h-&gt;mb.i_sub_partition[i] == D_L1_8x8 )
                            x264_me_refine_qpel_rd( h, &amp;analysis.l1.me8x8[i], analysis.i_lambda2, i*4, 1 );
                        else if( h-&gt;mb.i_sub_partition[i] == D_BI_8x8 )
                        {
                            i_biweight = h-&gt;mb.bipred_weight[analysis.l0.me8x8[i].i_ref][analysis.l1.me8x8[i].i_ref];
                            x264_me_refine_bidir_rd( h, &amp;analysis.l0.me8x8[i], &amp;analysis.l1.me8x8[i], i_biweight, i, analysis.i_lambda2 );
                        }
                    }
                }
            }
        }
    }

    x264_analyse_update_cache( h, &amp;analysis );

    /* In rare cases we can end up qpel-RDing our way back to a larger partition size
     * without realizing it.  Check for this and account for it if necessary. */
    if( analysis.i_mbrd &gt;= 2 )
    {
        /* Don't bother with bipred or 8x8-and-below, the odds are incredibly low. */
        static const uint8_t check_mv_lists[X264_MBTYPE_MAX] = {[P_L0]=1, [B_L0_L0]=1, [B_L1_L1]=2};
        int list = check_mv_lists[h-&gt;mb.i_type] - 1;
        if( list &gt;= 0 &amp;&amp; h-&gt;mb.i_partition != D_16x16 &amp;&amp;
            M32( &amp;h-&gt;mb.cache.mv[list][x264_scan8[0]] ) == M32( &amp;h-&gt;mb.cache.mv[list][x264_scan8[12]] ) &amp;&amp;
            h-&gt;mb.cache.ref[list][x264_scan8[0]] == h-&gt;mb.cache.ref[list][x264_scan8[12]] )
                h-&gt;mb.i_partition = D_16x16;
    }

    if( !analysis.i_mbrd )
        x264_mb_analyse_transform( h );

    if( analysis.i_mbrd == 3 &amp;&amp; !IS_SKIP(h-&gt;mb.i_type) )
        x264_mb_analyse_qp_rd( h, &amp;analysis );

    h-&gt;mb.b_trellis = h-&gt;param.analyse.i_trellis;
    h-&gt;mb.b_noise_reduction = h-&gt;mb.b_noise_reduction || (!!h-&gt;param.analyse.i_noise_reduction &amp;&amp; !IS_INTRA( h-&gt;mb.i_type ));

    if( !IS_SKIP(h-&gt;mb.i_type) &amp;&amp; h-&gt;mb.i_psy_trellis &amp;&amp; h-&gt;param.analyse.i_trellis == 1 )
        x264_psy_trellis_init( h, 0 );
    if( h-&gt;mb.b_trellis == 1 || h-&gt;mb.b_noise_reduction )
        h-&gt;mb.i_skip_intra = 0;
}
</pre><br />尽管x264_macroblock_analyse()的源代码比较长，但是它的逻辑比较清晰，如下所示：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）如果当前是I Slice，调用x264_mb_analyse_intra()进行Intra宏块的帧内预测模式分析。<br />（2）如果当前是P Slice，则进行下面流程的分析：<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用x264_macroblock_probe_pskip()分析是否为Skip宏块，如果是的话则不再进行下面分析。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)调用x264_mb_analyse_inter_p16x16()分析P16x16帧间预测的代价。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)调用x264_mb_analyse_inter_p8x8()分析P8x8帧间预测的代价。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">d)如果P8x8代价值小于P16x16，则依次对4个8x8的子宏块分割进行判断：</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">i.调用x264_mb_analyse_inter_p4x4()分析P4x4帧间预测的代价。</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ii.如果P4x4代价值小于P8x8，则调用 x264_mb_analyse_inter_p8x4()和x264_mb_analyse_inter_p4x8()分析P8x4和P4x8帧间预测的代价。</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">e)如果P8x8代价值小于P16x16，调用x264_mb_analyse_inter_p16x8()和x264_mb_analyse_inter_p8x16()分析P16x8和P8x16帧间预测的代价。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">f)此外还要调用x264_mb_analyse_intra()，检查当前宏块作为Intra宏块编码的代价是否小于作为P宏块编码的代价（P Slice中也允许有Intra宏块）。</blockquote>（3）如果当前是B Slice，则进行和P Slice类似的处理。</blockquote><p>本文记录这一流程中Intra宏块的帧内预测模式分析函数x264_mb_analyse_intra()。</p><br /><br /><h2>x264_mb_analyse_intra()</h2>x264_mb_analyse_intra()用于对Intra宏块进行帧内预测模式的分析。该函数的定义位于encoder\analyse.c，如下所示。<br /><pre name="code" class="cpp">//帧内预测分析-从16x16的SAD,4个8x8的SAD和，16个4x4SAD中选出最优方式
static void x264_mb_analyse_intra( x264_t *h, x264_mb_analysis_t *a, int i_satd_inter )
{
    const unsigned int flags = h-&gt;sh.i_type == SLICE_TYPE_I ? h-&gt;param.analyse.intra : h-&gt;param.analyse.inter;
    //计算
    //p_fenc是编码帧
    pixel *p_src = h-&gt;mb.pic.p_fenc[0];
    //p_fdec是重建帧
    pixel *p_dst = h-&gt;mb.pic.p_fdec[0];

    static const int8_t intra_analysis_shortcut[2][2][2][5] =
    {
        {{{I_PRED_4x4_HU, -1, -1, -1, -1},
          {I_PRED_4x4_DDL, I_PRED_4x4_VL, -1, -1, -1}},
         {{I_PRED_4x4_DDR, I_PRED_4x4_HD, I_PRED_4x4_HU, -1, -1},
          {I_PRED_4x4_DDL, I_PRED_4x4_DDR, I_PRED_4x4_VR, I_PRED_4x4_VL, -1}}},
        {{{I_PRED_4x4_HU, -1, -1, -1, -1},
          {-1, -1, -1, -1, -1}},
         {{I_PRED_4x4_DDR, I_PRED_4x4_HD, I_PRED_4x4_HU, -1, -1},
          {I_PRED_4x4_DDR, I_PRED_4x4_VR, -1, -1, -1}}},
    };

    int idx;
    int lambda = a-&gt;i_lambda;

    /*---------------- Try all mode and calculate their score ---------------*/
    /* Disabled i16x16 for AVC-Intra compat */
    //帧内16x16
    if( !h-&gt;param.i_avcintra_class )
    {
    	//获得可用的帧内预测模式-针对帧内16x16
    	/*
    	 * 16x16块
    	 *
    	 * +--------+--------+
    	 * |                 |
    	 * |                 |
    	 * |                 |
    	 * +        +        +
    	 * |                 |
    	 * |                 |
    	 * |                 |
    	 * +--------+--------+
    	 *
    	 */
    	//左侧是否有可用数据？上方是否有可用数据？
        const int8_t *predict_mode = predict_16x16_mode_available( h-&gt;mb.i_neighbour_intra );

        /* Not heavily tuned */
        static const uint8_t i16x16_thresh_lut[11] = { 2, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4 };
        int i16x16_thresh = a-&gt;b_fast_intra ? (i16x16_thresh_lut[h-&gt;mb.i_subpel_refine]*i_satd_inter)&gt;&gt;1 : COST_MAX;

        if( !h-&gt;mb.b_lossless &amp;&amp; predict_mode[3] &gt;= 0 )
        {
            h-&gt;pixf.intra_mbcmp_x3_16x16( p_src, p_dst, a-&gt;i_satd_i16x16_dir );
            a-&gt;i_satd_i16x16_dir[0] += lambda * bs_size_ue(0);
            a-&gt;i_satd_i16x16_dir[1] += lambda * bs_size_ue(1);
            a-&gt;i_satd_i16x16_dir[2] += lambda * bs_size_ue(2);
            COPY2_IF_LT( a-&gt;i_satd_i16x16, a-&gt;i_satd_i16x16_dir[0], a-&gt;i_predict16x16, 0 );
            COPY2_IF_LT( a-&gt;i_satd_i16x16, a-&gt;i_satd_i16x16_dir[1], a-&gt;i_predict16x16, 1 );
            COPY2_IF_LT( a-&gt;i_satd_i16x16, a-&gt;i_satd_i16x16_dir[2], a-&gt;i_predict16x16, 2 );

            /* Plane is expensive, so don't check it unless one of the previous modes was useful. */
            if( a-&gt;i_satd_i16x16 &lt;= i16x16_thresh )
            {
                h-&gt;predict_16x16[I_PRED_16x16_P]( p_dst );
                a-&gt;i_satd_i16x16_dir[I_PRED_16x16_P] = h-&gt;pixf.mbcmp[PIXEL_16x16]( p_dst, FDEC_STRIDE, p_src, FENC_STRIDE );
                a-&gt;i_satd_i16x16_dir[I_PRED_16x16_P] += lambda * bs_size_ue(3);
                COPY2_IF_LT( a-&gt;i_satd_i16x16, a-&gt;i_satd_i16x16_dir[I_PRED_16x16_P], a-&gt;i_predict16x16, 3 );
            }
        }
        else
        {
        	//遍历所有的可用的Intra16x16帧内预测模式
        	//最多4种
            for( ; *predict_mode &gt;= 0; predict_mode++ )
            {
                int i_satd;
                int i_mode = *predict_mode;

                //帧内预测汇编函数：根据左边和上边的像素计算出预测值
                /*
				 * 帧内预测举例
				 * Vertical预测方式
				 *    |X1 X2 ... X16
				 *  --+---------------
				 *    |X1 X2 ... X16
				 *    |X1 X2 ... X16
				 *    |.. .. ... X16
				 *    |X1 X2 ... X16
				 *
				 * Horizontal预测方式
				 *    |
				 *  --+---------------
				 *  X1| X1  X1 ...  X1
				 *  X2| X2  X2 ...  X2
				 *  ..| ..  .. ...  ..
				 * X16|X16 X16 ... X16
				 *
				 * DC预测方式
				 *    |X1 X2 ... X16
				 *  --+---------------
				 * X17|
				 * X18|     Y
				 *  ..|
				 * X32|
				 *
				 * Y=(X1+X2+X3+X4+...+X31+X32)/32
				 *
				 */
                if( h-&gt;mb.b_lossless )
                    x264_predict_lossless_16x16( h, 0, i_mode );
                else
                    h-&gt;predict_16x16[i_mode]( p_dst );//计算结果存储在p_dst重建帧中

                //计算SAD或者是SATD（SATD(transformed)是经过Hadamard变换之后的SAD）
                //即编码代价
                //数据位于p_dst和p_src
                i_satd = h-&gt;pixf.mbcmp[PIXEL_16x16]( p_dst, FDEC_STRIDE, p_src, FENC_STRIDE ) +
                         lambda * bs_size_ue( x264_mb_pred_mode16x16_fix[i_mode] );

                //COPY2_IF_LT()函数的意思是“copy if little”。即如果值更小（代价更小），就拷贝。
                //宏定义展开后如下所示
                //if((i_satd)&lt;(a-&gt;i_satd_i16x16))
                //{
                //    (a-&gt;i_satd_i16x16)=(i_satd);
                //    (a-&gt;i_predict16x16)=(i_mode);
                //}
                COPY2_IF_LT( a-&gt;i_satd_i16x16, i_satd, a-&gt;i_predict16x16, i_mode );
                //每种模式的代价都会存储
                a-&gt;i_satd_i16x16_dir[i_mode] = i_satd;
            }
        }

        if( h-&gt;sh.i_type == SLICE_TYPE_B )
            /* cavlc mb type prefix */
            a-&gt;i_satd_i16x16 += lambda * i_mb_b_cost_table[I_16x16];

        if( a-&gt;i_satd_i16x16 &gt; i16x16_thresh )
            return;
    }

    uint16_t *cost_i4x4_mode = (uint16_t*)ALIGN((intptr_t)x264_cost_i4x4_mode,64) + a-&gt;i_qp*32 + 8;
    /* 8x8 prediction selection */
    //帧内8x8（没研究过）
    if( flags &amp; X264_ANALYSE_I8x8 )
    {
        ALIGNED_ARRAY_32( pixel, edge,[36] );
        x264_pixel_cmp_t sa8d = (h-&gt;pixf.mbcmp[0] == h-&gt;pixf.satd[0]) ? h-&gt;pixf.sa8d[PIXEL_8x8] : h-&gt;pixf.mbcmp[PIXEL_8x8];
        int i_satd_thresh = a-&gt;i_mbrd ? COST_MAX : X264_MIN( i_satd_inter, a-&gt;i_satd_i16x16 );

        // FIXME some bias like in i4x4?
        int i_cost = lambda * 4; /* base predmode costs */
        h-&gt;mb.i_cbp_luma = 0;

        if( h-&gt;sh.i_type == SLICE_TYPE_B )
            i_cost += lambda * i_mb_b_cost_table[I_8x8];

        for( idx = 0;; idx++ )
        {
            int x = idx&amp;1;
            int y = idx&gt;&gt;1;
            pixel *p_src_by = p_src + 8*x + 8*y*FENC_STRIDE;
            pixel *p_dst_by = p_dst + 8*x + 8*y*FDEC_STRIDE;
            int i_best = COST_MAX;
            int i_pred_mode = x264_mb_predict_intra4x4_mode( h, 4*idx );

            const int8_t *predict_mode = predict_8x8_mode_available( a-&gt;b_avoid_topright, h-&gt;mb.i_neighbour8[idx], idx );
            h-&gt;predict_8x8_filter( p_dst_by, edge, h-&gt;mb.i_neighbour8[idx], ALL_NEIGHBORS );

            if( h-&gt;pixf.intra_mbcmp_x9_8x8 &amp;&amp; predict_mode[8] &gt;= 0 )
            {
                /* No shortcuts here. The SSSE3 implementation of intra_mbcmp_x9 is fast enough. */
                i_best = h-&gt;pixf.intra_mbcmp_x9_8x8( p_src_by, p_dst_by, edge, cost_i4x4_mode-i_pred_mode, a-&gt;i_satd_i8x8_dir[idx] );
                i_cost += i_best &amp; 0xffff;
                i_best &gt;&gt;= 16;
                a-&gt;i_predict8x8[idx] = i_best;
                if( idx == 3 || i_cost &gt; i_satd_thresh )
                    break;
                x264_macroblock_cache_intra8x8_pred( h, 2*x, 2*y, i_best );
            }
            else
            {
                if( !h-&gt;mb.b_lossless &amp;&amp; predict_mode[5] &gt;= 0 )
                {
                    ALIGNED_ARRAY_16( int32_t, satd,[9] );
                    h-&gt;pixf.intra_mbcmp_x3_8x8( p_src_by, edge, satd );
                    int favor_vertical = satd[I_PRED_4x4_H] &gt; satd[I_PRED_4x4_V];
                    satd[i_pred_mode] -= 3 * lambda;
                    for( int i = 2; i &gt;= 0; i-- )
                    {
                        int cost = satd[i];
                        a-&gt;i_satd_i8x8_dir[idx][i] = cost + 4 * lambda;
                        COPY2_IF_LT( i_best, cost, a-&gt;i_predict8x8[idx], i );
                    }

                    /* Take analysis shortcuts: don't analyse modes that are too
                     * far away direction-wise from the favored mode. */
                    if( a-&gt;i_mbrd &lt; 1 + a-&gt;b_fast_intra )
                        predict_mode = intra_analysis_shortcut[a-&gt;b_avoid_topright][predict_mode[8] &gt;= 0][favor_vertical];
                    else
                        predict_mode += 3;
                }

                for( ; *predict_mode &gt;= 0 &amp;&amp; (i_best &gt;= 0 || a-&gt;i_mbrd &gt;= 2); predict_mode++ )
                {
                    int i_satd;
                    int i_mode = *predict_mode;

                    if( h-&gt;mb.b_lossless )
                        x264_predict_lossless_8x8( h, p_dst_by, 0, idx, i_mode, edge );
                    else
                        h-&gt;predict_8x8[i_mode]( p_dst_by, edge );

                    i_satd = sa8d( p_dst_by, FDEC_STRIDE, p_src_by, FENC_STRIDE );
                    if( i_pred_mode == x264_mb_pred_mode4x4_fix(i_mode) )
                        i_satd -= 3 * lambda;

                    COPY2_IF_LT( i_best, i_satd, a-&gt;i_predict8x8[idx], i_mode );
                    a-&gt;i_satd_i8x8_dir[idx][i_mode] = i_satd + 4 * lambda;
                }
                i_cost += i_best + 3*lambda;

                if( idx == 3 || i_cost &gt; i_satd_thresh )
                    break;
                if( h-&gt;mb.b_lossless )
                    x264_predict_lossless_8x8( h, p_dst_by, 0, idx, a-&gt;i_predict8x8[idx], edge );
                else
                    h-&gt;predict_8x8[a-&gt;i_predict8x8[idx]]( p_dst_by, edge );
                x264_macroblock_cache_intra8x8_pred( h, 2*x, 2*y, a-&gt;i_predict8x8[idx] );
            }
            /* we need to encode this block now (for next ones) */
            x264_mb_encode_i8x8( h, 0, idx, a-&gt;i_qp, a-&gt;i_predict8x8[idx], edge, 0 );
        }

        if( idx == 3 )
        {
            a-&gt;i_satd_i8x8 = i_cost;
            if( h-&gt;mb.i_skip_intra )
            {
                h-&gt;mc.copy[PIXEL_16x16]( h-&gt;mb.pic.i8x8_fdec_buf, 16, p_dst, FDEC_STRIDE, 16 );
                h-&gt;mb.pic.i8x8_nnz_buf[0] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 0]] );
                h-&gt;mb.pic.i8x8_nnz_buf[1] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 2]] );
                h-&gt;mb.pic.i8x8_nnz_buf[2] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 8]] );
                h-&gt;mb.pic.i8x8_nnz_buf[3] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[10]] );
                h-&gt;mb.pic.i8x8_cbp = h-&gt;mb.i_cbp_luma;
                if( h-&gt;mb.i_skip_intra == 2 )
                    h-&gt;mc.memcpy_aligned( h-&gt;mb.pic.i8x8_dct_buf, h-&gt;dct.luma8x8, sizeof(h-&gt;mb.pic.i8x8_dct_buf) );
            }
        }
        else
        {
            static const uint16_t cost_div_fix8[3] = {1024,512,341};
            a-&gt;i_satd_i8x8 = COST_MAX;
            i_cost = (i_cost * cost_div_fix8[idx]) &gt;&gt; 8;
        }
        /* Not heavily tuned */
        static const uint8_t i8x8_thresh[11] = { 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6 };
        if( a-&gt;b_early_terminate &amp;&amp; X264_MIN(i_cost, a-&gt;i_satd_i16x16) &gt; (i_satd_inter*i8x8_thresh[h-&gt;mb.i_subpel_refine])&gt;&gt;2 )
            return;
    }

    /* 4x4 prediction selection */
    //帧内4x4
    if( flags &amp; X264_ANALYSE_I4x4 )
    {
        /*
		 * 16x16 宏块被划分为16个4x4子块
		 *
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 *
		 */
        int i_cost = lambda * (24+16); /* 24from JVT (SATD0), 16 from base predmode costs */
        int i_satd_thresh = a-&gt;b_early_terminate ? X264_MIN3( i_satd_inter, a-&gt;i_satd_i16x16, a-&gt;i_satd_i8x8 ) : COST_MAX;
        h-&gt;mb.i_cbp_luma = 0;

        if( a-&gt;b_early_terminate &amp;&amp; a-&gt;i_mbrd )
            i_satd_thresh = i_satd_thresh * (10-a-&gt;b_fast_intra)/8;

        if( h-&gt;sh.i_type == SLICE_TYPE_B )
            i_cost += lambda * i_mb_b_cost_table[I_4x4];
        //循环所有的4x4块
        for( idx = 0;; idx++ )
        {
        	//编码帧中的像素
        	//block_idx_xy_fenc[]记录了4x4小块在p_fenc中的偏移地址
            pixel *p_src_by = p_src + block_idx_xy_fenc[idx];
            //重建帧中的像素
            //block_idx_xy_fdec[]记录了4x4小块在p_fdec中的偏移地址
            pixel *p_dst_by = p_dst + block_idx_xy_fdec[idx];

            int i_best = COST_MAX;
            int i_pred_mode = x264_mb_predict_intra4x4_mode( h, idx );
        	//获得可用的帧内预测模式-针对帧内4x4
        	//左侧是否有可用数据？上方是否有可用数据？
            const int8_t *predict_mode = predict_4x4_mode_available( a-&gt;b_avoid_topright, h-&gt;mb.i_neighbour4[idx], idx );

            if( (h-&gt;mb.i_neighbour4[idx] &amp; (MB_TOPRIGHT|MB_TOP)) == MB_TOP )
                /* emulate missing topright samples */
                MPIXEL_X4( &amp;p_dst_by[4 - FDEC_STRIDE] ) = PIXEL_SPLAT_X4( p_dst_by[3 - FDEC_STRIDE] );

            if( h-&gt;pixf.intra_mbcmp_x9_4x4 &amp;&amp; predict_mode[8] &gt;= 0 )
            {
                /* No shortcuts here. The SSSE3 implementation of intra_mbcmp_x9 is fast enough. */
                i_best = h-&gt;pixf.intra_mbcmp_x9_4x4( p_src_by, p_dst_by, cost_i4x4_mode-i_pred_mode );
                i_cost += i_best &amp; 0xffff;
                i_best &gt;&gt;= 16;
                a-&gt;i_predict4x4[idx] = i_best;
                if( i_cost &gt; i_satd_thresh || idx == 15 )
                    break;
                h-&gt;mb.cache.intra4x4_pred_mode[x264_scan8[idx]] = i_best;
            }
            else
            {
                if( !h-&gt;mb.b_lossless &amp;&amp; predict_mode[5] &gt;= 0 )
                {
                    ALIGNED_ARRAY_16( int32_t, satd,[9] );

                    h-&gt;pixf.intra_mbcmp_x3_4x4( p_src_by, p_dst_by, satd );
                    int favor_vertical = satd[I_PRED_4x4_H] &gt; satd[I_PRED_4x4_V];
                    satd[i_pred_mode] -= 3 * lambda;
                    i_best = satd[I_PRED_4x4_DC]; a-&gt;i_predict4x4[idx] = I_PRED_4x4_DC;
                    COPY2_IF_LT( i_best, satd[I_PRED_4x4_H], a-&gt;i_predict4x4[idx], I_PRED_4x4_H );
                    COPY2_IF_LT( i_best, satd[I_PRED_4x4_V], a-&gt;i_predict4x4[idx], I_PRED_4x4_V );

                    /* Take analysis shortcuts: don't analyse modes that are too
                     * far away direction-wise from the favored mode. */
                    if( a-&gt;i_mbrd &lt; 1 + a-&gt;b_fast_intra )
                        predict_mode = intra_analysis_shortcut[a-&gt;b_avoid_topright][predict_mode[8] &gt;= 0][favor_vertical];
                    else
                        predict_mode += 3;
                }

                if( i_best &gt; 0 )
                {
                	//遍历所有Intra4x4帧内模式，最多9种
                    for( ; *predict_mode &gt;= 0; predict_mode++ )
                    {
                        int i_satd;
                        int i_mode = *predict_mode;
                        /*
						 * 4x4帧内预测举例
						 *
						 * Vertical预测方式
						 *   |X1 X2 X3 X4
						 * --+-----------
						 *   |X1 X2 X3 X4
						 *   |X1 X2 X3 X4
						 *   |X1 X2 X3 X4
						 *   |X1 X2 X3 X4
						 *
						 * Horizontal预测方式
						 *   |
						 * --+-----------
						 * X5|X5 X5 X5 X5
						 * X6|X6 X6 X6 X6
						 * X7|X7 X7 X7 X7
						 * X8|X8 X8 X8 X8
						 *
						 * DC预测方式
						 *   |X1 X2 X3 X4
						 * --+-----------
						 * X5|
						 * X6|     Y
						 * X7|
						 * X8|
						 *
						 * Y=(X1+X2+X3+X4+X5+X6+X7+X8)/8
						 *
						 */
                        if( h-&gt;mb.b_lossless )
                            x264_predict_lossless_4x4( h, p_dst_by, 0, idx, i_mode );
                        else
                            h-&gt;predict_4x4[i_mode]( p_dst_by );//帧内预测汇编函数-存储在重建帧中

                        //计算SAD或者是SATD（SATD（Transformed）是经过Hadamard变换之后的SAD）
                        //即编码代价
                        //p_src_by编码帧，p_dst_by重建帧
                        i_satd = h-&gt;pixf.mbcmp[PIXEL_4x4]( p_dst_by, FDEC_STRIDE, p_src_by, FENC_STRIDE );
                        if( i_pred_mode == x264_mb_pred_mode4x4_fix(i_mode) )
                        {
                            i_satd -= lambda * 3;
                            if( i_satd &lt;= 0 )
                            {
                                i_best = i_satd;
                                a-&gt;i_predict4x4[idx] = i_mode;
                                break;
                            }
                        }
                        //COPY2_IF_LT()函数的意思是“copy if little”。即如果值更小（代价更小），就拷贝。
						//宏定义展开后如下所示
                        //if((i_satd)&lt;(i_best))
                        //{
                        //    (i_best)=(i_satd);
                        //    (a-&gt;i_predict4x4[idx])=(i_mode);
                        //}

                        //看看代价是否更小
                        //i_best中存储了最小的代价值
                        //i_predict4x4[idx]中存储了代价最小的预测模式（idx为4x4小块的序号）
                        COPY2_IF_LT( i_best, i_satd, a-&gt;i_predict4x4[idx], i_mode );
                    }
                }
                //累加各个4x4块的代价（累加每个块的最小代价）
                i_cost += i_best + 3 * lambda;
                if( i_cost &gt; i_satd_thresh || idx == 15 )
                    break;
                if( h-&gt;mb.b_lossless )
                    x264_predict_lossless_4x4( h, p_dst_by, 0, idx, a-&gt;i_predict4x4[idx] );
                else
                    h-&gt;predict_4x4[a-&gt;i_predict4x4[idx]]( p_dst_by );

                /*
                 * 将mode填充至intra4x4_pred_mode_cache
                 *
				 * 用简单图形表示intra4x4_pred_mode_cache如下。数字代表填充顺序（一共填充16次）
				 *   |
				 * --+-------------------
				 *   | 0 0 0 0  0  0  0  0
				 *   | 0 0 0 0  1  2  5  6
				 *   | 0 0 0 0  3  4  7  8
				 *   | 0 0 0 0  9 10 13 14
				 *   | 0 0 0 0 11 12 15 16
				 *
				 */
                h-&gt;mb.cache.intra4x4_pred_mode[x264_scan8[idx]] = a-&gt;i_predict4x4[idx];
            }
            /* we need to encode this block now (for next ones) */
            x264_mb_encode_i4x4( h, 0, idx, a-&gt;i_qp, a-&gt;i_predict4x4[idx], 0 );
        }
        if( idx == 15 )//处理最后一个4x4小块（一共16个块）
        {
        	//开销（累加完的）
            a-&gt;i_satd_i4x4 = i_cost;
            if( h-&gt;mb.i_skip_intra )
            {
                h-&gt;mc.copy[PIXEL_16x16]( h-&gt;mb.pic.i4x4_fdec_buf, 16, p_dst, FDEC_STRIDE, 16 );
                h-&gt;mb.pic.i4x4_nnz_buf[0] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 0]] );
                h-&gt;mb.pic.i4x4_nnz_buf[1] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 2]] );
                h-&gt;mb.pic.i4x4_nnz_buf[2] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 8]] );
                h-&gt;mb.pic.i4x4_nnz_buf[3] = M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[10]] );
                h-&gt;mb.pic.i4x4_cbp = h-&gt;mb.i_cbp_luma;
                if( h-&gt;mb.i_skip_intra == 2 )
                    h-&gt;mc.memcpy_aligned( h-&gt;mb.pic.i4x4_dct_buf, h-&gt;dct.luma4x4, sizeof(h-&gt;mb.pic.i4x4_dct_buf) );
            }
        }
        else
            a-&gt;i_satd_i4x4 = COST_MAX;
    }
}
</pre><br />总体说来x264_mb_analyse_intra()通过计算Intra16x16，Intra8x8（暂时没有研究），Intra4x4这3中帧内预测模式的代价，比较后得到最佳的帧内预测模式。该函数的等流程大致如下：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）进行Intra16X16模式的预测<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用predict_16x16_mode_available()根据周围宏块的情况判断其可用的预测模式（主要检查左边和上边的块是否可用）。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)循环计算4种Intra16x16帧内预测模式：</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">i.调用predict_16x16[]()汇编函数进行Intra16x16帧内预测</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ii.调用x264_pixel_function_t中的mbcmp[]()计算编码代价（mbcmp[]()指向SAD或者SATD汇编函数）。</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)获取最小代价的Intra16x16模式。</blockquote>（2）进行Intra8x8模式的预测（未研究，流程应该类似）<br />（3）进行Intra4X4块模式的预测<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)循环处理16个4x4的块：</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">i.调用x264_mb_predict_intra4x4_mode()根据周围宏块情况判断该块可用的预测模式。</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ii.循环计算9种Intra4x4的帧内预测模式：</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">1)调用predict_4x4 []()汇编函数进行Intra4x4帧内预测</blockquote></blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">2)调用x264_pixel_function_t中的mbcmp[]()计算编码代价（mbcmp[]()指向SAD或者SATD汇编函数）。</blockquote></blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">iii.获取最小代价的Intra4x4模式。</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)将16个4X4块的最小代价相加，得到总代价。</blockquote><p>（4）将上述3中模式的代价进行对比，取最小者为当前宏块的帧内预测模式。</p></blockquote>后文将会对其中涉及到的几种汇编函数进行分析。在看源代码之前，简单记录一下相关的知识。<br /><br /><br /><h2>帧内预测知识</h2><p><span style="white-space:pre">	</span>简单记录一下帧内预测的方法。帧内预测根据宏块左边和上边的边界像素值推算宏块内部的像素值，帧内预测的效果如下图所示。其中左边的图为图像原始画面，右边的图为经过帧内预测后没有叠加残差的画面。</p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150522153436094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p><p><span style="white-space:pre">	</span>H.264中有两种帧内预测模式：16x16亮度帧内预测模式和4x4亮度帧内预测模式。其中16x16帧内预测模式一共有4种，如下图所示。</p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150522153540616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p><span style="white-space:pre">	</span>这4种模式列表如下。<br /><table border="1" cellspacing="0" cellpadding="0" witdh="500" align="center"> <tbody><tr>  <td valign="top"><p>模式</p></td>  <td valign="top"><p>描述</p></td> </tr> <tr>  <td valign="top"><p>Vertical</p></td>  <td valign="top"><p>由上边像素推出相应像素值</p></td> </tr> <tr>  <td valign="top"><p>Horizontal</p></td>  <td valign="top"><p>由左边像素推出相应像素值</p></td> </tr> <tr>  <td valign="top"><p>DC</p></td>  <td valign="top"><p>由上边和左边像素平均值推出相应像素值</p></td> </tr> <tr>  <td valign="top"><p>Plane</p></td>  <td valign="top"><p>由上边和左边像素推出相应像素值</p></td> </tr></tbody></table><br /><span style="white-space:pre">	</span>4x4帧内预测模式一共有9种，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150522153702828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><span style="white-space:pre">	</span>可以看出，Intra4x4帧内预测模式中前4种和Intra16x16是一样的。后面多增加了几种预测箭头不是45度角的方式——前面的箭头位于“口”中，而后面的箭头位于“日”中。<br /><br /><h2>像素比较知识</h2><span style="white-space:pre">	</span>帧内预测代价计算的过程中涉及到SAD和SATD像素计算，简单记录几个相关的概念。有关SAD、SATD、SSD的定义如下：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">SAD（Sum of Absolute Difference）也可以称为SAE（Sum of Absolute Error），即绝对误差和。它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。<br />SATD（Sum of Absolute Transformed Difference）即Hadamard变换后再绝对值求和。它和SAD的区别在于多了一个“变换”。<br />SSD（Sum of Squared Difference）也可以称为SSE（Sum of Squared Error），即差值的平方和。它和SAD的区别在于多了一个“平方”。</blockquote><span style="white-space:pre">	</span>H.264中使用SAD和SATD进行宏块预测模式的判断。早期的编码器使用SAD进行计算，近期的编码器多使用SATD进行计算。为什么使用SATD而不使用SAD呢？关键原因在于编码之后码流的大小是和图像块DCT变换后频域信息紧密相关的，而和变换前的时域信息关联性小一些。SAD只能反应时域信息；SATD却可以反映频域信息，而且计算复杂度也低于DCT变换，因此是比较合适的模式选择的依据。<br /><span style="white-space:pre">	</span>使用SAD进行模式选择的示例如下所示。下面这张图代表了一个普通的Intra16x16的宏块的像素。它的下方包含了使用Vertical，Horizontal，DC和Plane四种帧内预测模式预测的像素。通过计算可以得到这几种预测像素和原始像素之间的SAD（SAE）分别为3985，5097，4991，2539。由于Plane模式的SAD取值最小，由此可以断定Plane模式对于这个宏块来说是最好的帧内预测模式。<br /><div style="text-align: center;"><img src="http://img.blog.csdn.net/20150522153857441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></div><div style="text-align: center;"><img src="http://img.blog.csdn.net/20150522153839763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></div><br /><p>下面按照Intra16x16预测，Intra4x4预测，像素计算的顺序记录依次记录各个模块的汇编函数源代码。</p><p><br /></p><p><br /></p><h2>Intra16x16帧内预测源代码</h2><p>Intra16x16帧内预测模块的初始化函数是x264_predict_16x16_init()。该函数对x264_predict_t结构体中的函数指针进行了赋值。X264运行的过程中只要调用x264_predict_t的函数指针就可以完成相应的功能。</p><p><br /></p><h3>x264_predict_16x16_init()</h3>x264_predict_16x16_init()用于初始化Intra16x16帧内预测汇编函数。该函数的定义位于x264\common\predict.c，如下所示。<br /><pre name="code" class="cpp">//Intra16x16帧内预测汇编函数初始化
void x264_predict_16x16_init( int cpu, x264_predict_t pf[7] )
{
	//C语言版本
	//================================================
	//垂直 Vertical
    pf[I_PRED_16x16_V ]     = x264_predict_16x16_v_c;
    //水平 Horizontal
    pf[I_PRED_16x16_H ]     = x264_predict_16x16_h_c;
    //DC
    pf[I_PRED_16x16_DC]     = x264_predict_16x16_dc_c;
    //Plane
    pf[I_PRED_16x16_P ]     = x264_predict_16x16_p_c;
    //这几种是啥？
    pf[I_PRED_16x16_DC_LEFT]= x264_predict_16x16_dc_left_c;
    pf[I_PRED_16x16_DC_TOP ]= x264_predict_16x16_dc_top_c;
    pf[I_PRED_16x16_DC_128 ]= x264_predict_16x16_dc_128_c;
    //================================================
    //MMX版本
#if HAVE_MMX
    x264_predict_16x16_init_mmx( cpu, pf );
#endif
    //ALTIVEC版本
#if HAVE_ALTIVEC
    if( cpu&amp;X264_CPU_ALTIVEC )
        x264_predict_16x16_init_altivec( pf );
#endif
    //ARMV6版本
#if HAVE_ARMV6
    x264_predict_16x16_init_arm( cpu, pf );
#endif
    //AARCH64版本
#if ARCH_AARCH64
    x264_predict_16x16_init_aarch64( cpu, pf );
#endif
}
</pre><br />从源代码可看出，x264_predict_16x16_init()首先对帧内预测函数指针数组x264_predict_t[]中的元素赋值了C语言版本的函数x264_predict_16x16_v_c()，x264_predict_16x16_h_c()，x264_predict_16x16_dc_c()，x264_predict_16x16_p_c()；然后会判断系统平台的特性，如果平台支持的话，会调用x264_predict_16x16_init_mmx()，x264_predict_16x16_init_arm()等给x264_predict_t[]中的元素赋值经过汇编优化的函数。下文首先看一下Intra16x16中的4种帧内预测模式的C语言版本，作为对比再看一下Intra16x16中Vertical模式的X86汇编版本和NEON汇编版本。<br /><br /><h3>x264_predict_16x16_v_c()</h3>x264_predict_16x16_v_c()是Intra16x16帧内预测Vertical模式的C语言版本函数。该函数的定义位于common\predict.c，如下所示。<br /><pre name="code" class="cpp">//16x16帧内预测
//垂直预测（Vertical）
void x264_predict_16x16_v_c( pixel *src )
{
	/*
	 * Vertical预测方式
	 *   |X1 X2 X3 X4
	 * --+-----------
	 *   |X1 X2 X3 X4
	 *   |X1 X2 X3 X4
	 *   |X1 X2 X3 X4
	 *   |X1 X2 X3 X4
	 *
	 */
	/*
	 * 【展开宏定义】
	 * uint32_t v0 = ((x264_union32_t*)(&amp;src[ 0-FDEC_STRIDE]))-&gt;i;
	 * uint32_t v1 = ((x264_union32_t*)(&amp;src[ 4-FDEC_STRIDE]))-&gt;i;
	 * uint32_t v2 = ((x264_union32_t*)(&amp;src[ 8-FDEC_STRIDE]))-&gt;i;
	 * uint32_t v3 = ((x264_union32_t*)(&amp;src[12-FDEC_STRIDE]))-&gt;i;
	 * 在这里，上述代码实际上相当于：
	 * uint32_t v0 = *((uint32_t*)(&amp;src[ 0-FDEC_STRIDE]));
	 * uint32_t v1 = *((uint32_t*)(&amp;src[ 4-FDEC_STRIDE]));
	 * uint32_t v2 = *((uint32_t*)(&amp;src[ 8-FDEC_STRIDE]));
	 * uint32_t v3 = *((uint32_t*)(&amp;src[12-FDEC_STRIDE]));
	 * 即分成4次，每次取出4个像素（一共16个像素），分别赋值给v0，v1，v2，v3
	 * 取出的值源自于16x16块上面的一行像素
	 *    0|          4          8          12         16
	 *    ||    v0    |    v1    |    v2    |    v3    |
	 * ---++==========+==========+==========+==========+
	 *    ||
	 *    ||
	 *    ||
	 *    ||
	 *    ||
	 *    ||
	 *
	 */
	//pixel4实际上是uint32_t（占用32bit），存储4个像素的值（每个像素占用8bit）

    pixel4 v0 = MPIXEL_X4( &amp;src[ 0-FDEC_STRIDE] );
    pixel4 v1 = MPIXEL_X4( &amp;src[ 4-FDEC_STRIDE] );
    pixel4 v2 = MPIXEL_X4( &amp;src[ 8-FDEC_STRIDE] );
    pixel4 v3 = MPIXEL_X4( &amp;src[12-FDEC_STRIDE] );

    //循环赋值16行
    for( int i = 0; i &lt; 16; i++ )
    {
    	//【展开宏定义】
    	//(((x264_union32_t*)(src+ 0))-&gt;i) = v0;
    	//(((x264_union32_t*)(src+ 4))-&gt;i) = v1;
    	//(((x264_union32_t*)(src+ 8))-&gt;i) = v2;
    	//(((x264_union32_t*)(src+12))-&gt;i) = v3;
    	//即分成4次，每次赋值4个像素
    	//
        MPIXEL_X4( src+ 0 ) = v0;
        MPIXEL_X4( src+ 4 ) = v1;
        MPIXEL_X4( src+ 8 ) = v2;
        MPIXEL_X4( src+12 ) = v3;
        //下一行
        //FDEC_STRIDE=32,是重建宏块缓存fdec_buf一行的数据量
        src += FDEC_STRIDE;
    }
}
</pre><br /><p>从源代码可以看出，x264_predict_16x16_v_c()首先取出16x16块上面一行像素值，依次存储在v0、v1、v2、v3，然后循环16次赋值给块中的16行像素。</p><p><br /></p><h3>x264_predict_16x16_h_c()</h3>x264_predict_16x16_h_c()是Intra16x16帧内预测Horizontal模式的C语言版本函数。该函数的定义位于common\predict.c，如下所示。<br /><pre name="code" class="cpp">//16x16帧内预测
//水平预测（Horizontal）
void x264_predict_16x16_h_c( pixel *src )
{
    /*
     * Horizontal预测方式
     *   |
     * --+-----------
     * X5|X5 X5 X5 X5
     * X6|X6 X6 X6 X6
     * X7|X7 X7 X7 X7
     * X8|X8 X8 X8 X8
     *
     */
	/*
     * const pixel4 v = PIXEL_SPLAT_X4( src[-1] );
     * 宏定义展开后
     * const uint32_t v = (src[-1])*0x01010101U;
     *
     * PIXEL_SPLAT_X4()的作用应该是把最后一个像素（最后8位）拷贝给前面3个像素（前24位）
     * 即把0x0100009F变成0x9F9F9F9F
     * 推导：
     * 前提是x占8bit（对应1个像素）
     * y=x*0x01010101
     *  =x*(0x00000001+0x00000100+0x00010000+0x01000000)
     *  =x&lt;&lt;0+x&lt;&lt;8+x&lt;&lt;16+x&lt;&lt;24
     *
     * const uint32_t v = (src[-1])*0x01010101U含义：
     * 每行把src[-1]中像素值例如0x02赋值给v.v取值为0x02020202
     * src[-1]即16x16块左侧的值
	 */
	//循环赋值16行
    for( int i = 0; i &lt; 16; i++ )
    {
        const pixel4 v = PIXEL_SPLAT_X4( src[-1] );
        //宏定义展开后：
        //((x264_union32_t*)(src+ 0))-&gt;i=v;
        //((x264_union32_t*)(src+ 4))-&gt;i=v;
        //((x264_union32_t*)(src+ 8))-&gt;i=v;
        //((x264_union32_t*)(src+12))-&gt;i=v;
        //即分4次，每次赋值4个像素（一行一共16个像素，取值是一样的）
        //
        //   0|          4          8         12         16
    	//   ||          |          |          |          |
    	//---++==========+==========+==========+==========+
    	//   ||
        // v ||    v     |    v     |    v     |    v     |
    	//   ||
    	//   ||
    	//   ||
        //
        MPIXEL_X4( src+ 0 ) = v;
        MPIXEL_X4( src+ 4 ) = v;
        MPIXEL_X4( src+ 8 ) = v;
        MPIXEL_X4( src+12 ) = v;
        //下一行
        //FDEC_STRIDE=32,是重建宏块缓存fdec_buf一行的数据量
        src += FDEC_STRIDE;
    }
}
</pre><br />从源代码可以看出，x264_predict_16x16_h_c()首先取出16x16块每行左边的1个像素，复制4份后存储在v中，然后分成4次将v赋值给这一行像素。其中“PIXEL_SPLAT_X4()”的功能是取出变量低8位的数值复制4份到高24位，相关的推导功能已经记录在源代码中，不再重复叙述。<br /><br /><h3>x264_predict_16x16_dc_c()</h3>x264_predict_16x16_dc_c()是Intra16x16帧内预测DC模式的C语言版本函数。该函数的定义位于common\predict.c，如下所示。<br /><pre name="code" class="cpp">#define PREDICT_16x16_DC(v)\
    for( int i = 0; i &lt; 16; i++ )\
    {\
        MPIXEL_X4( src+ 0 ) = v;\
        MPIXEL_X4( src+ 4 ) = v;\
        MPIXEL_X4( src+ 8 ) = v;\
        MPIXEL_X4( src+12 ) = v;\
        src += FDEC_STRIDE;\
    }

void x264_predict_16x16_dc_c( pixel *src )
{
	/*
	 * DC预测方式
	 *   |X1 X2 X3 X4
	 * --+-----------
	 * X5|
	 * X6|     Y
	 * X7|
	 * X8|
	 *
	 * Y=(X1+X2+X3+X4+X5+X6+X7+X8)/8
	 */

    int dc = 0;
    //把16x16块中所有像素的值加起来，存储在dc中
    for( int i = 0; i &lt; 16; i++ )
    {
    	//左侧的值
        dc += src[-1 + i * FDEC_STRIDE];
        //上方的值
        dc += src[i - FDEC_STRIDE];
    }
    //加起来的值除以32（一共16+16个点）
    //“+16”是为了四舍五入？
    //PIXEL_SPLAT_X4()的作用应该是把最后一个像素（最后8位）拷贝给前面3个像素（前24位）
    //即把0x0100009F变成0x9F9F9F9F
    pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 16 ) &gt;&gt; 5 );
    //赋值到16x16块中的每个像素
    /*
     * 宏展开之后结果
     * for( int i = 0; i &lt; 16; i++ )
     * {
     * 	(((x264_union32_t*)(src+ 0))-&gt;i) = dcsplat;
     * 	(((x264_union32_t*)(src+ 4))-&gt;i) = dcsplat;
     * 	(((x264_union32_t*)(src+ 8))-&gt;i) = dcsplat;
     * 	(((x264_union32_t*)(src+12))-&gt;i) = dcsplat;
     * 	src += 32;
     * }
     */
    PREDICT_16x16_DC( dcsplat );
}
</pre><br />从源代码可以看出，x264_predict_16x16_dc_c()求出16x16块上面一行像素和左边一列像素的平均值，然后赋值给16x16块中的每一个像素。<br /><br /><h3>X86以及ARM平台汇编函数</h3><p>除了C语言版本的帧内预测函数之外，还包含了很多汇编语言版本的函数。下面以Intra16x16帧内预测Vertical模式为例，看一下该函数的X86平台汇编版本以及ARM平台汇编版本。</p><p><br /></p><h3>x264_predict_16x16_init_mmx()</h3>x264_predict_16x16_init_mmx()用于初始化经过x86汇编优化过的Intra16x16的帧内预测函数。该函数的定义位于common\x86\predict-c.c（在“x86”子文件夹下），如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_7_1984467" name="code" class="cpp">//Intra16x16帧内预测汇编函数-MMX版本
void x264_predict_16x16_init_mmx( int cpu, x264_predict_t pf[7] )
{
    if( !(cpu&amp;X264_CPU_MMX2) )
        return;
    pf[I_PRED_16x16_DC]      = x264_predict_16x16_dc_mmx2;
    pf[I_PRED_16x16_DC_TOP]  = x264_predict_16x16_dc_top_mmx2;
    pf[I_PRED_16x16_DC_LEFT] = x264_predict_16x16_dc_left_mmx2;
    pf[I_PRED_16x16_V]       = x264_predict_16x16_v_mmx2;
    pf[I_PRED_16x16_H]       = x264_predict_16x16_h_mmx2;
#if HIGH_BIT_DEPTH
    if( !(cpu&amp;X264_CPU_SSE) )
        return;
    pf[I_PRED_16x16_V]       = x264_predict_16x16_v_sse;
    if( !(cpu&amp;X264_CPU_SSE2) )
        return;
    pf[I_PRED_16x16_DC]      = x264_predict_16x16_dc_sse2;
    pf[I_PRED_16x16_DC_TOP]  = x264_predict_16x16_dc_top_sse2;
    pf[I_PRED_16x16_DC_LEFT] = x264_predict_16x16_dc_left_sse2;
    pf[I_PRED_16x16_H]       = x264_predict_16x16_h_sse2;
    pf[I_PRED_16x16_P]       = x264_predict_16x16_p_sse2;
    if( !(cpu&amp;X264_CPU_AVX) )
        return;
    pf[I_PRED_16x16_V]       = x264_predict_16x16_v_avx;
    if( !(cpu&amp;X264_CPU_AVX2) )
        return;
    pf[I_PRED_16x16_H]       = x264_predict_16x16_h_avx2;
#else
#if !ARCH_X86_64
    pf[I_PRED_16x16_P]       = x264_predict_16x16_p_mmx2;
#endif
    if( !(cpu&amp;X264_CPU_SSE) )
        return;
    pf[I_PRED_16x16_V]       = x264_predict_16x16_v_sse;
    if( !(cpu&amp;X264_CPU_SSE2) )
        return;
    pf[I_PRED_16x16_DC]      = x264_predict_16x16_dc_sse2;
    if( cpu&amp;X264_CPU_SSE2_IS_SLOW )
        return;
    pf[I_PRED_16x16_DC_TOP]  = x264_predict_16x16_dc_top_sse2;
    pf[I_PRED_16x16_DC_LEFT] = x264_predict_16x16_dc_left_sse2;
    pf[I_PRED_16x16_P]       = x264_predict_16x16_p_sse2;
    if( !(cpu&amp;X264_CPU_SSSE3) )
        return;
    if( !(cpu&amp;X264_CPU_SLOW_PSHUFB) )
        pf[I_PRED_16x16_H]       = x264_predict_16x16_h_ssse3;
#if HAVE_X86_INLINE_ASM
    pf[I_PRED_16x16_P]       = x264_predict_16x16_p_ssse3;
#endif
    if( !(cpu&amp;X264_CPU_AVX) )
        return;
    pf[I_PRED_16x16_P]       = x264_predict_16x16_p_avx;
#endif // HIGH_BIT_DEPTH

    if( cpu&amp;X264_CPU_AVX2 )
    {
        pf[I_PRED_16x16_P]       = x264_predict_16x16_p_avx2;
        pf[I_PRED_16x16_DC]      = x264_predict_16x16_dc_avx2;
        pf[I_PRED_16x16_DC_TOP]  = x264_predict_16x16_dc_top_avx2;
        pf[I_PRED_16x16_DC_LEFT] = x264_predict_16x16_dc_left_avx2;
    }
}
</pre><br />可以看出，针对Intra16x16的Vertical帧内预测模式，x264_predict_16x16_init_mmx()会根据系统的特型初始化2个函数：如果系统仅支持MMX指令集，就会初始化x264_predict_16x16_v_mmx2()；如果系统还支持SSE指令集，就会初始化x264_predict_16x16_v_sse()。下面看一下这2个函数的代码。<br /><br /><h3>x264_predict_16x16_v_mmx2()<br />x264_predict_16x16_v_sse()</h3>在x264中，x264_predict_16x16_v_mmx2()和x264_predict_16x16_v_sse()这两个函数的定义是写到一起的。它们的定义位于common\x86\predict-a.asm，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_8_4528" name="code" class="cpp">;-----------------------------------------------------------------------------
; void predict_16x16_v( pixel *src )
; Intra16x16帧内预测Vertical模式
;-----------------------------------------------------------------------------
;SIZEOF_PIXEL取值为1
;FDEC_STRIDEB为重建宏块缓存fdec_buf一行像素的大小，取值为32
;
;平台相关的信息位于x86inc.asm
;INIT_MMX中
;  mmsize为8
;  mova为movq
;INIT_XMM中：
;  mmsize为16
;  mova为movdqa
;
;STORE16的定义在前面，用于循环16行存储数据

%macro PREDICT_16x16_V 0
cglobal predict_16x16_v, 1,2
%assign %%i 0
%rep 16*SIZEOF_PIXEL/mmsize                         ;rep循环执行，拷贝16x16块上方的1行像素数据至m0,m1...
                                                    ;mmssize为指令1次处理比特数
    mova m %+ %%i, [r0-FDEC_STRIDEB+%%i*mmsize]     ;移入m0,m1...
%assign %%i %%i+1
%endrep
%if 16*SIZEOF_PIXEL/mmsize == 4                     ;1行需要处理4次
    STORE16 m0, m1, m2, m3                          ;循环存储16行，每次存储4个寄存器
%elif 16*SIZEOF_PIXEL/mmsize == 2                   ;1行需要处理2次
    STORE16 m0, m1                                  ;循环存储16行，每次存储2个寄存器
%else                                               ;1行需要处理1次
    STORE16 m0                                      ;循环存储16行，每次存储1个寄存器
%endif
    RET
%endmacro

INIT_MMX mmx2
PREDICT_16x16_V
INIT_XMM sse
PREDICT_16x16_V
</pre><br />从汇编代码可以看出，x264_predict_16x16_v_mmx2()和x264_predict_16x16_v_sse()的逻辑是一模一样的。它们之间的不同主要在于一条指令处理的数据量：MMX指令的MOVA对应的是MOVQ，一次处理8Byte（8个像素）；SSE指令的MOVA对应的是MOVDQA，一次处理16Byte（16个像素，正好是16x16块中的一行像素）。<br />作为对比，我们可以看一下ARM平台下汇编优化过的Intra16x16的帧内预测函数。这些汇编函数的初始化函数是x264_predict_16x16_init_arm()。<br /><br /><h3>x264_predict_16x16_init_arm()</h3>x264_predict_16x16_init_arm()用于初始化ARM平台下汇编优化过的Intra16x16的帧内预测函数。该函数的定义位于common\arm\predict-c.c（“arm”文件夹下），如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_9_957172" name="code" class="cpp">void x264_predict_16x16_init_arm( int cpu, x264_predict_t pf[7] )
{
    if (!(cpu&amp;X264_CPU_NEON))
        return;

#if !HIGH_BIT_DEPTH
    pf[I_PRED_16x16_DC ]    = x264_predict_16x16_dc_neon;
    pf[I_PRED_16x16_DC_TOP] = x264_predict_16x16_dc_top_neon;
    pf[I_PRED_16x16_DC_LEFT]= x264_predict_16x16_dc_left_neon;
    pf[I_PRED_16x16_H ]     = x264_predict_16x16_h_neon;
    pf[I_PRED_16x16_V ]     = x264_predict_16x16_v_neon;
    pf[I_PRED_16x16_P ]     = x264_predict_16x16_p_neon;
#endif // !HIGH_BIT_DEPTH
}
</pre><br />从源代码可以看出，针对Vertical预测模式，x264_predict_16x16_init_arm()初始化了经过NEON指令集优化的函数x264_predict_16x16_v_neon()。<br /><br /><h3>x264_predict_16x16_v_neon()</h3>x264_predict_16x16_v_neon()的定义位于common\arm\predict-a.S，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_10_863041" name="code" class="cpp">/*
 * Intra16x16帧内预测Vertical模式-NEON
 *
 */
 /* FDEC_STRIDE=32Bytes，为重建宏块一行像素的大小 */
 /* R0存储16x16像素块地址 */
function x264_predict_16x16_v_neon
    sub         r0, r0, #FDEC_STRIDE     /* r0=r0-FDEC_STRIDE */
    mov         ip, #FDEC_STRIDE         /* ip=32 */
                                         /* VLD向量加载: 内存-&gt;NEON寄存器 */
                                         /* d0,d1为64bit双字寄存器，共16Byte，在这里存储16x16块上方一行像素 */
    vld1.64     {d0-d1}, [r0,:128], ip   /* 将R0指向的数据从内存加载到d0和d1寄存器（64bit） */
                                         /* r0=r0+ip */
.rept 16                                 /* 循环16次，一次处理1行 */
                                         /* VST向量存储: NEON寄存器-&gt;内存 */
    vst1.64     {d0-d1}, [r0,:128], ip   /* 将d0和d1寄存器中的数据传递给R0指向的内存 */
                                         /* r0=r0+ip */
.endr
    bx          lr                       /* 子程序返回 */
endfunc
</pre><br />可以看出，x264_predict_16x16_v_neon()使用vld1.64指令载入16x16块上方的一行像素，然后在一个16次的循环中，使用vst1.64指令将该行像素值赋值给16x16块的每一行。<br />至此有关Intra16x16的Vertical帧内预测方式的源代码就分析完了。<br /><br /><br /><h2>Intra4x4帧内预测源代码</h2>Intra4x4帧内预测模块的初始化函数是x264_predict_4x4_init()。该函数对x264_predict_t结构体中的函数指针进行了赋值。X264运行的过程中只要调用x264_predict_t的函数指针就可以完成相应的功能。<br /><br /><h3>x264_predict_4x4_init()</h3>x264_predict_4x4_init()用于初始化Intra4x4帧内预测汇编函数。该函数的定义位于common\predict.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_11_1292297" name="code" class="cpp">//Intra4x4帧内预测汇编函数初始化
void x264_predict_4x4_init( int cpu, x264_predict_t pf[12] )
{
	//9种Intra4x4预测方式
    pf[I_PRED_4x4_V]      = x264_predict_4x4_v_c;
    pf[I_PRED_4x4_H]      = x264_predict_4x4_h_c;
    pf[I_PRED_4x4_DC]     = x264_predict_4x4_dc_c;
    pf[I_PRED_4x4_DDL]    = x264_predict_4x4_ddl_c;
    pf[I_PRED_4x4_DDR]    = x264_predict_4x4_ddr_c;
    pf[I_PRED_4x4_VR]     = x264_predict_4x4_vr_c;
    pf[I_PRED_4x4_HD]     = x264_predict_4x4_hd_c;
    pf[I_PRED_4x4_VL]     = x264_predict_4x4_vl_c;
    pf[I_PRED_4x4_HU]     = x264_predict_4x4_hu_c;
    //这些是？
    pf[I_PRED_4x4_DC_LEFT]= x264_predict_4x4_dc_left_c;
    pf[I_PRED_4x4_DC_TOP] = x264_predict_4x4_dc_top_c;
    pf[I_PRED_4x4_DC_128] = x264_predict_4x4_dc_128_c;

#if HAVE_MMX
    x264_predict_4x4_init_mmx( cpu, pf );
#endif

#if HAVE_ARMV6
    x264_predict_4x4_init_arm( cpu, pf );
#endif

#if ARCH_AARCH64
    x264_predict_4x4_init_aarch64( cpu, pf );
#endif
}
</pre><br />从源代码可看出，x264_predict_4x4_init()首先对帧内预测函数指针数组x264_predict_t[]中的元素赋值了C语言版本的函数x264_predict_4x4_v_c()，x264_predict_4x4_h_c()，x264_predict_4x4_dc_c()，x264_predict_4x4_p_c()等一系列函数（Intra4x4有9种，后面那几种是怎么回事？）；然后会判断系统平台的特性，如果平台支持的话，会调用x264_predict_4x4_init_mmx()，x264_predict_4x4_init_arm()等给x264_predict_t[]中的元素赋值经过汇编优化的函数。下面看一下Intra4x4帧内预测中Vertical、Horizontal、DC模式的C语言版本函数。<br /><br /><h3>x264_predict_4x4_v_c()</h3>x264_predict_4x4_v_c()实现了Intra4x4帧内预测Vertical模式。该函数的定义位于common\predict.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_12_9868765" name="code" class="cpp">void x264_predict_4x4_v_c( pixel *src )
{
    /*
     * Vertical预测方式
     *   |X1 X2 X3 X4
     * --+-----------
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *
     */

	/*
	 * 宏展开后的结果如下所示
	 * 注：重建宏块缓存fdec_buf一行的数据量为32Byte
	 *
	 * (((x264_union32_t*)(&amp;src[(0)+(0)*32]))-&gt;i) =
	 * (((x264_union32_t*)(&amp;src[(0)+(1)*32]))-&gt;i) =
	 * (((x264_union32_t*)(&amp;src[(0)+(2)*32]))-&gt;i) =
	 * (((x264_union32_t*)(&amp;src[(0)+(3)*32]))-&gt;i) = (((x264_union32_t*)(&amp;src[(0)+(-1)*32]))-&gt;i);
	 */
    PREDICT_4x4_DC(SRC_X4(0,-1));
}
</pre><br />x264_predict_4x4_v_c()函数的函数体极其简单，只有一个宏定义“PREDICT_4x4_DC(SRC_X4(0,-1));”。如果把该宏展开后，可以看出它取了4x4块上面一行4个像素的值，然后分别赋值给4x4块的4行像素。<br /><br /><h3>x264_predict_4x4_h_c()</h3>x264_predict_4x4_h_c()实现了Intra4x4帧内预测Horizontal模式。该函数的定义位于common\predict.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_13_6809030" name="code" class="cpp">void x264_predict_4x4_h_c( pixel *src )
{
    /*
     * Horizontal预测方式
     *   |
     * --+-----------
     * X5|X5 X5 X5 X5
     * X6|X6 X6 X6 X6
     * X7|X7 X7 X7 X7
     * X8|X8 X8 X8 X8
     *
     */

	/*
	 * 宏展开后的结果如下所示
	 * 注：重建宏块缓存fdec_buf一行的数据量为32Byte
	 *
	 * 该代码就是把每行左边的值赋值给该行像素，一次赋值一行
	 *
	 * (((x264_union32_t*)(&amp;src[(0)+(0)*32]))-&gt;i)=((src[(-1)+(0)*32])*0x01010101U);
	 * (((x264_union32_t*)(&amp;src[(0)+(1)*32]))-&gt;i)=((src[(-1)+(1)*32])*0x01010101U);
	 * (((x264_union32_t*)(&amp;src[(0)+(2)*32]))-&gt;i)=((src[(-1)+(2)*32])*0x01010101U);
	 * (((x264_union32_t*)(&amp;src[(0)+(3)*32]))-&gt;i)=((src[(-1)+(3)*32])*0x01010101U);
	 *
	 * PIXEL_SPLAT_X4()的作用应该是把最后一个像素（最后8位）拷贝给前面3个像素（前24位）
     * 即把0x0100009F变成0x9F9F9F9F
     * 推导：
     * 前提是x占8bit（对应1个像素）
     * y=x*0x01010101
     *  =x*(0x00000001+0x00000100+0x00010000+0x01000000)
     *  =x&lt;&lt;0+x&lt;&lt;8+x&lt;&lt;16+x&lt;&lt;24
     *
     * const uint32_t v = (src[-1])*0x01010101U含义：
     * 每行把src[-1]中像素值例如0x02赋值给v.v取值为0x02020202
     * src[-1]即16x16块左侧的值
     *
	 */

    SRC_X4(0,0) = PIXEL_SPLAT_X4( SRC(-1,0) );
    SRC_X4(0,1) = PIXEL_SPLAT_X4( SRC(-1,1) );
    SRC_X4(0,2) = PIXEL_SPLAT_X4( SRC(-1,2) );
    SRC_X4(0,3) = PIXEL_SPLAT_X4( SRC(-1,3) );
}
</pre><br />从源代码可以看出，x264_predict_4x4_h_c()首先取出4x4块每行左边的1个像素，复制4份后赋值给这一行像素。其中“PIXEL_SPLAT_X4()”的功能是取出变量低8位的数值复制4份到高24位。<br /><br /><h3>x264_predict_4x4_dc_c()</h3>x264_predict_4x4_dc_c()实现了Intra4x4帧内预测DC模式。该函数的定义位于common\predict.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_14_269930" name="code" class="cpp">void x264_predict_4x4_dc_c( pixel *src )
{
    /*
     * DC预测方式
     *   |X1 X2 X3 X4
     * --+-----------
     * X5|
     * X6|     Y
     * X7|
     * X8|
     *
     * Y=(X1+X2+X3+X4+X5+X6+X7+X8)/8
     */

	/*
	 * 宏展开后的结果如下所示
	 * 注：重建宏块缓存fdec_buf一行的数据量为32Byte
	 * 注2：“+4”是为了四舍五入
	 *
	 * uint32_t dc=(((src[(-1)+(0)*32] + src[(-1)+(1)*32] + src[(-1)+(2)*32] + src[(-1)+(3)*32] +
     *     src[(0)+(-1)*32] + src[(1)+(-1)*32] + src[(2)+(-1)*32] + src[(3)+(-1)*32] + 4) &gt;&gt; 3)*0x01010101U)
	 *
	 * 一次赋值一行
     * (((x264_union32_t*)(&amp;src[(0)+(0)*32]))-&gt;i) =
     * (((x264_union32_t*)(&amp;src[(0)+(1)*32]))-&gt;i) =
     * (((x264_union32_t*)(&amp;src[(0)+(2)*32]))-&gt;i) =
     * (((x264_union32_t*)(&amp;src[(0)+(3)*32]))-&gt;i) = dc;
     *
	 */
    pixel4 dc = PIXEL_SPLAT_X4( (SRC(-1,0) + SRC(-1,1) + SRC(-1,2) + SRC(-1,3) +
                                 SRC(0,-1) + SRC(1,-1) + SRC(2,-1) + SRC(3,-1) + 4) &gt;&gt; 3 );
    PREDICT_4x4_DC( dc );
}
</pre><br />从源代码可以看出，x264_predict_4x4_dc_c()取出了4x4块左边和上边的8个像素，将它们的平均值赋值给4x4块中的每个像素。<br /><br /><br /><h2>像素计算源代码</h2><p>像素计算模块的初始化函数是x264_pixel_init()。该函数对x264_pixel_function_t结构体中的函数指针进行了赋值。X264运行的过程中只要调用x264_pixel_function_t的函数指针就可以完成相应的功能。</p><p><br /></p><h3>x264_pixel_init()</h3>x264_pixel_init()初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。该函数的定义位于common\pixel.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_15_732206" name="code" class="cpp">/****************************************************************************
 * x264_pixel_init:
 ****************************************************************************/
//SAD等和像素计算有关的函数
void x264_pixel_init( int cpu, x264_pixel_function_t *pixf )
{
    memset( pixf, 0, sizeof(*pixf) );

    //初始化2个函数-16x16,16x8
#define INIT2_NAME( name1, name2, cpu ) \
    pixf-&gt;name1[PIXEL_16x16] = x264_pixel_##name2##_16x16##cpu;\
    pixf-&gt;name1[PIXEL_16x8]  = x264_pixel_##name2##_16x8##cpu;
    //初始化4个函数-(16x16,16x8),8x16,8x8
#define INIT4_NAME( name1, name2, cpu ) \
    INIT2_NAME( name1, name2, cpu ) \
    pixf-&gt;name1[PIXEL_8x16]  = x264_pixel_##name2##_8x16##cpu;\
    pixf-&gt;name1[PIXEL_8x8]   = x264_pixel_##name2##_8x8##cpu;
    //初始化5个函数-(16x16,16x8,8x16,8x8),8x4
#define INIT5_NAME( name1, name2, cpu ) \
    INIT4_NAME( name1, name2, cpu ) \
    pixf-&gt;name1[PIXEL_8x4]   = x264_pixel_##name2##_8x4##cpu;
    //初始化6个函数-(16x16,16x8,8x16,8x8,8x4),4x8
#define INIT6_NAME( name1, name2, cpu ) \
    INIT5_NAME( name1, name2, cpu ) \
    pixf-&gt;name1[PIXEL_4x8]   = x264_pixel_##name2##_4x8##cpu;
    //初始化7个函数-(16x16,16x8,8x16,8x8,8x4,4x8),4x4
#define INIT7_NAME( name1, name2, cpu ) \
    INIT6_NAME( name1, name2, cpu ) \
    pixf-&gt;name1[PIXEL_4x4]   = x264_pixel_##name2##_4x4##cpu;
#define INIT8_NAME( name1, name2, cpu ) \
    INIT7_NAME( name1, name2, cpu ) \
    pixf-&gt;name1[PIXEL_4x16]  = x264_pixel_##name2##_4x16##cpu;

    //重新起个名字
#define INIT2( name, cpu ) INIT2_NAME( name, name, cpu )
#define INIT4( name, cpu ) INIT4_NAME( name, name, cpu )
#define INIT5( name, cpu ) INIT5_NAME( name, name, cpu )
#define INIT6( name, cpu ) INIT6_NAME( name, name, cpu )
#define INIT7( name, cpu ) INIT7_NAME( name, name, cpu )
#define INIT8( name, cpu ) INIT8_NAME( name, name, cpu )

#define INIT_ADS( cpu ) \
    pixf-&gt;ads[PIXEL_16x16] = x264_pixel_ads4##cpu;\
    pixf-&gt;ads[PIXEL_16x8] = x264_pixel_ads2##cpu;\
    pixf-&gt;ads[PIXEL_8x8] = x264_pixel_ads1##cpu;
    //8个sad函数
    INIT8( sad, );
    INIT8_NAME( sad_aligned, sad, );
    //7个sad函数-一次性计算3次
    INIT7( sad_x3, );
    //7个sad函数-一次性计算4次
    INIT7( sad_x4, );
    //8个ssd函数
    //ssd可以用来计算PSNR
    INIT8( ssd, );
    //8个satd函数
    //satd计算的是经过Hadamard变换后的值
    INIT8( satd, );
    //8个satd函数-一次性计算3次
    INIT7( satd_x3, );
    //8个satd函数-一次性计算4次
    INIT7( satd_x4, );
    INIT4( hadamard_ac, );
    INIT_ADS( );

    pixf-&gt;sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16;
    pixf-&gt;sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8;
    pixf-&gt;var[PIXEL_16x16] = x264_pixel_var_16x16;
    pixf-&gt;var[PIXEL_8x16]  = x264_pixel_var_8x16;
    pixf-&gt;var[PIXEL_8x8]   = x264_pixel_var_8x8;
    pixf-&gt;var2[PIXEL_8x16]  = x264_pixel_var2_8x16;
    pixf-&gt;var2[PIXEL_8x8]   = x264_pixel_var2_8x8;
    //计算UV的
    pixf-&gt;ssd_nv12_core = pixel_ssd_nv12_core;
    //计算SSIM
    pixf-&gt;ssim_4x4x2_core = ssim_4x4x2_core;
    pixf-&gt;ssim_end4 = ssim_end4;
    pixf-&gt;vsad = pixel_vsad;
    pixf-&gt;asd8 = pixel_asd8;

    pixf-&gt;intra_sad_x3_4x4    = x264_intra_sad_x3_4x4;
    pixf-&gt;intra_satd_x3_4x4   = x264_intra_satd_x3_4x4;
    pixf-&gt;intra_sad_x3_8x8    = x264_intra_sad_x3_8x8;
    pixf-&gt;intra_sa8d_x3_8x8   = x264_intra_sa8d_x3_8x8;
    pixf-&gt;intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c;
    pixf-&gt;intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c;
    pixf-&gt;intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c;
    pixf-&gt;intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c;
    pixf-&gt;intra_sad_x3_16x16  = x264_intra_sad_x3_16x16;
    pixf-&gt;intra_satd_x3_16x16 = x264_intra_satd_x3_16x16;

    //后面的初始化基本上都是汇编优化过的函数

#if HIGH_BIT_DEPTH
#if HAVE_MMX
    if( cpu&amp;X264_CPU_MMX2 )
    {
        INIT7( sad, _mmx2 );
        INIT7_NAME( sad_aligned, sad, _mmx2 );
        INIT7( sad_x3, _mmx2 );
        INIT7( sad_x4, _mmx2 );
        INIT8( satd, _mmx2 );
        INIT7( satd_x3, _mmx2 );
        INIT7( satd_x4, _mmx2 );
        INIT4( hadamard_ac, _mmx2 );
        INIT8( ssd, _mmx2 );
        INIT_ADS( _mmx2 );

        pixf-&gt;ssd_nv12_core = x264_pixel_ssd_nv12_core_mmx2;
        pixf-&gt;var[PIXEL_16x16] = x264_pixel_var_16x16_mmx2;
        pixf-&gt;var[PIXEL_8x8]   = x264_pixel_var_8x8_mmx2;
#if ARCH_X86
        pixf-&gt;var2[PIXEL_8x8]  = x264_pixel_var2_8x8_mmx2;
        pixf-&gt;var2[PIXEL_8x16] = x264_pixel_var2_8x16_mmx2;
#endif

        pixf-&gt;intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_mmx2;
        pixf-&gt;intra_satd_x3_4x4   = x264_intra_satd_x3_4x4_mmx2;
        pixf-&gt;intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_mmx2;
        pixf-&gt;intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_mmx2;
        pixf-&gt;intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_mmx2;
        pixf-&gt;intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_mmx2;
        pixf-&gt;intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_mmx2;
        pixf-&gt;intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_mmx2;
        pixf-&gt;intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_mmx2;
    }
    if( cpu&amp;X264_CPU_SSE2 )
    {
        INIT4_NAME( sad_aligned, sad, _sse2_aligned );
        INIT5( ssd, _sse2 );
        INIT6( satd, _sse2 );
        pixf-&gt;satd[PIXEL_4x16] = x264_pixel_satd_4x16_sse2;

        pixf-&gt;sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16_sse2;
        pixf-&gt;sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8_sse2;
#if ARCH_X86_64
        pixf-&gt;intra_sa8d_x3_8x8 = x264_intra_sa8d_x3_8x8_sse2;
        pixf-&gt;sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_sse2;
#endif
        pixf-&gt;intra_sad_x3_4x4  = x264_intra_sad_x3_4x4_sse2;
        pixf-&gt;ssd_nv12_core = x264_pixel_ssd_nv12_core_sse2;
        pixf-&gt;ssim_4x4x2_core  = x264_pixel_ssim_4x4x2_core_sse2;
        pixf-&gt;ssim_end4        = x264_pixel_ssim_end4_sse2;
        pixf-&gt;var[PIXEL_16x16] = x264_pixel_var_16x16_sse2;
        pixf-&gt;var[PIXEL_8x8]   = x264_pixel_var_8x8_sse2;
        pixf-&gt;var2[PIXEL_8x8]  = x264_pixel_var2_8x8_sse2;
        pixf-&gt;var2[PIXEL_8x16] = x264_pixel_var2_8x16_sse2;
        pixf-&gt;intra_sad_x3_8x8 = x264_intra_sad_x3_8x8_sse2;
}
//此处省略大量的X86、ARM等平台的汇编函数初始化代码
}
</pre><br />x264_pixel_init()的源代码非常的长，主要原因在于它把C语言版本的函数以及各种平台的汇编函数都写到一块了（不知道现在最新的版本是不是还是这样）。x264_pixel_init()包含了大量和像素计算有关的函数，包括SAD、SATD、SSD、SSIM等等。它的输入参数x264_pixel_function_t是一个结构体，其中包含了各种像素计算的函数接口。x264_pixel_function_t的定义如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_16_48648" name="code" class="cpp">typedef struct
{
    x264_pixel_cmp_t  sad[8];
    x264_pixel_cmp_t  ssd[8];
    x264_pixel_cmp_t satd[8];
    x264_pixel_cmp_t ssim[7];
    x264_pixel_cmp_t sa8d[4];
    x264_pixel_cmp_t mbcmp[8]; /* either satd or sad for subpel refine and mode decision */
    x264_pixel_cmp_t mbcmp_unaligned[8]; /* unaligned mbcmp for subpel */
    x264_pixel_cmp_t fpelcmp[8]; /* either satd or sad for fullpel motion search */
    x264_pixel_cmp_x3_t fpelcmp_x3[7];
    x264_pixel_cmp_x4_t fpelcmp_x4[7];
    x264_pixel_cmp_t sad_aligned[8]; /* Aligned SAD for mbcmp */
    int (*vsad)( pixel *, intptr_t, int );
    int (*asd8)( pixel *pix1, intptr_t stride1, pixel *pix2, intptr_t stride2, int height );
    uint64_t (*sa8d_satd[1])( pixel *pix1, intptr_t stride1, pixel *pix2, intptr_t stride2 );

    uint64_t (*var[4])( pixel *pix, intptr_t stride );
    int (*var2[4])( pixel *pix1, intptr_t stride1,
                    pixel *pix2, intptr_t stride2, int *ssd );
    uint64_t (*hadamard_ac[4])( pixel *pix, intptr_t stride );

    void (*ssd_nv12_core)( pixel *pixuv1, intptr_t stride1,
                           pixel *pixuv2, intptr_t stride2, int width, int height,
                           uint64_t *ssd_u, uint64_t *ssd_v );
    void (*ssim_4x4x2_core)( const pixel *pix1, intptr_t stride1,
                             const pixel *pix2, intptr_t stride2, int sums[2][4] );
    float (*ssim_end4)( int sum0[5][4], int sum1[5][4], int width );

    /* multiple parallel calls to cmp. */
    x264_pixel_cmp_x3_t sad_x3[7];
    x264_pixel_cmp_x4_t sad_x4[7];
    x264_pixel_cmp_x3_t satd_x3[7];
    x264_pixel_cmp_x4_t satd_x4[7];

    /* abs-diff-sum for successive elimination.
     * may round width up to a multiple of 16. */
    int (*ads[7])( int enc_dc[4], uint16_t *sums, int delta,
                   uint16_t *cost_mvx, int16_t *mvs, int width, int thresh );

    /* calculate satd or sad of V, H, and DC modes. */
    void (*intra_mbcmp_x3_16x16)( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_satd_x3_16x16) ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_sad_x3_16x16)  ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_mbcmp_x3_4x4)  ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_satd_x3_4x4)   ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_sad_x3_4x4)    ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_mbcmp_x3_chroma)( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_satd_x3_chroma) ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_sad_x3_chroma)  ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_mbcmp_x3_8x16c) ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_satd_x3_8x16c)  ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_sad_x3_8x16c)   ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_mbcmp_x3_8x8c)  ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_satd_x3_8x8c)   ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_sad_x3_8x8c)    ( pixel *fenc, pixel *fdec, int res[3] );
    void (*intra_mbcmp_x3_8x8)  ( pixel *fenc, pixel edge[36], int res[3] );
    void (*intra_sa8d_x3_8x8)   ( pixel *fenc, pixel edge[36], int res[3] );
    void (*intra_sad_x3_8x8)    ( pixel *fenc, pixel edge[36], int res[3] );
    /* find minimum satd or sad of all modes, and set fdec.
     * may be NULL, in which case just use pred+satd instead. */
    int (*intra_mbcmp_x9_4x4)( pixel *fenc, pixel *fdec, uint16_t *bitcosts );
    int (*intra_satd_x9_4x4) ( pixel *fenc, pixel *fdec, uint16_t *bitcosts );
    int (*intra_sad_x9_4x4)  ( pixel *fenc, pixel *fdec, uint16_t *bitcosts );
    int (*intra_mbcmp_x9_8x8)( pixel *fenc, pixel *fdec, pixel edge[36], uint16_t *bitcosts, uint16_t *satds );
    int (*intra_sa8d_x9_8x8) ( pixel *fenc, pixel *fdec, pixel edge[36], uint16_t *bitcosts, uint16_t *satds );
    int (*intra_sad_x9_8x8)  ( pixel *fenc, pixel *fdec, pixel edge[36], uint16_t *bitcosts, uint16_t *satds );
} x264_pixel_function_t;
</pre><br />在x264_pixel_init()中定义了好几个宏，用于给x264_pixel_function_t结构体中的函数接口赋值。例如“INIT8( sad, )”用于给x264_pixel_function_t中的sad[8]赋值。该宏展开后的代码如下。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_17_5461394" name="code" class="cpp">pixf-&gt;sad[PIXEL_16x16] = x264_pixel_sad_16x16;
pixf-&gt;sad[PIXEL_16x8]  = x264_pixel_sad_16x8;
pixf-&gt;sad[PIXEL_8x16]  = x264_pixel_sad_8x16;
pixf-&gt;sad[PIXEL_8x8]   = x264_pixel_sad_8x8;
pixf-&gt;sad[PIXEL_8x4]   = x264_pixel_sad_8x4;
pixf-&gt;sad[PIXEL_4x8]   = x264_pixel_sad_4x8;
pixf-&gt;sad[PIXEL_4x4]   = x264_pixel_sad_4x4;
pixf-&gt;sad[PIXEL_4x16]  = x264_pixel_sad_4x16;</pre>“INIT8( ssd, )” 用于给x264_pixel_function_t中的ssd[8]赋值。该宏展开后的代码如下。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_18_1496588" name="code" class="cpp">pixf-&gt;ssd[PIXEL_16x16] = x264_pixel_ssd_16x16;
pixf-&gt;ssd[PIXEL_16x8]  = x264_pixel_ssd_16x8; 
pixf-&gt;ssd[PIXEL_8x16]  = x264_pixel_ssd_8x16;
pixf-&gt;ssd[PIXEL_8x8]   = x264_pixel_ssd_8x8; 
pixf-&gt;ssd[PIXEL_8x4]   = x264_pixel_ssd_8x4; 
pixf-&gt;ssd[PIXEL_4x8]   = x264_pixel_ssd_4x8; 
pixf-&gt;ssd[PIXEL_4x4]   = x264_pixel_ssd_4x4; 
pixf-&gt;ssd[PIXEL_4x16]  = x264_pixel_ssd_4x16;</pre>“INIT8( satd, )” 用于给x264_pixel_function_t中的satd[8]赋值。该宏展开后的代码如下。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_19_6385946" name="code" class="cpp">pixf-&gt;satd[PIXEL_16x16] = x264_pixel_satd_16x16;
pixf-&gt;satd[PIXEL_16x8]  = x264_pixel_satd_16x8; 
pixf-&gt;satd[PIXEL_8x16]  = x264_pixel_satd_8x16;
pixf-&gt;satd[PIXEL_8x8]   = x264_pixel_satd_8x8; 
pixf-&gt;satd[PIXEL_8x4]   = x264_pixel_satd_8x4; 
pixf-&gt;satd[PIXEL_4x8]   = x264_pixel_satd_4x8; 
pixf-&gt;satd[PIXEL_4x4]   = x264_pixel_satd_4x4; 
pixf-&gt;satd[PIXEL_4x16]  = x264_pixel_satd_4x16;</pre>下文打算分别记录SAD、SSD和SATD计算的函数x264_pixel_sad_4x4()，x264_pixel_ssd_4x4()，和x264_pixel_satd_4x4()。此外再记录一个一次性“批量”计算4个点的函数x264_pixel_sad_x4_4x4()。<br /><br /><h3>x264_pixel_sad_4x4()</h3>x264_pixel_sad_4x4()用于计算4x4块的SAD。该函数的定义位于common\pixel.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_20_926641" name="code" class="cpp">   static int x264_pixel_sad_4x4( pixel *pix1, intptr_t i_stride_pix1,
                 pixel *pix2, intptr_t i_stride_pix2 )
	{
		int i_sum = 0;
		for( int y = 0; y &lt; 4; y++ ) //4个像素
		{
			for( int x = 0; x &lt; 4; x++ ) //4个像素
			{
				i_sum += abs( pix1[x] - pix2[x] );//相减之后求绝对值，然后累加
			}
			pix1 += i_stride_pix1;
			pix2 += i_stride_pix2;
		}
		return i_sum;
	}</pre>可以看出x264_pixel_sad_4x4()将两个4x4图像块对应点相减之后，调用abs()求出绝对值，然后累加到i_sum变量上。<br /><br /><h3>x264_pixel_sad_x4_4x4()</h3>x264_pixel_sad_4x4()用于计算4个4x4块的SAD。该函数的定义位于common\pixel.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_21_3307745" name="code" class="cpp">	static void x264_pixel_sad_x4_4x4( pixel *fenc, pixel *pix0, pixel *pix1,pixel *pix2, pixel *pix3,
										  intptr_t i_stride, int scores[4] )
	{
		scores[0] = x264_pixel_sad_4x4( fenc, 16, pix0, i_stride );
		scores[1] = x264_pixel_sad_4x4( fenc, 16, pix1, i_stride );
		scores[2] = x264_pixel_sad_4x4( fenc, 16, pix2, i_stride );
		scores[3] = x264_pixel_sad_4x4( fenc, 16, pix3, i_stride );
	}</pre>可以看出，x264_pixel_sad_4x4()计算了起始点在pix0，pix1，pix2，pix3四个4x4的图像块和fenc之间的SAD，并将结果存储于scores[4]数组中。<br /><br /><h3>x264_pixel_ssd_4x4()</h3><p>x264_pixel_ssd_4x4()用于计算4x4块的SSD。该函数的定义位于common\pixel.c，如下所示。</p><p></p><pre code_snippet_id="672964" snippet_file_name="blog_20150522_22_148952" name="code" class="cpp">	static int x264_pixel_ssd_4x4( pixel *pix1, intptr_t i_stride_pix1,
					 pixel *pix2, intptr_t i_stride_pix2 )
	{
		int i_sum = 0;
		for( int y = 0; y &lt; 4; y++ ) //4个像素
		{
			for( int x = 0; x &lt; 4; x++ ) //4个像素
			{
				int d = pix1[x] - pix2[x]; //相减
				i_sum += d*d;              //平方之后，累加
			}
			pix1 += i_stride_pix1;
			pix2 += i_stride_pix2;
		}
		return i_sum;
	}</pre><p></p>可以看出x264_pixel_ssd_4x4()将两个4x4图像块对应点相减之后，取了平方值，然后累加到i_sum变量上。<br /><br /><h3>x264_pixel_satd_4x4()</h3>x264_pixel_satd_4x4()用于计算4x4块的SATD。该函数的定义位于common\pixel.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_23_1691023" name="code" class="cpp">//SAD（Sum of Absolute Difference）=SAE（Sum of Absolute Error)即绝对误差和
//SATD（Sum of Absolute Transformed Difference）即hadamard变换后再绝对值求和
//
//为什么帧内模式选择要用SATD？
//SAD即绝对误差和，仅反映残差时域差异，影响PSNR值，不能有效反映码流的大小。
//SATD即将残差经哈德曼变换的4x4块的预测残差绝对值总和，可以将其看作简单的时频变换，其值在一定程度上可以反映生成码流的大小。
//4x4的SATD
static NOINLINE int x264_pixel_satd_4x4( pixel *pix1, intptr_t i_pix1, pixel *pix2, intptr_t i_pix2 )
{
    sum2_t tmp[4][2];
    sum2_t a0, a1, a2, a3, b0, b1;
    sum2_t sum = 0;

    for( int i = 0; i &lt; 4; i++, pix1 += i_pix1, pix2 += i_pix2 )
    {
        a0 = pix1[0] - pix2[0];
        a1 = pix1[1] - pix2[1];
        b0 = (a0+a1) + ((a0-a1)&lt;&lt;BITS_PER_SUM);
        a2 = pix1[2] - pix2[2];
        a3 = pix1[3] - pix2[3];
        b1 = (a2+a3) + ((a2-a3)&lt;&lt;BITS_PER_SUM);
        tmp[i][0] = b0 + b1;
        tmp[i][1] = b0 - b1;
    }
    for( int i = 0; i &lt; 2; i++ )
    {
        HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );
        a0 = abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);
        sum += ((sum_t)a0) + (a0&gt;&gt;BITS_PER_SUM);
    }
    return sum &gt;&gt; 1;
}
</pre><br />可以看出x264_pixel_satd_4x4()调用了一个宏HADAMARD4()用于Hadamard变换的计算，并最终将两个像素块Hadamard变换后对应元素求差的绝对值之后，累加到sum变量上。<br /><br /><h3>mbcmp_init()</h3>Intra宏块帧内预测模式的分析函数x264_mb_analyse_intra()中并没有直接调用x264_pixel_function_t 中sad[]/satd[]的函数，而是调用了x264_pixel_function_t的mbcmp[]中的函数。mbcmp[]中实际上就是存储的sad[]/satd[]中的函数。mbcmp_init()函数通过参数决定了mbcmp[]使用sad[]还是satd[]。该函数的定义位于encoder\encoder.c，如下所示。<br /><pre code_snippet_id="672964" snippet_file_name="blog_20150522_24_4944179" name="code" class="cpp">//决定了像素比较的时候用SAD还是SATD
static void mbcmp_init( x264_t *h )
{
	//b_lossless一般为0
    //主要看i_subpel_refine，大于1的话就使用SATD
    int satd = !h-&gt;mb.b_lossless &amp;&amp; h-&gt;param.analyse.i_subpel_refine &gt; 1;

    //sad或者satd赋值给mbcmp
    memcpy( h-&gt;pixf.mbcmp, satd ? h-&gt;pixf.satd : h-&gt;pixf.sad_aligned, sizeof(h-&gt;pixf.mbcmp) );
    memcpy( h-&gt;pixf.mbcmp_unaligned, satd ? h-&gt;pixf.satd : h-&gt;pixf.sad, sizeof(h-&gt;pixf.mbcmp_unaligned) );
    h-&gt;pixf.intra_mbcmp_x3_16x16 = satd ? h-&gt;pixf.intra_satd_x3_16x16 : h-&gt;pixf.intra_sad_x3_16x16;
    h-&gt;pixf.intra_mbcmp_x3_8x16c = satd ? h-&gt;pixf.intra_satd_x3_8x16c : h-&gt;pixf.intra_sad_x3_8x16c;
    h-&gt;pixf.intra_mbcmp_x3_8x8c  = satd ? h-&gt;pixf.intra_satd_x3_8x8c  : h-&gt;pixf.intra_sad_x3_8x8c;
    h-&gt;pixf.intra_mbcmp_x3_8x8 = satd ? h-&gt;pixf.intra_sa8d_x3_8x8 : h-&gt;pixf.intra_sad_x3_8x8;
    h-&gt;pixf.intra_mbcmp_x3_4x4 = satd ? h-&gt;pixf.intra_satd_x3_4x4 : h-&gt;pixf.intra_sad_x3_4x4;
    h-&gt;pixf.intra_mbcmp_x9_4x4 = h-&gt;param.b_cpu_independent || h-&gt;mb.b_lossless ? NULL
                               : satd ? h-&gt;pixf.intra_satd_x9_4x4 : h-&gt;pixf.intra_sad_x9_4x4;
    h-&gt;pixf.intra_mbcmp_x9_8x8 = h-&gt;param.b_cpu_independent || h-&gt;mb.b_lossless ? NULL
                               : satd ? h-&gt;pixf.intra_sa8d_x9_8x8 : h-&gt;pixf.intra_sad_x9_8x8;
    satd &amp;= h-&gt;param.analyse.i_me_method == X264_ME_TESA;
    memcpy( h-&gt;pixf.fpelcmp, satd ? h-&gt;pixf.satd : h-&gt;pixf.sad, sizeof(h-&gt;pixf.fpelcmp) );
    memcpy( h-&gt;pixf.fpelcmp_x3, satd ? h-&gt;pixf.satd_x3 : h-&gt;pixf.sad_x3, sizeof(h-&gt;pixf.fpelcmp_x3) );
    memcpy( h-&gt;pixf.fpelcmp_x4, satd ? h-&gt;pixf.satd_x4 : h-&gt;pixf.sad_x4, sizeof(h-&gt;pixf.fpelcmp_x4) );
}
</pre><br />从mbcmp_init()的源代码可以看出，当i_subpel_refine取值大于1的时候，satd变量为1，此时后续代码中赋值给mbcmp[]相关的一系列函数指针的函数就是SATD函数；当i_subpel_refine取值小于等于1的时候，satd变量为0，此时后续代码中赋值给mbcmp[]相关的一系列函数指针的函数就是SAD函数。<br /><br /><br />至此有关x264中的Intra宏块分析模块的源代码就分析完毕了。<br /><br /><br /><p><br /></p><br /><strong><span style="color:#990000;">雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</span></strong><br /><br /><br /><br /><br /><br /><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/45917757		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=x264&t=blog" target="_blank">x264						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=帧内编码&t=blog" target="_blank">帧内编码						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=Intra&t=blog" target="_blank">Intra						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=SAD&t=blog" target="_blank">SAD						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=H.264&t=blog" target="_blank">H.264						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/2619503"  target="_blank">x264						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/osmedia.html" target="_blank">开源多媒体项目源代码分析</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45917757#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45938927" target="_blank" strategy="BlogCommendFromBaidu_0">
				<em>x264</em><em>源代码</em><em>简单</em><em>分析</em>：<em>宏块</em>编码（Encode）<em>部分</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45938927" target="_blank" >
				本文记录<em>x264</em>的 <em>x264</em>_slice_write()函数中调用的<em>x264</em>_macroblock_encode()的<em>源代码</em>。<em>x264</em>_macroblock_encode()对应着<em>x264</em>中的<em>宏块</em>编码...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-05-24 13:47:40</span>
			</p>
			<p>
				<span class="read-num">阅读数：8151</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/shaqoneal/article/details/53959053" target="_blank" strategy="BlogCommendFromBaidu_1">
				【H.264/AVC视频编解码技术详解】十二、解析H.264码流的<em>宏块</em>结构（下）：H.264帧内编码<em>宏块</em>的预测结构			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/shaqoneal/article/details/53959053" target="_blank" >
				《H.264/AVC视频编解码技术详解》视频教程已经在“CSDN学院”上线，视频中详述了H.264的背景、标准协议和实现，并通过一个实战工程的形式对H.264的标准进行解析和实现，欢迎观看！“纸上得来...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/shaqoneal" title="shaqoneal" target="_blank">
					<img src="https://avatar.csdn.net/C/5/8/3_shaqoneal.jpg" alt="shaqoneal" class="avatar-pic">
					<span class="name">shaqoneal</span>
				</a>
			</p>
			<p>
				<span class="date">2016-12-31 23:28:49</span>
			</p>
			<p>
				<span class="read-num">阅读数：1673</span>
			</p>
		</div>
	</div>
								<div class="recommend-item-box recommend-ad-box" id="ad1"></div>
				<script>
				  var width = $("div.recommend-box").outerWidth() - 48;
					NEWS_FEED({
						w: width,
						h : 90,
						showid : 'GNKXx7',
						placeholderId: "ad1",
						inject : 'define',
						define : {
							imagePosition : 'right',
							imageBorderRadius : 0,
							imageWidth: 120,
							imageHeight: 90,
							imageFill : 'clip',
							displayImage : true,
							displayTitle : true,
							titleFontSize: 20,
							titleFontColor: '#333',
							titleFontFamily : 'Microsoft Yahei',
							titleFontWeight: 'bold',
							titlePaddingTop : 0,
							titlePaddingRight : 0,
							titlePaddingBottom : 10,
							titlePaddingLeft : 0,
							displayDesc : true,
							descFontSize: 14,
							descFontColor: '#6b6b6b',
							descFontFamily : 'Microsoft Yahei',
							paddingTop : 0,
							paddingRight : 0,
							paddingBottom : 0,
							paddingLeft : 0,
							backgroundColor: '#fff',
							hoverColor: '#ca0c16'
						}
					})
				</script>

			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/wanggp_2007/article/details/4842839" target="_blank" strategy="BlogCommendFromBaidu_2">
				H264基本概念之 <em>宏块</em>、片和片组			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/wanggp_2007/article/details/4842839" target="_blank" >
				这几个概念对比音频信号处理可是全新的，下面简要介绍一下定义和作用： 1、<em>宏块</em>（Macro Block）：一个编码图像首先要划分成多个块（4x4 像素）才能进行处理，显然<em>宏块</em>应该是整数个块组成，通常<em>宏块</em>...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/wanggp_2007" title="wanggp_2007" target="_blank">
					<img src="https://avatar.csdn.net/F/1/5/3_wanggp_2007.jpg" alt="wanggp_2007" class="avatar-pic">
					<span class="name">wanggp_2007</span>
				</a>
			</p>
			<p>
				<span class="date">2009-11-20 16:41:00</span>
			</p>
			<p>
				<span class="read-num">阅读数：13282</span>
			</p>
		</div>
	</div>
						<div class="recommend-item-box recommend-download-box csdn-tracking-statistics clearfix" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
			<div class="content float-left">
				<h4 class="text-truncate">
					<a href="https://download.csdn.net/download/vblittleboy/4478298" target="_blank" strategy="BlogCommendFromBaidu_3">
						自适应<em>宏块</em>编码算法的研究					</a>
				</h4>
				<p>
					<span class="data">2012年08月05日 </span>
					<span class="size">398KB</span>
					<span class="type">下载</span>
				</p>
			</div>
			<div class="img-box float-right">
				<a href="https://download.csdn.net/download/vblittleboy/4478298" target="_blank" strategy="BlogCommendFromBaidu_3">
					<img src="http://csdnimg.cn/release/download/old_static/images/minetype/pdf.svg" alt="">
				</a>
			</div>
		</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/jubincn/article/details/7057246" target="_blank" strategy="BlogCommendFromBaidu_4">
				[视频] <em>x264</em> 压缩笔记			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/jubincn/article/details/7057246" target="_blank" >
				转载本站文章请注明，转载自：扶凯[http://www.php-oa.com]
本文链接: http://www.php-oa.com/2009/03/22/<em>x264</em>.html
象<em>x264</em>本身是不...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/jubincn" title="jubincn" target="_blank">
					<img src="https://avatar.csdn.net/7/E/E/3_jubincn.jpg" alt="jubincn" class="avatar-pic">
					<span class="name">jubincn</span>
				</a>
			</p>
			<p>
				<span class="date">2011-12-09 15:24:32</span>
			</p>
			<p>
				<span class="read-num">阅读数：4973</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/zanjunrong/article/details/78560377" target="_blank" strategy="BlogCommendFromBaidu_5">
				H264基本原理			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/zanjunrong/article/details/78560377" target="_blank" >
				H264基本原理


前言
H264视频压缩算法现在无疑是所有视频压缩技术中使用最广泛，最流行的。随着 <em>x264</em>/openh264以及ffmpeg等开源库的推出，大多数使用者无需再对H264的...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/zanjunrong" title="zanjunrong" target="_blank">
					<img src="https://avatar.csdn.net/6/C/A/3_zanjunrong.jpg" alt="zanjunrong" class="avatar-pic">
					<span class="name">zanjunrong</span>
				</a>
			</p>
			<p>
				<span class="date">2017-11-17 13:49:13</span>
			</p>
			<p>
				<span class="read-num">阅读数：133</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/shaqoneal/article/details/53471976" target="_blank" strategy="BlogCommendFromBaidu_6">
				【H.264/AVC视频编解码技术详解】十二、解析H.264码流的<em>宏块</em>结构（上）			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/shaqoneal/article/details/53471976" target="_blank" >
				《H.264/AVC视频编解码技术详解》视频教程已经在“CSDN学院”上线，视频中详述了H.264的背景、标准协议和实现，并通过一个实战工程的形式对H.264的标准进行解析和实现，欢迎观看！“纸上得来...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/shaqoneal" title="shaqoneal" target="_blank">
					<img src="https://avatar.csdn.net/C/5/8/3_shaqoneal.jpg" alt="shaqoneal" class="avatar-pic">
					<span class="name">shaqoneal</span>
				</a>
			</p>
			<p>
				<span class="date">2016-12-06 00:08:20</span>
			</p>
			<p>
				<span class="read-num">阅读数：1764</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45936267" target="_blank" strategy="BlogCommendFromBaidu_7">
				<em>x264</em><em>源代码</em><em>简单</em><em>分析</em>：<em>宏块</em><em>分析</em>（<em>Analysis</em>）<em>部分</em>-帧间<em>宏块</em>（Inter）			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45936267" target="_blank" >
				本文记录<em>x264</em>的 <em>x264</em>_slice_write()函数中调用的<em>x264</em>_macroblock_analyse()的<em>源代码</em>。<em>x264</em>_macroblock_analyse()对应着<em>x264</em>中的<em>分析</em>...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-05-23 19:07:49</span>
			</p>
			<p>
				<span class="read-num">阅读数：7265</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45143075" target="_blank" strategy="BlogCommendFromBaidu_8">
				FFmpeg的H.264解码器<em>源代码</em><em>简单</em><em>分析</em>：<em>宏块</em>解码（Decode）<em>部分</em>-帧内<em>宏块</em>（<em>Intra</em>）			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45143075" target="_blank" >
				本文<em>分析</em>FFmpeg的H.264解码器的<em>宏块</em>解码（Decode）<em>部分</em>的<em>源代码</em>。FFmpeg的H.264解码器调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-04-20 14:55:51</span>
			</p>
			<p>
				<span class="read-num">阅读数：14565</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/fangbaolei2088/article/details/7528764" target="_blank" strategy="BlogCommendFromQuerySearch_9">
				H.264帧内编码的模式选择			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/fangbaolei2088/article/details/7528764" target="_blank" >
				H.264帧内编码的模式选择

H.264中4X4亮度预测依据预测方向的不同共有9种预测模式。在亮度4x4帧内预测时，其中DC预测(模式2)、垂直预测(模式0)和水平预测(模式2总是被认为有效的，...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/fangbaolei2088" title="fangbaolei2088" target="_blank">
					<img src="https://avatar.csdn.net/E/B/3/3_fangbaolei2088.jpg" alt="fangbaolei2088" class="avatar-pic">
					<span class="name">fangbaolei2088</span>
				</a>
			</p>
			<p>
				<span class="date">2012-05-02 17:17:39</span>
			</p>
			<p>
				<span class="read-num">阅读数：253</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45917757" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421168">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>3</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）";
    var ChannelId = 16;
    var articleId = "45917757";
    var commentscount = 4;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/45917757";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B+0x01010101+%2A+%28%28dc1+%2B+dc2+%2B+4%29+%3E%3E+3%29";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B+0x01010101+%2A+%28%28dc1+%2B+dc2+%2B+4%29+%3E%3E+3%29"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>