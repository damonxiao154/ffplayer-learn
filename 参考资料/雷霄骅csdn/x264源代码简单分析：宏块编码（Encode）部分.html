<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/45938927"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文记录x264的 x264_slice_write()函数中调用的x264_macroblock_encode()的源代码。x264_macroblock_encode()对应着x264中的宏块编码模块。宏块编码模块主要完成了DCT变换和量化两个步骤。函数调用关系图宏块编码（Encode）部分的源代码在整个x264中的位置如下图所示。单击查看更清晰的图片宏块编码（Encode）部分的函数调用关系" />
    <meta name="keywords" content="x264,DCT" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>x264源代码简单分析：宏块编码（Encode）部分 - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45938927"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">x264源代码简单分析：宏块编码（Encode）部分</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年05月24日 13:47:40</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：8151</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p></p><p>=====================================================</p><p>H.264源代码分析文章列表：</p><p>【编码 - x264】</p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45536607">x264源代码简单分析：概述</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45583217">x264源代码简单分析：x264命令行工具（x264.exe）</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45644367">x264源代码简单分析：编码器主干部分-1</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45719905">x264源代码简单分析：编码器主干部分-2</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45790195">x264源代码简单分析：x264_slice_write()</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45870269">x264源代码简单分析：滤波（Filter）部分</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45917757">x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45936267">x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45938927">x264源代码简单分析：宏块编码（Encode）部分</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45944811">x264源代码简单分析：熵编码（Entropy Encoding）部分</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45960409">FFmpeg与libx264接口源代码简单分析</a></p><p>【解码 - libavcodec H.264 解码器】</p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">FFmpeg的H.264解码器源代码简单分析：概述</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45001033">FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45042755">FFmpeg的H.264解码器源代码简单分析：解码器主干部分</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45114453">FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45143075">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45195291">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）</a></p><p><a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/45224579">FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分</a></p><p>=====================================================</p><br /><p>本文记录x264的 x264_slice_write()函数中调用的x264_macroblock_encode()的源代码。x264_macroblock_encode()对应着x264中的宏块编码模块。宏块编码模块主要完成了DCT变换和量化两个步骤。</p><br /><br /><h2>函数调用关系图</h2><p>宏块编码（Encode）部分的源代码在整个x264中的位置如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201505/06/1430897637_6272.jpg"><img src="http://img.blog.csdn.net/20150523233134640" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1807927">单击查看更清晰的图片</a></div><br /><p>宏块编码（Encode）部分的函数调用关系如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201505/23/1432395492_7495.jpg"><img src="http://img.blog.csdn.net/20150523233435017" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1808795">单击查看更清晰的图片</a></div><br />从图中可以看出，宏块编码模块的x264_macroblock_encode()调用了x264_macroblock_encode_internal()，而x264_macroblock_encode_internal()完成了如下功能：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">x264_macroblock_encode_skip()：编码Skip类型宏块。<br />x264_mb_encode_i16x16()：编码Intra16x16类型的宏块。该函数除了进行DCT变换之外，还对16个小块的DC系数进行了Hadamard变换。<br />x264_mb_encode_i4x4()：编码Intra4x4类型的宏块。<br />帧间宏块编码：这一部分代码直接写在了函数体里面。<br />x264_mb_encode_chroma()：编码色度块。</blockquote>本文将会分析上述函数中除了色度编码外的几个函数。<br /><br /><br /><h2>x264_slice_write()</h2>x264_slice_write()是x264项目的核心，它完成了编码了一个Slice的工作。有关该函数的分析可以参考文章《x264源代码简单分析：x264_slice_write()》。本文分析其调用的x264_macroblock_encode()函数。<br /><br /><br /><h2>x264_macroblock_encode()</h2>x264_macroblock_encode()用于编码宏块。该函数的定义位于encoder\macroblock.c，如下所示。<br /><pre name="code" class="cpp">//编码-残差DCT变换、量化
void x264_macroblock_encode( x264_t *h )
{
	//编码-内部函数
	//YUV444相当于把YUV3个分量都当做Y编码
    if( CHROMA444 )
        x264_macroblock_encode_internal( h, 3, 0 );
    else
        x264_macroblock_encode_internal( h, 1, 1 );
}
</pre><br />从源代码可以看出，x264_macroblock_encode()封装了x264_macroblock_encode_internal()。如果色度模式是YUV444的话，传递的参数plane_count=3而chroma=0；如果不是YUV444的话，传递的参数plane_count=1而chroma=1。<br /><br /><br /><h2>x264_macroblock_encode_internal()</h2>x264_macroblock_encode_internal()是x264_macroblock_encode()的内部函数。该函数的定义位于encoder\macroblock.c，如下所示。<br /><pre name="code" class="cpp">/*****************************************************************************
 * x264_macroblock_encode:
 * 编码-残差DCT变换、量化-内部函数
 *
 * 注释和处理：雷霄骅
 * http://blog.csdn.net/leixiaohua1020
 * leixiaohua1020@126.com
 *****************************************************************************/
static ALWAYS_INLINE void x264_macroblock_encode_internal( x264_t *h, int plane_count, int chroma )
{
    int i_qp = h-&gt;mb.i_qp;
    int b_decimate = h-&gt;mb.b_dct_decimate;
    int b_force_no_skip = 0;
    int nz;
    h-&gt;mb.i_cbp_luma = 0;
    for( int p = 0; p &lt; plane_count; p++ )
        h-&gt;mb.cache.non_zero_count[x264_scan8[LUMA_DC+p]] = 0;
    //PCM，不常见
    if( h-&gt;mb.i_type == I_PCM )
    {
        /* if PCM is chosen, we need to store reconstructed frame data */
        for( int p = 0; p &lt; plane_count; p++ )
            h-&gt;mc.copy[PIXEL_16x16]( h-&gt;mb.pic.p_fdec[p], FDEC_STRIDE, h-&gt;mb.pic.p_fenc[p], FENC_STRIDE, 16 );
        if( chroma )
        {
            int height = 16 &gt;&gt; CHROMA_V_SHIFT;
            h-&gt;mc.copy[PIXEL_8x8]  ( h-&gt;mb.pic.p_fdec[1], FDEC_STRIDE, h-&gt;mb.pic.p_fenc[1], FENC_STRIDE, height );
            h-&gt;mc.copy[PIXEL_8x8]  ( h-&gt;mb.pic.p_fdec[2], FDEC_STRIDE, h-&gt;mb.pic.p_fenc[2], FENC_STRIDE, height );
        }
        return;
    }

    if( !h-&gt;mb.b_allow_skip )
    {
        b_force_no_skip = 1;
        if( IS_SKIP(h-&gt;mb.i_type) )
        {
            if( h-&gt;mb.i_type == P_SKIP )
                h-&gt;mb.i_type = P_L0;
            else if( h-&gt;mb.i_type == B_SKIP )
                h-&gt;mb.i_type = B_DIRECT;
        }
    }
    //根据不同的宏块类型，进行编码
    if( h-&gt;mb.i_type == P_SKIP )
    {
        /* don't do pskip motion compensation if it was already done in macroblock_analyse */
        if( !h-&gt;mb.b_skip_mc )
        {
            int mvx = x264_clip3( h-&gt;mb.cache.mv[0][x264_scan8[0]][0],
                                  h-&gt;mb.mv_min[0], h-&gt;mb.mv_max[0] );
            int mvy = x264_clip3( h-&gt;mb.cache.mv[0][x264_scan8[0]][1],
                                  h-&gt;mb.mv_min[1], h-&gt;mb.mv_max[1] );

            for( int p = 0; p &lt; plane_count; p++ )
                h-&gt;mc.mc_luma( h-&gt;mb.pic.p_fdec[p], FDEC_STRIDE,
                               &amp;h-&gt;mb.pic.p_fref[0][0][p*4], h-&gt;mb.pic.i_stride[p],
                               mvx, mvy, 16, 16, &amp;h-&gt;sh.weight[0][p] );

            if( chroma )
            {
                int v_shift = CHROMA_V_SHIFT;
                int height = 16 &gt;&gt; v_shift;

                /* Special case for mv0, which is (of course) very common in P-skip mode. */
                if( mvx | mvy )
                    h-&gt;mc.mc_chroma( h-&gt;mb.pic.p_fdec[1], h-&gt;mb.pic.p_fdec[2], FDEC_STRIDE,
                                     h-&gt;mb.pic.p_fref[0][0][4], h-&gt;mb.pic.i_stride[1],
                                     mvx, 2*mvy&gt;&gt;v_shift, 8, height );
                else
                    h-&gt;mc.load_deinterleave_chroma_fdec( h-&gt;mb.pic.p_fdec[1], h-&gt;mb.pic.p_fref[0][0][4],
                                                         h-&gt;mb.pic.i_stride[1], height );

                if( h-&gt;sh.weight[0][1].weightfn )
                    h-&gt;sh.weight[0][1].weightfn[8&gt;&gt;2]( h-&gt;mb.pic.p_fdec[1], FDEC_STRIDE,
                                                       h-&gt;mb.pic.p_fdec[1], FDEC_STRIDE,
                                                       &amp;h-&gt;sh.weight[0][1], height );
                if( h-&gt;sh.weight[0][2].weightfn )
                    h-&gt;sh.weight[0][2].weightfn[8&gt;&gt;2]( h-&gt;mb.pic.p_fdec[2], FDEC_STRIDE,
                                                       h-&gt;mb.pic.p_fdec[2], FDEC_STRIDE,
                                                       &amp;h-&gt;sh.weight[0][2], height );
            }
        }
        //编码skip类型宏块
        x264_macroblock_encode_skip( h );
        return;
    }
    if( h-&gt;mb.i_type == B_SKIP )
    {
        /* don't do bskip motion compensation if it was already done in macroblock_analyse */
        if( !h-&gt;mb.b_skip_mc )
            x264_mb_mc( h );
        x264_macroblock_encode_skip( h );
        return;
    }

    if( h-&gt;mb.i_type == I_16x16 )
    {
        h-&gt;mb.b_transform_8x8 = 0;
        //Intra16x16宏块编码-需要Hadamard变换
        //分别编码Y，U，V
    	/*
    	 * 16x16 宏块
    	 *
    	 * +--------+--------+
    	 * |                 |
    	 * |                 |
    	 * |                 |
    	 * +        +        +
    	 * |                 |
    	 * |                 |
    	 * |                 |
    	 * +--------+--------+
    	 *
    	 */
        for( int p = 0; p &lt; plane_count; p++, i_qp = h-&gt;mb.i_chroma_qp )
            x264_mb_encode_i16x16( h, p, i_qp );
    }
    else if( h-&gt;mb.i_type == I_8x8 )
    {
        h-&gt;mb.b_transform_8x8 = 1;
        /* If we already encoded 3 of the 4 i8x8 blocks, we don't have to do them again. */
        if( h-&gt;mb.i_skip_intra )
        {
            h-&gt;mc.copy[PIXEL_16x16]( h-&gt;mb.pic.p_fdec[0], FDEC_STRIDE, h-&gt;mb.pic.i8x8_fdec_buf, 16, 16 );
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 0]] ) = h-&gt;mb.pic.i8x8_nnz_buf[0];
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 2]] ) = h-&gt;mb.pic.i8x8_nnz_buf[1];
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 8]] ) = h-&gt;mb.pic.i8x8_nnz_buf[2];
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[10]] ) = h-&gt;mb.pic.i8x8_nnz_buf[3];
            h-&gt;mb.i_cbp_luma = h-&gt;mb.pic.i8x8_cbp;
            /* In RD mode, restore the now-overwritten DCT data. */
            if( h-&gt;mb.i_skip_intra == 2 )
                h-&gt;mc.memcpy_aligned( h-&gt;dct.luma8x8, h-&gt;mb.pic.i8x8_dct_buf, sizeof(h-&gt;mb.pic.i8x8_dct_buf) );
        }
        for( int p = 0; p &lt; plane_count; p++, i_qp = h-&gt;mb.i_chroma_qp )
        {
            for( int i = (p == 0 &amp;&amp; h-&gt;mb.i_skip_intra) ? 3 : 0 ; i &lt; 4; i++ )
            {
                int i_mode = h-&gt;mb.cache.intra4x4_pred_mode[x264_scan8[4*i]];
                x264_mb_encode_i8x8( h, p, i, i_qp, i_mode, NULL, 1 );
            }
        }
    }
    //Intra4x4类型
    else if( h-&gt;mb.i_type == I_4x4 )
    {
        /*
		 * 帧内预测：16x16 宏块被划分为16个4x4子块
		 *
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 * |    |    |    |    |
		 * +----+----+----+----+
		 *
		 */
        h-&gt;mb.b_transform_8x8 = 0;
        /* If we already encoded 15 of the 16 i4x4 blocks, we don't have to do them again. */
        if( h-&gt;mb.i_skip_intra )
        {
            h-&gt;mc.copy[PIXEL_16x16]( h-&gt;mb.pic.p_fdec[0], FDEC_STRIDE, h-&gt;mb.pic.i4x4_fdec_buf, 16, 16 );
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 0]] ) = h-&gt;mb.pic.i4x4_nnz_buf[0];
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 2]] ) = h-&gt;mb.pic.i4x4_nnz_buf[1];
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 8]] ) = h-&gt;mb.pic.i4x4_nnz_buf[2];
            M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[10]] ) = h-&gt;mb.pic.i4x4_nnz_buf[3];
            h-&gt;mb.i_cbp_luma = h-&gt;mb.pic.i4x4_cbp;
            /* In RD mode, restore the now-overwritten DCT data. */
            if( h-&gt;mb.i_skip_intra == 2 )
                h-&gt;mc.memcpy_aligned( h-&gt;dct.luma4x4, h-&gt;mb.pic.i4x4_dct_buf, sizeof(h-&gt;mb.pic.i4x4_dct_buf) );
        }
        //分别编码Y,U,V
        for( int p = 0; p &lt; plane_count; p++, i_qp = h-&gt;mb.i_chroma_qp )
        {
        	//循环16次，编码16个Intra4x4宏块
            for( int i = (p == 0 &amp;&amp; h-&gt;mb.i_skip_intra) ? 15 : 0 ; i &lt; 16; i++ )
            {
                pixel *p_dst = &amp;h-&gt;mb.pic.p_fdec[p][block_idx_xy_fdec[i]];
                int i_mode = h-&gt;mb.cache.intra4x4_pred_mode[x264_scan8[i]];

                if( (h-&gt;mb.i_neighbour4[i] &amp; (MB_TOPRIGHT|MB_TOP)) == MB_TOP )
                    /* emulate missing topright samples */
                    MPIXEL_X4( &amp;p_dst[4-FDEC_STRIDE] ) = PIXEL_SPLAT_X4( p_dst[3-FDEC_STRIDE] );
                //Intra4x4宏块编码
                /*
                 * +----+
                 * |    |
                 * +----+
                 */
                x264_mb_encode_i4x4( h, p, i, i_qp, i_mode, 1 );
            }
        }
    }
    //包含帧间预测
    else    /* Inter MB */
    {
        int i_decimate_mb = 0;

        /* Don't repeat motion compensation if it was already done in non-RD transform analysis */
        if( !h-&gt;mb.b_skip_mc )
            x264_mb_mc( h );

        if( h-&gt;mb.b_lossless )//lossless情况没研究过
        {
            if( h-&gt;mb.b_transform_8x8 )
                for( int p = 0; p &lt; plane_count; p++ )
                    for( int i8x8 = 0; i8x8 &lt; 4; i8x8++ )
                    {
                        int x = i8x8&amp;1;
                        int y = i8x8&gt;&gt;1;
                        nz = h-&gt;zigzagf.sub_8x8( h-&gt;dct.luma8x8[p*4+i8x8], h-&gt;mb.pic.p_fenc[p] + 8*x + 8*y*FENC_STRIDE,
                                                                           h-&gt;mb.pic.p_fdec[p] + 8*x + 8*y*FDEC_STRIDE );
                        STORE_8x8_NNZ( p, i8x8, nz );
                        h-&gt;mb.i_cbp_luma |= nz &lt;&lt; i8x8;
                    }
            else
                for( int p = 0; p &lt; plane_count; p++ )
                    for( int i4x4 = 0; i4x4 &lt; 16; i4x4++ )
                    {
                        nz = h-&gt;zigzagf.sub_4x4( h-&gt;dct.luma4x4[p*16+i4x4],
                                                 h-&gt;mb.pic.p_fenc[p]+block_idx_xy_fenc[i4x4],
                                                 h-&gt;mb.pic.p_fdec[p]+block_idx_xy_fdec[i4x4] );
                        h-&gt;mb.cache.non_zero_count[x264_scan8[p*16+i4x4]] = nz;
                        h-&gt;mb.i_cbp_luma |= nz &lt;&lt; (i4x4&gt;&gt;2);
                    }
        }
        else if( h-&gt;mb.b_transform_8x8 )//DCT8x8情况暂时没研究过
        {
            ALIGNED_ARRAY_N( dctcoef, dct8x8,[4],[64] );
            b_decimate &amp;= !h-&gt;mb.b_trellis || !h-&gt;param.b_cabac; // 8x8 trellis is inherently optimal decimation for CABAC

            for( int p = 0; p &lt; plane_count; p++, i_qp = h-&gt;mb.i_chroma_qp )
            {
                CLEAR_16x16_NNZ( p );
                h-&gt;dctf.sub16x16_dct8( dct8x8, h-&gt;mb.pic.p_fenc[p], h-&gt;mb.pic.p_fdec[p] );
                h-&gt;nr_count[1+!!p*2] += h-&gt;mb.b_noise_reduction * 4;

                int plane_cbp = 0;
                for( int idx = 0; idx &lt; 4; idx++ )
                {
                    nz = x264_quant_8x8( h, dct8x8[idx], i_qp, ctx_cat_plane[DCT_LUMA_8x8][p], 0, p, idx );

                    if( nz )
                    {
                        h-&gt;zigzagf.scan_8x8( h-&gt;dct.luma8x8[p*4+idx], dct8x8[idx] );
                        if( b_decimate )
                        {
                            int i_decimate_8x8 = h-&gt;quantf.decimate_score64( h-&gt;dct.luma8x8[p*4+idx] );
                            i_decimate_mb += i_decimate_8x8;
                            if( i_decimate_8x8 &gt;= 4 )
                                plane_cbp |= 1&lt;&lt;idx;
                        }
                        else
                            plane_cbp |= 1&lt;&lt;idx;
                    }
                }

                if( i_decimate_mb &gt;= 6 || !b_decimate )
                {
                    h-&gt;mb.i_cbp_luma |= plane_cbp;
                    FOREACH_BIT( idx, 0, plane_cbp )
                    {
                        h-&gt;quantf.dequant_8x8( dct8x8[idx], h-&gt;dequant8_mf[p?CQM_8PC:CQM_8PY], i_qp );
                        h-&gt;dctf.add8x8_idct8( &amp;h-&gt;mb.pic.p_fdec[p][8*(idx&amp;1) + 8*(idx&gt;&gt;1)*FDEC_STRIDE], dct8x8[idx] );
                        STORE_8x8_NNZ( p, idx, 1 );
                    }
                }
            }
        }
        else//最普通的情况
        {
        	/*
			 * 帧间预测：16x16 宏块被划分为8x8
			 * 每个8x8再次被划分为4x4
			 *
			 * ++====+====++====+====++
			 * ||    |    ||    |    ||
			 * ++====+====++====+====++
			 * ||    |    ||    |    ||
			 * ++====+====++====+====++
			 * ||    |    ||    |    ||
			 * ++====+====++====+====++
			 * ||    |    ||    |    ||
			 * ++====+====+=====+====++
			 *
			 */
            ALIGNED_ARRAY_N( dctcoef, dct4x4,[16],[16] );
            for( int p = 0; p &lt; plane_count; p++, i_qp = h-&gt;mb.i_chroma_qp )
            {
                CLEAR_16x16_NNZ( p );
                //16x16DCT（实际上分解为16个4x4DCT）
                //求编码帧p_fenc和重建帧p_fdec之间的残差，然后进行DCT变换
                h-&gt;dctf.sub16x16_dct( dct4x4, h-&gt;mb.pic.p_fenc[p], h-&gt;mb.pic.p_fdec[p] );

                if( h-&gt;mb.b_noise_reduction )
                {
                    h-&gt;nr_count[0+!!p*2] += 16;
                    for( int idx = 0; idx &lt; 16; idx++ )
                        h-&gt;quantf.denoise_dct( dct4x4[idx], h-&gt;nr_residual_sum[0+!!p*2], h-&gt;nr_offset[0+!!p*2], 16 );
                }

                int plane_cbp = 0;
                //16x16的块分成4个8x8的块
                for( int i8x8 = 0; i8x8 &lt; 4; i8x8++ )
                {
                    int i_decimate_8x8 = b_decimate ? 0 : 6;
                    int nnz8x8 = 0;
                    if( h-&gt;mb.b_trellis )
                    {
                        for( int i4x4 = 0; i4x4 &lt; 4; i4x4++ )
                        {
                            int idx = i8x8*4+i4x4;
                            if( x264_quant_4x4_trellis( h, dct4x4[idx], CQM_4PY, i_qp, ctx_cat_plane[DCT_LUMA_4x4][p], 0, !!p, p*16+idx ) )
                            {
                                h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma4x4[p*16+idx], dct4x4[idx] );
                                h-&gt;quantf.dequant_4x4( dct4x4[idx], h-&gt;dequant4_mf[p?CQM_4PC:CQM_4PY], i_qp );
                                if( i_decimate_8x8 &lt; 6 )
                                    i_decimate_8x8 += h-&gt;quantf.decimate_score16( h-&gt;dct.luma4x4[p*16+idx] );
                                h-&gt;mb.cache.non_zero_count[x264_scan8[p*16+idx]] = 1;
                                nnz8x8 = 1;
                            }
                        }
                    }
                    else
                    {
                    	//8x8的块分成4个4x4的块，每个4x4的块再分别进行量化
                        nnz8x8 = nz = h-&gt;quantf.quant_4x4x4( &amp;dct4x4[i8x8*4], h-&gt;quant4_mf[CQM_4PY][i_qp], h-&gt;quant4_bias[CQM_4PY][i_qp] );
                        if( nz )
                        {
                            FOREACH_BIT( idx, i8x8*4, nz )
                            {
                            	//这几步用于建立重建帧
                                h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma4x4[p*16+idx], dct4x4[idx] );
                                //反量化
                                h-&gt;quantf.dequant_4x4( dct4x4[idx], h-&gt;dequant4_mf[p?CQM_4PC:CQM_4PY], i_qp );
                                if( i_decimate_8x8 &lt; 6 )
                                    i_decimate_8x8 += h-&gt;quantf.decimate_score16( h-&gt;dct.luma4x4[p*16+idx] );
                                h-&gt;mb.cache.non_zero_count[x264_scan8[p*16+idx]] = 1;
                            }
                        }
                    }
                    if( nnz8x8 )
                    {
                        i_decimate_mb += i_decimate_8x8;
                        if( i_decimate_8x8 &lt; 4 )
                            STORE_8x8_NNZ( p, i8x8, 0 );
                        else
                            plane_cbp |= 1&lt;&lt;i8x8;
                    }
                }

                if( i_decimate_mb &lt; 6 )
                {
                    plane_cbp = 0;
                    CLEAR_16x16_NNZ( p );
                }
                else
                {
                    h-&gt;mb.i_cbp_luma |= plane_cbp;
                    FOREACH_BIT( i8x8, 0, plane_cbp )
                    {
                    	//用于建立重建帧
                    	//残差进行DCT反变换之后，叠加到预测数据上
                        h-&gt;dctf.add8x8_idct( &amp;h-&gt;mb.pic.p_fdec[p][(i8x8&amp;1)*8 + (i8x8&gt;&gt;1)*8*FDEC_STRIDE], &amp;dct4x4[i8x8*4] );
                    }
                }
            }
        }
    }

    /* encode chroma */
    if( chroma )
    {
        if( IS_INTRA( h-&gt;mb.i_type ) )
        {
            int i_mode = h-&gt;mb.i_chroma_pred_mode;
            if( h-&gt;mb.b_lossless )
                x264_predict_lossless_chroma( h, i_mode );
            else
            {
                h-&gt;predict_chroma[i_mode]( h-&gt;mb.pic.p_fdec[1] );
                h-&gt;predict_chroma[i_mode]( h-&gt;mb.pic.p_fdec[2] );
            }
        }

        /* encode the 8x8 blocks */
        x264_mb_encode_chroma( h, !IS_INTRA( h-&gt;mb.i_type ), h-&gt;mb.i_chroma_qp );
    }
    else
        h-&gt;mb.i_cbp_chroma = 0;

    /* store cbp */
    int cbp = h-&gt;mb.i_cbp_chroma &lt;&lt; 4 | h-&gt;mb.i_cbp_luma;
    if( h-&gt;param.b_cabac )
        cbp |= h-&gt;mb.cache.non_zero_count[x264_scan8[LUMA_DC    ]] &lt;&lt; 8
            |  h-&gt;mb.cache.non_zero_count[x264_scan8[CHROMA_DC+0]] &lt;&lt; 9
            |  h-&gt;mb.cache.non_zero_count[x264_scan8[CHROMA_DC+1]] &lt;&lt; 10;
    h-&gt;mb.cbp[h-&gt;mb.i_mb_xy] = cbp;

    /* Check for P_SKIP
     * XXX: in the me perhaps we should take x264_mb_predict_mv_pskip into account
     *      (if multiple mv give same result)*/
    if( !b_force_no_skip )
    {
        if( h-&gt;mb.i_type == P_L0 &amp;&amp; h-&gt;mb.i_partition == D_16x16 &amp;&amp;
            !(h-&gt;mb.i_cbp_luma | h-&gt;mb.i_cbp_chroma) &amp;&amp;
            M32( h-&gt;mb.cache.mv[0][x264_scan8[0]] ) == M32( h-&gt;mb.cache.pskip_mv )
            &amp;&amp; h-&gt;mb.cache.ref[0][x264_scan8[0]] == 0 )
        {
            h-&gt;mb.i_type = P_SKIP;
        }

        /* Check for B_SKIP */
        if( h-&gt;mb.i_type == B_DIRECT &amp;&amp; !(h-&gt;mb.i_cbp_luma | h-&gt;mb.i_cbp_chroma) )
        {
            h-&gt;mb.i_type = B_SKIP;
        }
    }
}
</pre><br />从源代码可以看出，x264_macroblock_encode_internal()的流程大致如下：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）如果是Skip类型，调用x264_macroblock_encode_skip()编码宏块。<br />（2）如果是Intra16x16类型，调用x264_mb_encode_i16x16()编码宏块。<br />（3）如果是Intra4x4类型，循环16次调用x264_mb_encode_i4x4()编码宏块。<br />（4）如果是Inter类型，则不再调用子函数，而是直接进行编码：<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)对16x16块调用x264_dct_function_t的sub16x16_dct()汇编函数，求得编码宏块数据p_fenc与重建宏块数据p_fdec之间的残差（“sub”），并对残差进行DCT变换。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)分成4个8x8的块，对每个8x8块分别调用x264_quant_function_t的quant_4x4x4()汇编函数进行量化。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)分成16个4x4的块，对每个4x4块分别调用x264_quant_function_t的dequant_4x4()汇编函数进行反量化（用于重建帧）。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">d)分成4个8x8的块，对每个8x8块分别调用x264_dct_function_t的add8x8_idct()汇编函数，对残差进行DCT反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。</blockquote>（5）<span style="white-space:pre">	</span>如果对色度编码，调用x264_mb_encode_chroma()。</blockquote><p>从Inter宏块编码的步骤可以看出，编码就是“DCT变换+量化”两步的组合。下文将会按照顺序记录x264_macroblock_encode_skip()，x264_mb_encode_i16x16()，x264_mb_encode_i4x4()三个函数。</p><p><br /></p><p><br /></p><h2>x264_macroblock_encode_skip()</h2>x264_macroblock_encode_skip()用于编码Skip宏块。该函数的定义位于encoder\macroblock.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_3_4400485" name="code" class="cpp">//编码skip类型宏块
static void x264_macroblock_encode_skip( x264_t *h )
{
	/*
	 * YUV420P的时候在这里相当于在non_zero_count[]填充了v（v=0）：
	 * YUV422P，YUV444P的时候填充了w（w=0）
	 *   |
	 * --+--------------
	 *   | 0 0 0 0 0 0 0 0
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 0 0 0 0
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 w w w w
	 *   | 0 0 0 0 w w w w
	 *   | 0 0 0 0 0 0 0 0
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 v v v v
	 *   | 0 0 0 0 w w w w
	 *   | 0 0 0 0 w w w w
	 */
	//填充non_zero_count[]
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 0]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 2]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[ 8]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[10]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[16+ 0]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[16+ 2]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[32+ 0]] ) = 0;
    M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[32+ 2]] ) = 0;
    if( CHROMA_FORMAT &gt;= CHROMA_422 )
    {
        M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[16+ 8]] ) = 0;
        M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[16+10]] ) = 0;
        M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[32+ 8]] ) = 0;
        M32( &amp;h-&gt;mb.cache.non_zero_count[x264_scan8[32+10]] ) = 0;
    }
    //CBP也赋值为0，即不对亮度和色度编码
    h-&gt;mb.i_cbp_luma = 0;
    h-&gt;mb.i_cbp_chroma = 0;
    h-&gt;mb.cbp[h-&gt;mb.i_mb_xy] = 0;
}
</pre><br />从源代码可以看出，x264_macroblock_encode_skip()的逻辑比较简单，就是将宏块的DCT非零系数缓存non_zero_count[]设置成了0，并且将宏块的CBP也设置为0（代表没有残差信息）。<br /><br /><br /><h2>x264_mb_encode_i16x16()</h2>x264_mb_encode_i16x16()用于编码Intra16x16的宏块。该函数的定义位于encoder\macroblock.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_4_1864138" name="code" class="cpp">//编码I16x16宏块-需要Hadamard变换
/*
 * 16x16 宏块
 *
 * +--------+--------+
 * |                 |       D   D   D   D
 * |                 |
 * |                 |       D   D   D   D
 * +        +        +   +
 * |                 |       D   D   D   D
 * |                 |
 * |                 |       D   D   D   D
 * +--------+--------+
 *
 */
//p代表分量
static void x264_mb_encode_i16x16( x264_t *h, int p, int i_qp )
{
	//编码帧
    pixel *p_src = h-&gt;mb.pic.p_fenc[p];
    //重建帧
    pixel *p_dst = h-&gt;mb.pic.p_fdec[p];

    ALIGNED_ARRAY_N( dctcoef, dct4x4,[16],[16] );
    ALIGNED_ARRAY_N( dctcoef, dct_dc4x4,[16] );

    int nz, block_cbp = 0;
    int decimate_score = h-&gt;mb.b_dct_decimate ? 0 : 9;
    int i_quant_cat = p ? CQM_4IC : CQM_4IY;
    int i_mode = h-&gt;mb.i_intra16x16_pred_mode;

    if( h-&gt;mb.b_lossless )
        x264_predict_lossless_16x16( h, p, i_mode );
    else
        h-&gt;predict_16x16[i_mode]( h-&gt;mb.pic.p_fdec[p] );   //帧内预测.p_fdec是重建帧。p_fenc是编码帧。

    if( h-&gt;mb.b_lossless )
    {
        for( int i = 0; i &lt; 16; i++ )
        {
            int oe = block_idx_xy_fenc[i];
            int od = block_idx_xy_fdec[i];
            nz = h-&gt;zigzagf.sub_4x4ac( h-&gt;dct.luma4x4[16*p+i], p_src+oe, p_dst+od, &amp;dct_dc4x4[block_idx_yx_1d[i]] );
            h-&gt;mb.cache.non_zero_count[x264_scan8[16*p+i]] = nz;
            block_cbp |= nz;
        }
        h-&gt;mb.i_cbp_luma |= block_cbp * 0xf;
        h-&gt;mb.cache.non_zero_count[x264_scan8[LUMA_DC+p]] = array_non_zero( dct_dc4x4, 16 );
        h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma16x16_dc[p], dct_dc4x4 );
        return;
    }

    CLEAR_16x16_NNZ( p );

    h-&gt;dctf.sub16x16_dct( dct4x4, p_src, p_dst );  //求残差，然后进行DCT变换

    if( h-&gt;mb.b_noise_reduction )
        for( int idx = 0; idx &lt; 16; idx++ )
            h-&gt;quantf.denoise_dct( dct4x4[idx], h-&gt;nr_residual_sum[0], h-&gt;nr_offset[0], 16 );
    //获取DC系数
    for( int idx = 0; idx &lt; 16; idx++ )
    {
    	//每个4x4DCT块的[0]元素
        dct_dc4x4[block_idx_xy_1d[idx]] = dct4x4[idx][0];
        //抽取出来之后，赋值0
        dct4x4[idx][0] = 0;
    }

    if( h-&gt;mb.b_trellis )
    {
        for( int idx = 0; idx &lt; 16; idx++ )
            if( x264_quant_4x4_trellis( h, dct4x4[idx], i_quant_cat, i_qp, ctx_cat_plane[DCT_LUMA_AC][p], 1, !!p, idx ) )
            {
                block_cbp = 0xf;
                h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma4x4[16*p+idx], dct4x4[idx] );
                h-&gt;quantf.dequant_4x4( dct4x4[idx], h-&gt;dequant4_mf[i_quant_cat], i_qp );
                if( decimate_score &lt; 6 ) decimate_score += h-&gt;quantf.decimate_score15( h-&gt;dct.luma4x4[16*p+idx] );
                h-&gt;mb.cache.non_zero_count[x264_scan8[16*p+idx]] = 1;
            }
    }
    else
    {
    	//先分成4个8x8？
        for( int i8x8 = 0; i8x8 &lt; 4; i8x8++ )
        {
        	//每个8x8做4个4x4量化
            nz = h-&gt;quantf.quant_4x4x4( &amp;dct4x4[i8x8*4], h-&gt;quant4_mf[i_quant_cat][i_qp], h-&gt;quant4_bias[i_quant_cat][i_qp] );
            if( nz )
            {
                block_cbp = 0xf;
                FOREACH_BIT( idx, i8x8*4, nz )
                {
                	//建立重建的帧
                	//之子扫描
                    h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma4x4[16*p+idx], dct4x4[idx] );
                    //反量化，用于重建图像
                    h-&gt;quantf.dequant_4x4( dct4x4[idx], h-&gt;dequant4_mf[i_quant_cat], i_qp );
                    if( decimate_score &lt; 6 ) decimate_score += h-&gt;quantf.decimate_score15( h-&gt;dct.luma4x4[16*p+idx] );
                    h-&gt;mb.cache.non_zero_count[x264_scan8[16*p+idx]] = 1;
                }
            }
        }
    }

    /* Writing the 16 CBFs in an i16x16 block is quite costly, so decimation can save many bits. */
    /* More useful with CAVLC, but still useful with CABAC. */
    if( decimate_score &lt; 6 )
    {
        CLEAR_16x16_NNZ( p );
        block_cbp = 0;
    }
    else
        h-&gt;mb.i_cbp_luma |= block_cbp;

    //16个DC系数-Hadamard变换
    h-&gt;dctf.dct4x4dc( dct_dc4x4 );
    if( h-&gt;mb.b_trellis )
        nz = x264_quant_luma_dc_trellis( h, dct_dc4x4, i_quant_cat, i_qp, ctx_cat_plane[DCT_LUMA_DC][p], 1, LUMA_DC+p );
    else
    	//DC-Hadamard变换之后-量化
        nz = h-&gt;quantf.quant_4x4_dc( dct_dc4x4, h-&gt;quant4_mf[i_quant_cat][i_qp][0]&gt;&gt;1, h-&gt;quant4_bias[i_quant_cat][i_qp][0]&lt;&lt;1 );

    h-&gt;mb.cache.non_zero_count[x264_scan8[LUMA_DC+p]] = nz;
    if( nz )
    {

    	//之子扫描
        h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma16x16_dc[p], dct_dc4x4 );

        /* output samples to fdec */
        //DC-反变换
        h-&gt;dctf.idct4x4dc( dct_dc4x4 );
        //DC-反量化
        h-&gt;quantf.dequant_4x4_dc( dct_dc4x4, h-&gt;dequant4_mf[i_quant_cat], i_qp );  /* XXX not inversed */
        if( block_cbp )
            for( int i = 0; i &lt; 16; i++ )//循环16个4x4DCT块
                dct4x4[i][0] = dct_dc4x4[block_idx_xy_1d[i]];//把DC系数重新赋值到每个DCT数组的[0]元素上
    }

    /* put pixels to fdec */
    // fdec代表重建帧
    if( block_cbp )
        h-&gt;dctf.add16x16_idct( p_dst, dct4x4 );//DCT反变换后，叠加到预测数据上（通用）
    else if( nz )
        h-&gt;dctf.add16x16_idct_dc( p_dst, dct_dc4x4 );//DCT反变换后，叠加到预测数据上（只有DC系数的时候）
}
</pre><br />简单整理一下x264_mb_encode_i16x16()的逻辑，如下所示：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用predict_16x16[]()汇编函数对重建宏块数据p_fdec进行帧内预测。<br />（2）调用x264_dct_function_t的sub16x16_dct()汇编函数，计算重建宏块数据p_fdec与编码宏块数据p_fenc之间的残差，然后对残差做DCT变换。<br />（3）抽取出来16个4x4DCT小块的DC系数，存储于dct_dc4x4[]。<br />（4）分成4个8x8的块，对每个8x8块分别调用x264_quant_function_t的quant_4x4x4()汇编函数进行量化。<br />（5）分成16个4x4的块，对每个4x4块分别调用x264_quant_function_t的dequant_4x4()汇编函数进行反量化（用于重建帧）。<br />（6）对于dct_dc4x4[]中16个小块的DC系数作如下处理：<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用x264_dct_function_t的dct4x4dc()汇编函数进行Hadamard变换。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)调用x264_quant_function_t的quant_4x4_dc()汇编函数进行DC系数的量化。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)调用x264_dct_function_t的idct4x4dc()汇编函数进行Hadamard反变换。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">d)调用x264_quant_function_t的dequant_4x4_dc()汇编函数进行DC系数的反量化。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">e)将反量化后的DC系数重新放到16x16块对应的位置上。</blockquote>（7）调用x264_dct_function_t的add16x16_idct()汇编函数，对残差进行DCT反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。</blockquote><p>可以看出Intra16x16编码的过程就是一个“DCT变换 + 量化 + Hadamard变换”的流程。其中“DCT变换 + 量化”是一个通用的编码步骤，而“Hadamard变换”是专属于Intra16x16宏块的步骤。</p><br /><br /><h2>x264_mb_encode_i4x4()</h2>x264_mb_encode_i4x4()用于编码Intra4x4的宏块。该函数的定义位于encoder\macroblock.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_5_9294771" name="code" class="cpp">//编码Intra4x4
/*
 * +----+
 * |    |
 * +----+
 */
static ALWAYS_INLINE void x264_mb_encode_i4x4( x264_t *h, int p, int idx, int i_qp, int i_mode, int b_predict )
{
    int nz;
    //编码帧
    pixel *p_src = &amp;h-&gt;mb.pic.p_fenc[p][block_idx_xy_fenc[idx]];
    //重建帧
    pixel *p_dst = &amp;h-&gt;mb.pic.p_fdec[p][block_idx_xy_fdec[idx]];
    ALIGNED_ARRAY_N( dctcoef, dct4x4,[16] );

    if( b_predict )
    {
        if( h-&gt;mb.b_lossless )
            x264_predict_lossless_4x4( h, p_dst, p, idx, i_mode );
        else
            h-&gt;predict_4x4[i_mode]( p_dst );//帧内预测，存于p_dst
    }

    if( h-&gt;mb.b_lossless )
    {
        nz = h-&gt;zigzagf.sub_4x4( h-&gt;dct.luma4x4[p*16+idx], p_src, p_dst );
        h-&gt;mb.cache.non_zero_count[x264_scan8[p*16+idx]] = nz;
        h-&gt;mb.i_cbp_luma |= nz&lt;&lt;(idx&gt;&gt;2);
        return;
    }

    h-&gt;dctf.sub4x4_dct( dct4x4, p_src, p_dst );//求p_src与p_dst之间的残差，并且进行DCT变换
    //量化
    nz = x264_quant_4x4( h, dct4x4, i_qp, ctx_cat_plane[DCT_LUMA_4x4][p], 1, p, idx );
    h-&gt;mb.cache.non_zero_count[x264_scan8[p*16+idx]] = nz;
    if( nz )
    {
    	//解码并且建立重建帧（p_dst）
        h-&gt;mb.i_cbp_luma |= 1&lt;&lt;(idx&gt;&gt;2);
        //DCT系数重新排个序-从之子扫描变换为普通扫描
        h-&gt;zigzagf.scan_4x4( h-&gt;dct.luma4x4[p*16+idx], dct4x4 );
        //反量化
        h-&gt;quantf.dequant_4x4( dct4x4, h-&gt;dequant4_mf[p?CQM_4IC:CQM_4IY], i_qp );
        //DCT残差反变换，并且叠加到预测数据上，形成重建帧
        h-&gt;dctf.add4x4_idct( p_dst, dct4x4 );
    }
}
</pre><br />简单整理一下x264_mb_encode_i4x4()的逻辑，如下所示：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用predict_4x4[]()汇编函数对重建宏块数据p_fdec进行帧内预测。<br />（2）调用x264_dct_function_t的sub4x4_dct ()汇编函数，计算重建宏块数据p_fdec与编码宏块数据p_fenc之间的残差，然后对残差做DCT变换。<br />（3）调用x264_quant_function_t的quant_4x4()汇编函数进行量化。<br />（4）调用x264_quant_function_t的dequant_4x4()汇编函数进行反量化（用于重建帧）。<br />（5）调用x264_dct_function_t的add4x4_idct()汇编函数，对残差进行DCT反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。</blockquote><p>可以看出Intra4x4编码的过程就是一个“DCT变换 + 量化”的流程。</p><br /><br /><h2>DCT和量化的知识</h2>宏块的编码过程就是一个“DCT变换+量化”的过程。简单记录一下相关的知识。<br /><br /><h3>DCT变换</h3><p>DCT变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。二维8x8DCT变换常见的示意图如下所示。</p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150523234300433" alt="" /><br /></p>早期的DCT变换都使用了8x8的矩阵（变换系数为小数）。在H.264标准中新提出了一种4x4的矩阵。这种4x4 DCT变换的系数都是整数，一方面提高了运算的准确性，一方面也利于代码的优化。4x4整数DCT变换的示意图如下所示（作为对比，右侧为4x4块的Hadamard变换的示意图）。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234338512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>4x4整数DCT变换的公式如下所示。&nbsp;<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234512034?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><p>对该公式中的矩阵乘法可以转换为2次一维DCT变换：首先对4x4块中的每行像素进行一维DCT变换，然后再对4x4块中的每列像素进行一维DCT变换。而一维的DCT变换是可以改造成为蝶形快速算法的，如下所示。</p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150523234535825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p>同理，DCT反变换就是DCT变换的逆变换。DCT反变换的公式如下所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234729293?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>同理，DCT反变换的矩阵乘法也可以改造成为2次一维IDCT变换：首先对4x4块中的每行像素进行一维IDCT变换，然后再对4x4块中的每列像素进行一维IDCT变换。而一维的IDCT变换也可以改造成为蝶形快速算法，如下所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234608179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>除了4x4DCT变换之外，新版本的H.264标准中还引入了一种8x8DCT。目前针对这种8x8DCT我还没有做研究，暂时不做记录。<br /><br /><h3>量化</h3>量化是H.264视频压缩编码中对视频质量影响最大的地方，也是会导致“信息丢失”的地方。量化的原理可以表示为下面公式：<br /><div style="text-align: center;"><strong>FQ=round(y/Qstep)</strong></div>其中，y 为输入样本点编码，Qstep为量化步长，FQ 为y 的量化值，round()为取整函数（其输出为与输入实数最近的整数）。其相反过程，即反量化为：<br /><div style="text-align: center;"><strong>y’＝FQ/Qstep</strong></div>如果Qstep较大，则量化值FQ取值较小，其相应的编码长度较小，但是但反量化时损失较多的图像细节信息。简而言之，Qstep越大，视频压缩编码后体积越小，视频质量越差。<br />在H.264 中，量化步长Qstep 共有52 个值，如下表所示。其中QP 是量化参数，是量化步长的序号。当QP 取最小值0 时代表最精细的量化，当QP 取最大值51 时代表最粗糙的量化。QP 每增加6，Qstep 增加一倍。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234831552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>《H.264标准》中规定，量化过程除了完成本职工作外，还需要完成它前一步DCT变换中“系数相乘”的工作。这一步骤的推导过程不再记录，直接给出最终的公式（这个公式完全为整数运算，同时避免了除法的使用）：<br /><div style="text-align: center;"><strong>|Zij| = (|Wij|*MF + f)&gt;&gt;qbits</strong></div><div style="text-align: center;"><strong>sign(Zij) = sign (Wij)</strong></div>其中：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">sign()为符号函数。<br />Wij为DCT变换后的系数。<br />MF的值如下表所示。表中只列出对应QP 值为0 到5 的MF 值。QP大于6之后，将QP实行对6取余数操作，再找到MF的值。<br />qbits计算公式为“qbits = 15 + floor(QP/6)”。即它的值随QP 值每增加6 而增加1。<br />f 是偏移量（用于改善恢复图像的视觉效果）。对帧内预测图像块取2^qbits/3，对帧间预测图像块取2^qbits/6。</blockquote><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234734946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>为了更形象的显示MF的取值，做了下面一张示意图。图中深蓝色代表MF取值较大的点，而浅蓝色代表MF取值较小的点。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150523234931191" alt="" /></div><div style="text-align: center;"><br /></div><p><br /></p><h2>DCT相关的源代码</h2><p>DCT模块的初始化函数是x264_dct_init()。该函数对x264_dct_function_t结构体中的函数指针进行了赋值。X264运行的过程中只要调用x264_dct_function_t的函数指针就可以完成相应的功能。</p><p><br /></p><h3>x264_dct_init()</h3>x264_dct_init()用于初始化DCT变换和DCT反变换相关的汇编函数。该函数的定义位于common\dct.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_6_1327212" name="code" class="cpp">/****************************************************************************
 * x264_dct_init:
 ****************************************************************************/
void x264_dct_init( int cpu, x264_dct_function_t *dctf )
{
	//C语言版本
	//4x4DCT变换
    dctf-&gt;sub4x4_dct    = sub4x4_dct;
    dctf-&gt;add4x4_idct   = add4x4_idct;
    //8x8块：分解成4个4x4DCT变换，调用4次sub4x4_dct()
    dctf-&gt;sub8x8_dct    = sub8x8_dct;
    dctf-&gt;sub8x8_dct_dc = sub8x8_dct_dc;
    dctf-&gt;add8x8_idct   = add8x8_idct;
    dctf-&gt;add8x8_idct_dc = add8x8_idct_dc;

    dctf-&gt;sub8x16_dct_dc = sub8x16_dct_dc;
    //16x16块：分解成4个8x8块，调用4次sub8x8_dct()
    //实际上每个sub8x8_dct()又分解成4个4x4DCT变换，调用4次sub4x4_dct()
    dctf-&gt;sub16x16_dct  = sub16x16_dct;
    dctf-&gt;add16x16_idct = add16x16_idct;
    dctf-&gt;add16x16_idct_dc = add16x16_idct_dc;
    //8x8DCT，注意：后缀是_dct8
    dctf-&gt;sub8x8_dct8   = sub8x8_dct8;
    dctf-&gt;add8x8_idct8  = add8x8_idct8;

    dctf-&gt;sub16x16_dct8  = sub16x16_dct8;
    dctf-&gt;add16x16_idct8 = add16x16_idct8;
    //Hadamard变换
    dctf-&gt;dct4x4dc  = dct4x4dc;
    dctf-&gt;idct4x4dc = idct4x4dc;

    dctf-&gt;dct2x4dc = dct2x4dc;

#if HIGH_BIT_DEPTH
#if HAVE_MMX
    if( cpu&amp;X264_CPU_MMX )
    {
        dctf-&gt;sub4x4_dct    = x264_sub4x4_dct_mmx;
        dctf-&gt;sub8x8_dct    = x264_sub8x8_dct_mmx;
        dctf-&gt;sub16x16_dct  = x264_sub16x16_dct_mmx;
    }
    if( cpu&amp;X264_CPU_SSE2 )
    {
        dctf-&gt;add4x4_idct     = x264_add4x4_idct_sse2;
        dctf-&gt;dct4x4dc        = x264_dct4x4dc_sse2;
        dctf-&gt;idct4x4dc       = x264_idct4x4dc_sse2;
        dctf-&gt;sub8x8_dct8     = x264_sub8x8_dct8_sse2;
        dctf-&gt;sub16x16_dct8   = x264_sub16x16_dct8_sse2;
        dctf-&gt;add8x8_idct     = x264_add8x8_idct_sse2;
        dctf-&gt;add16x16_idct   = x264_add16x16_idct_sse2;
        dctf-&gt;add8x8_idct8    = x264_add8x8_idct8_sse2;
        dctf-&gt;add16x16_idct8    = x264_add16x16_idct8_sse2;
        dctf-&gt;sub8x8_dct_dc   = x264_sub8x8_dct_dc_sse2;
        dctf-&gt;add8x8_idct_dc  = x264_add8x8_idct_dc_sse2;
        dctf-&gt;sub8x16_dct_dc  = x264_sub8x16_dct_dc_sse2;
        dctf-&gt;add16x16_idct_dc= x264_add16x16_idct_dc_sse2;
    }
    if( cpu&amp;X264_CPU_SSE4 )
    {
        dctf-&gt;sub8x8_dct8     = x264_sub8x8_dct8_sse4;
        dctf-&gt;sub16x16_dct8   = x264_sub16x16_dct8_sse4;
    }
    if( cpu&amp;X264_CPU_AVX )
    {
        dctf-&gt;add4x4_idct     = x264_add4x4_idct_avx;
        dctf-&gt;dct4x4dc        = x264_dct4x4dc_avx;
        dctf-&gt;idct4x4dc       = x264_idct4x4dc_avx;
        dctf-&gt;sub8x8_dct8     = x264_sub8x8_dct8_avx;
        dctf-&gt;sub16x16_dct8   = x264_sub16x16_dct8_avx;
        dctf-&gt;add8x8_idct     = x264_add8x8_idct_avx;
        dctf-&gt;add16x16_idct   = x264_add16x16_idct_avx;
        dctf-&gt;add8x8_idct8    = x264_add8x8_idct8_avx;
        dctf-&gt;add16x16_idct8  = x264_add16x16_idct8_avx;
        dctf-&gt;add8x8_idct_dc  = x264_add8x8_idct_dc_avx;
        dctf-&gt;sub8x16_dct_dc  = x264_sub8x16_dct_dc_avx;
        dctf-&gt;add16x16_idct_dc= x264_add16x16_idct_dc_avx;
    }
#endif // HAVE_MMX
#else // !HIGH_BIT_DEPTH
    //MMX版本
#if HAVE_MMX
    if( cpu&amp;X264_CPU_MMX )
    {
        dctf-&gt;sub4x4_dct    = x264_sub4x4_dct_mmx;
        dctf-&gt;add4x4_idct   = x264_add4x4_idct_mmx;
        dctf-&gt;idct4x4dc     = x264_idct4x4dc_mmx;
        dctf-&gt;sub8x8_dct_dc = x264_sub8x8_dct_dc_mmx2;
    //此处省略大量的X86、ARM等平台的汇编函数初始化代码
}
</pre><br />从源代码可以看出，x264_dct_init()初始化了一系列的DCT变换的函数，这些DCT函数名称有如下规律：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）DCT函数名称前面有“sub”，代表对两块像素相减得到残差之后，再进行DCT变换。<br />（2）DCT反变换函数名称前面有“add”，代表将DCT反变换之后的残差数据叠加到预测数据上。<br />（3）以“dct8”为结尾的函数使用了8x8DCT（未研究过），其余函数是用的都是4x4DCT。</blockquote>x264_dct_init()的输入参数x264_dct_function_t是一个结构体，其中包含了各种DCT函数的接口。x264_dct_function_t的定义如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_7_3118888" name="code" class="cpp">typedef struct
{
    // pix1  stride = FENC_STRIDE
    // pix2  stride = FDEC_STRIDE
    // p_dst stride = FDEC_STRIDE
    void (*sub4x4_dct)   ( dctcoef dct[16], pixel *pix1, pixel *pix2 );
    void (*add4x4_idct)  ( pixel *p_dst, dctcoef dct[16] );

    void (*sub8x8_dct)   ( dctcoef dct[4][16], pixel *pix1, pixel *pix2 );
    void (*sub8x8_dct_dc)( dctcoef dct[4], pixel *pix1, pixel *pix2 );
    void (*add8x8_idct)  ( pixel *p_dst, dctcoef dct[4][16] );
    void (*add8x8_idct_dc) ( pixel *p_dst, dctcoef dct[4] );

    void (*sub8x16_dct_dc)( dctcoef dct[8], pixel *pix1, pixel *pix2 );

    void (*sub16x16_dct) ( dctcoef dct[16][16], pixel *pix1, pixel *pix2 );
    void (*add16x16_idct)( pixel *p_dst, dctcoef dct[16][16] );
    void (*add16x16_idct_dc) ( pixel *p_dst, dctcoef dct[16] );

    void (*sub8x8_dct8)  ( dctcoef dct[64], pixel *pix1, pixel *pix2 );
    void (*add8x8_idct8) ( pixel *p_dst, dctcoef dct[64] );

    void (*sub16x16_dct8) ( dctcoef dct[4][64], pixel *pix1, pixel *pix2 );
    void (*add16x16_idct8)( pixel *p_dst, dctcoef dct[4][64] );

    void (*dct4x4dc) ( dctcoef d[16] );
    void (*idct4x4dc)( dctcoef d[16] );

    void (*dct2x4dc)( dctcoef dct[8], dctcoef dct4x4[8][16] );

} x264_dct_function_t;</pre><p>x264_dct_init()的工作就是对x264_dct_function_t中的函数指针进行赋值。由于DCT函数很多，不便于一一研究，下文仅举例分析几个典型的4x4DCT函数：4x4DCT变换函数sub4x4_dct()，4x4IDCT变换函数add4x4_idct()，8x8块的4x4DCT变换函数sub8x8_dct()，16x16块的4x4DCT变换函数sub16x16_dct()，4x4Hadamard变换函数dct4x4dc()。</p><p><br /></p><h3>sub4x4_dct()</h3>sub4x4_dct()可以将两块4x4的图像相减求残差后，进行DCT变换。该函数的定义位于common\dct.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_8_3024757" name="code" class="cpp">/*
 * 求残差用
 * 注意求的是一个“方块”形像素
 *
 * 参数的含义如下：
 * diff：输出的残差数据
 * i_size：方块的大小
 * pix1：输入数据1
 * i_pix1：输入数据1一行像素大小（stride）
 * pix2：输入数据2
 * i_pix2：输入数据2一行像素大小（stride）
 *
 */
static inline void pixel_sub_wxh( dctcoef *diff, int i_size,
                                  pixel *pix1, int i_pix1, pixel *pix2, int i_pix2 )
{
    for( int y = 0; y &lt; i_size; y++ )
    {
        for( int x = 0; x &lt; i_size; x++ )
            diff[x + y*i_size] = pix1[x] - pix2[x];//求残差
        pix1 += i_pix1;//前进到下一行
        pix2 += i_pix2;
    }
}
//4x4DCT变换
//注意首先获取pix1和pix2两块数据的残差，然后再进行变换
//返回dct[16]
static void sub4x4_dct( dctcoef dct[16], pixel *pix1, pixel *pix2 )
{
    dctcoef d[16];
    dctcoef tmp[16];
    //获取残差数据，存入d[16]
    //pix1一般为编码帧（enc）
    //pix2一般为重建帧（dec）
    pixel_sub_wxh( d, 4, pix1, FENC_STRIDE, pix2, FDEC_STRIDE );

    //处理残差d[16]
    //蝶形算法：横向4个像素
    for( int i = 0; i &lt; 4; i++ )
    {
        int s03 = d[i*4+0] + d[i*4+3];
        int s12 = d[i*4+1] + d[i*4+2];
        int d03 = d[i*4+0] - d[i*4+3];
        int d12 = d[i*4+1] - d[i*4+2];

        tmp[0*4+i] =   s03 +   s12;
        tmp[1*4+i] = 2*d03 +   d12;
        tmp[2*4+i] =   s03 -   s12;
        tmp[3*4+i] =   d03 - 2*d12;
    }
    //蝶形算法：纵向
    for( int i = 0; i &lt; 4; i++ )
    {
        int s03 = tmp[i*4+0] + tmp[i*4+3];
        int s12 = tmp[i*4+1] + tmp[i*4+2];
        int d03 = tmp[i*4+0] - tmp[i*4+3];
        int d12 = tmp[i*4+1] - tmp[i*4+2];

        dct[i*4+0] =   s03 +   s12;
        dct[i*4+1] = 2*d03 +   d12;
        dct[i*4+2] =   s03 -   s12;
        dct[i*4+3] =   d03 - 2*d12;
    }
}
</pre><br />从源代码可以看出，sub4x4_dct()首先调用pixel_sub_wxh()求出两个输入图像块的残差，然后使用蝶形快速算法计算残差图像的DCT系数。<br /><br /><h3>add4x4_idct()</h3>add4x4_idct()可以将残差数据进行DCT反变换，并将变换后得到的残差像素数据叠加到预测数据上。该函数的定义位于common\dct.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_9_6485656" name="code" class="cpp">//4x4DCT反变换（“add”代表叠加到已有的像素上）
static void add4x4_idct( pixel *p_dst, dctcoef dct[16] )
{
    dctcoef d[16];
    dctcoef tmp[16];

    for( int i = 0; i &lt; 4; i++ )
    {
        int s02 =  dct[0*4+i]     +  dct[2*4+i];
        int d02 =  dct[0*4+i]     -  dct[2*4+i];
        int s13 =  dct[1*4+i]     + (dct[3*4+i]&gt;&gt;1);
        int d13 = (dct[1*4+i]&gt;&gt;1) -  dct[3*4+i];

        tmp[i*4+0] = s02 + s13;
        tmp[i*4+1] = d02 + d13;
        tmp[i*4+2] = d02 - d13;
        tmp[i*4+3] = s02 - s13;
    }

    for( int i = 0; i &lt; 4; i++ )
    {
        int s02 =  tmp[0*4+i]     +  tmp[2*4+i];
        int d02 =  tmp[0*4+i]     -  tmp[2*4+i];
        int s13 =  tmp[1*4+i]     + (tmp[3*4+i]&gt;&gt;1);
        int d13 = (tmp[1*4+i]&gt;&gt;1) -  tmp[3*4+i];

        d[0*4+i] = ( s02 + s13 + 32 ) &gt;&gt; 6;
        d[1*4+i] = ( d02 + d13 + 32 ) &gt;&gt; 6;
        d[2*4+i] = ( d02 - d13 + 32 ) &gt;&gt; 6;
        d[3*4+i] = ( s02 - s13 + 32 ) &gt;&gt; 6;
    }


    for( int y = 0; y &lt; 4; y++ )
    {
        for( int x = 0; x &lt; 4; x++ )
            p_dst[x] = x264_clip_pixel( p_dst[x] + d[y*4+x] );
        p_dst += FDEC_STRIDE;
    }
}
</pre><br />从源代码可以看出，add4x4_idct()首先采用快速蝶形算法对DCT系数进行DCT反变换后得到残差像素数据，然后再将残差数据叠加到p_dst指向的像素上。需要注意这里是“叠加”而不是“赋值”。<br /><br /><h3>sub8x8_dct()</h3>sub8x8_dct()可以将两块8x8的图像相减求残差后，进行4x4DCT变换。该函数的定义位于common\dct.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_10_8866759" name="code" class="cpp">//8x8块：分解成4个4x4DCT变换，调用4次sub4x4_dct()
//返回dct[4][16]
static void sub8x8_dct( dctcoef dct[4][16], pixel *pix1, pixel *pix2 )
{
	/*
	 * 8x8 宏块被划分为4个4x4子块
	 *
	 * +---+---+
	 * | 0 | 1 |
	 * +---+---+
	 * | 2 | 3 |
	 * +---+---+
	 *
	 */
    sub4x4_dct( dct[0], &amp;pix1[0], &amp;pix2[0] );
    sub4x4_dct( dct[1], &amp;pix1[4], &amp;pix2[4] );
    sub4x4_dct( dct[2], &amp;pix1[4*FENC_STRIDE+0], &amp;pix2[4*FDEC_STRIDE+0] );
    sub4x4_dct( dct[3], &amp;pix1[4*FENC_STRIDE+4], &amp;pix2[4*FDEC_STRIDE+4] );
}
</pre><br />从源代码可以看出， sub8x8_dct()将8x8的图像块分成4个4x4的图像块，分别调用了sub4x4_dct()。<br /><br /><h3>sub16x16_dct()</h3>sub16x16_dct()可以将两块16x16的图像相减求残差后，进行4x4DCT变换。该函数的定义位于common\dct.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_11_1488627" name="code" class="cpp">//16x16块：分解成4个8x8的块做DCT变换，调用4次sub8x8_dct()
//返回dct[16][16]
static void sub16x16_dct( dctcoef dct[16][16], pixel *pix1, pixel *pix2 )
{
	/*
	 * 16x16 宏块被划分为4个8x8子块
	 *
	 * +--------+--------+
	 * |        |        |
	 * |   0    |   1    |
	 * |        |        |
	 * +--------+--------+
	 * |        |        |
	 * |   2    |   3    |
	 * |        |        |
	 * +--------+--------+
	 *
	 */
    sub8x8_dct( &amp;dct[ 0], &amp;pix1[0], &amp;pix2[0] );  //0
    sub8x8_dct( &amp;dct[ 4], &amp;pix1[8], &amp;pix2[8] );  //1
    sub8x8_dct( &amp;dct[ 8], &amp;pix1[8*FENC_STRIDE+0], &amp;pix2[8*FDEC_STRIDE+0] );  //2
    sub8x8_dct( &amp;dct[12], &amp;pix1[8*FENC_STRIDE+8], &amp;pix2[8*FDEC_STRIDE+8] );  //3
}
</pre><br />从源代码可以看出， sub8x8_dct()将16x16的图像块分成4个8x8的图像块，分别调用了sub8x8_dct()。而sub8x8_dct()实际上又调用了4次sub4x4_dct()。所以可以得知，不论sub16x16_dct()，sub8x8_dct()还是sub4x4_dct()，本质都是进行4x4DCT。<br /><br /><h3>dct4x4dc()</h3>dct4x4dc()可以将输入的4x4图像块进行Hadamard变换。该函数的定义位于common\dct.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_12_1917883" name="code" class="cpp">//Hadamard变换
static void dct4x4dc( dctcoef d[16] )
{
    dctcoef tmp[16];

    //蝶形算法：横向的4个像素
    for( int i = 0; i &lt; 4; i++ )
    {

        int s01 = d[i*4+0] + d[i*4+1];
        int d01 = d[i*4+0] - d[i*4+1];
        int s23 = d[i*4+2] + d[i*4+3];
        int d23 = d[i*4+2] - d[i*4+3];

        tmp[0*4+i] = s01 + s23;
        tmp[1*4+i] = s01 - s23;
        tmp[2*4+i] = d01 - d23;
        tmp[3*4+i] = d01 + d23;
    }
    //蝶形算法：纵向
    for( int i = 0; i &lt; 4; i++ )
    {
        int s01 = tmp[i*4+0] + tmp[i*4+1];
        int d01 = tmp[i*4+0] - tmp[i*4+1];
        int s23 = tmp[i*4+2] + tmp[i*4+3];
        int d23 = tmp[i*4+2] - tmp[i*4+3];

        d[i*4+0] = ( s01 + s23 + 1 ) &gt;&gt; 1;
        d[i*4+1] = ( s01 - s23 + 1 ) &gt;&gt; 1;
        d[i*4+2] = ( d01 - d23 + 1 ) &gt;&gt; 1;
        d[i*4+3] = ( d01 + d23 + 1 ) &gt;&gt; 1;
    }
}
</pre><br />从源代码可以看出，dct4x4dc()实现了Hadamard快速蝶形算法。<br /><br /><br /><h2>量化相关的源代码</h2><p>量化模块的初始化函数是x264_quant_init()。该函数对x264_quant_function_t结构体中的函数指针进行了赋值。X264运行的过程中只要调用x264_quant_function_t的函数指针就可以完成相应的功能。</p><p><br /></p><h3>x264_quant_init()</h3>x264_quant_init()初始化量化和反量化相关的汇编函数。该函数的定义位于common\quant.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_13_4614632" name="code" class="cpp">//量化
void x264_quant_init( x264_t *h, int cpu, x264_quant_function_t *pf )
{
	//这个好像是针对8x8DCT的
    pf-&gt;quant_8x8 = quant_8x8;

    //量化4x4=16个
    pf-&gt;quant_4x4 = quant_4x4;
    //注意：处理4个4x4的块
    pf-&gt;quant_4x4x4 = quant_4x4x4;
    //Intra16x16中，16个DC系数Hadamard变换后对的它们量化
    pf-&gt;quant_4x4_dc = quant_4x4_dc;
    pf-&gt;quant_2x2_dc = quant_2x2_dc;
    //反量化4x4=16个
    pf-&gt;dequant_4x4 = dequant_4x4;
    pf-&gt;dequant_4x4_dc = dequant_4x4_dc;
    pf-&gt;dequant_8x8 = dequant_8x8;

    pf-&gt;idct_dequant_2x4_dc = idct_dequant_2x4_dc;
    pf-&gt;idct_dequant_2x4_dconly = idct_dequant_2x4_dconly;

    pf-&gt;optimize_chroma_2x2_dc = optimize_chroma_2x2_dc;
    pf-&gt;optimize_chroma_2x4_dc = optimize_chroma_2x4_dc;

    pf-&gt;denoise_dct = x264_denoise_dct;
    pf-&gt;decimate_score15 = x264_decimate_score15;
    pf-&gt;decimate_score16 = x264_decimate_score16;
    pf-&gt;decimate_score64 = x264_decimate_score64;

    pf-&gt;coeff_last4 = x264_coeff_last4;
    pf-&gt;coeff_last8 = x264_coeff_last8;
    pf-&gt;coeff_last[  DCT_LUMA_AC] = x264_coeff_last15;
    pf-&gt;coeff_last[ DCT_LUMA_4x4] = x264_coeff_last16;
    pf-&gt;coeff_last[ DCT_LUMA_8x8] = x264_coeff_last64;
    pf-&gt;coeff_level_run4 = x264_coeff_level_run4;
    pf-&gt;coeff_level_run8 = x264_coeff_level_run8;
    pf-&gt;coeff_level_run[  DCT_LUMA_AC] = x264_coeff_level_run15;
    pf-&gt;coeff_level_run[ DCT_LUMA_4x4] = x264_coeff_level_run16;

#if HIGH_BIT_DEPTH
#if HAVE_MMX
    INIT_TRELLIS( sse2 );
    if( cpu&amp;X264_CPU_MMX2 )
    {
#if ARCH_X86
        pf-&gt;denoise_dct = x264_denoise_dct_mmx;
        pf-&gt;decimate_score15 = x264_decimate_score15_mmx2;
        pf-&gt;decimate_score16 = x264_decimate_score16_mmx2;
        pf-&gt;decimate_score64 = x264_decimate_score64_mmx2;
        pf-&gt;coeff_last8 = x264_coeff_last8_mmx2;
        pf-&gt;coeff_last[  DCT_LUMA_AC] = x264_coeff_last15_mmx2;
        pf-&gt;coeff_last[ DCT_LUMA_4x4] = x264_coeff_last16_mmx2;
        pf-&gt;coeff_last[ DCT_LUMA_8x8] = x264_coeff_last64_mmx2;
        pf-&gt;coeff_level_run8 = x264_coeff_level_run8_mmx2;
        pf-&gt;coeff_level_run[  DCT_LUMA_AC] = x264_coeff_level_run15_mmx2;
        pf-&gt;coeff_level_run[ DCT_LUMA_4x4] = x264_coeff_level_run16_mmx2;
#endif
        pf-&gt;coeff_last4 = x264_coeff_last4_mmx2;
        pf-&gt;coeff_level_run4 = x264_coeff_level_run4_mmx2;
        if( cpu&amp;X264_CPU_LZCNT )
            pf-&gt;coeff_level_run4 = x264_coeff_level_run4_mmx2_lzcnt;
    }
    //此处省略大量的X86、ARM等平台的汇编函数初始化代码
}
</pre><br />从源代码可以看出，x264_quant_init()初始化了一系列的量化相关的函数。它的输入参数x264_quant_function_t是一个结构体，其中包含了和量化相关各种函数指针。x264_quant_function_t的定义如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_14_4695224" name="code" class="cpp">typedef struct
{
    int (*quant_8x8)  ( dctcoef dct[64], udctcoef mf[64], udctcoef bias[64] );
    int (*quant_4x4)  ( dctcoef dct[16], udctcoef mf[16], udctcoef bias[16] );
    int (*quant_4x4x4)( dctcoef dct[4][16], udctcoef mf[16], udctcoef bias[16] );
    int (*quant_4x4_dc)( dctcoef dct[16], int mf, int bias );
    int (*quant_2x2_dc)( dctcoef dct[4], int mf, int bias );

    void (*dequant_8x8)( dctcoef dct[64], int dequant_mf[6][64], int i_qp );
    void (*dequant_4x4)( dctcoef dct[16], int dequant_mf[6][16], int i_qp );
    void (*dequant_4x4_dc)( dctcoef dct[16], int dequant_mf[6][16], int i_qp );

    void (*idct_dequant_2x4_dc)( dctcoef dct[8], dctcoef dct4x4[8][16], int dequant_mf[6][16], int i_qp );
    void (*idct_dequant_2x4_dconly)( dctcoef dct[8], int dequant_mf[6][16], int i_qp );

    int (*optimize_chroma_2x2_dc)( dctcoef dct[4], int dequant_mf );
    int (*optimize_chroma_2x4_dc)( dctcoef dct[8], int dequant_mf );

    void (*denoise_dct)( dctcoef *dct, uint32_t *sum, udctcoef *offset, int size );

    int (*decimate_score15)( dctcoef *dct );
    int (*decimate_score16)( dctcoef *dct );
    int (*decimate_score64)( dctcoef *dct );
    int (*coeff_last[14])( dctcoef *dct );
    int (*coeff_last4)( dctcoef *dct );
    int (*coeff_last8)( dctcoef *dct );
    int (*coeff_level_run[13])( dctcoef *dct, x264_run_level_t *runlevel );
    int (*coeff_level_run4)( dctcoef *dct, x264_run_level_t *runlevel );
    int (*coeff_level_run8)( dctcoef *dct, x264_run_level_t *runlevel );

#define TRELLIS_PARAMS const int *unquant_mf, const uint8_t *zigzag, int lambda2,\
                       int last_nnz, dctcoef *coefs, dctcoef *quant_coefs, dctcoef *dct,\
                       uint8_t *cabac_state_sig, uint8_t *cabac_state_last,\
                       uint64_t level_state0, uint16_t level_state1
    int (*trellis_cabac_4x4)( TRELLIS_PARAMS, int b_ac );
    int (*trellis_cabac_8x8)( TRELLIS_PARAMS, int b_interlaced );
    int (*trellis_cabac_4x4_psy)( TRELLIS_PARAMS, int b_ac, dctcoef *fenc_dct, int psy_trellis );
    int (*trellis_cabac_8x8_psy)( TRELLIS_PARAMS, int b_interlaced, dctcoef *fenc_dct, int psy_trellis );
    int (*trellis_cabac_dc)( TRELLIS_PARAMS, int num_coefs );
    int (*trellis_cabac_chroma_422_dc)( TRELLIS_PARAMS );
} x264_quant_function_t;
</pre><br />x264_quant_init ()的工作就是对x264_quant_function_t中的函数指针进行赋值。下文分析其中2个函数：4x4矩阵量化函数quant_4x4()，4个4x4矩阵量化函数quant_4x4x4()。<br /><br /><h3>quant_4x4()</h3>quant_4x4()用于对4x4的DCT残差矩阵进行量化。该函数的定义位于common\quant.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_15_1536430" name="code" class="cpp">//4x4量化
//输入输出都是dct[16]
static int quant_4x4( dctcoef dct[16], udctcoef mf[16], udctcoef bias[16] )
{
    int nz = 0;
    //循环16个元素
    for( int i = 0; i &lt; 16; i++ )
        QUANT_ONE( dct[i], mf[i], bias[i] );
    return !!nz;
}
</pre><br />可以看出quant_4x4()循环16次调用了QUANT_ONE()完成了量化工作。并且将DCT系数值，MF值，bias偏移值直接传递给了该宏。<br /><br /><h3>QUANT_ONE()</h3>QUANT_ONE()完成了一个DCT系数的量化工作，它的定义如下。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_16_5869381" name="code" class="cpp">//量化1个元素
#define QUANT_ONE( coef, mf, f ) \
{ \
    if( (coef) &gt; 0 ) \
        (coef) = (f + (coef)) * (mf) &gt;&gt; 16; \
    else \
        (coef) = - ((f - (coef)) * (mf) &gt;&gt; 16); \
    nz |= (coef); \
}</pre>从QUANT_ONE()的定义可以看出，它实现了上文提到的H.264标准中的量化公式。<br /><br /><h3>quant_4x4x4()</h3>quant_4x4x4()用于对4个4x4的DCT残差矩阵进行量化。该函数的定义位于common\quant.c，如下所示。<br /><pre code_snippet_id="673955" snippet_file_name="blog_20150524_17_7378433" name="code" class="cpp">//处理4个4x4量化
//输入输出都是dct[4][16]
static int quant_4x4x4( dctcoef dct[4][16], udctcoef mf[16], udctcoef bias[16] )
{
    int nza = 0;
    //处理4个
    for( int j = 0; j &lt; 4; j++ )
    {
        int nz = 0;
        //量化
        for( int i = 0; i &lt; 16; i++ )
            QUANT_ONE( dct[j][i], mf[i], bias[i] );
        nza |= (!!nz)&lt;&lt;j;
    }
    return nza;
}
</pre>从quant_4x4x4()的定义可以看出，该函数相当于调用了4次quant_4x4()函数。<br /><br /><br />至此有关x264中的宏块编码模块的源代码就分析完毕了。<br /><br /><br /><br /><br /><span style="color:#990000;"><strong>雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</strong></span><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/45938927		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=x264&t=blog" target="_blank">x264						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=DCT&t=blog" target="_blank">DCT						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=量化&t=blog" target="_blank">量化						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=残差&t=blog" target="_blank">残差						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=编码&t=blog" target="_blank">编码						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/2619503"  target="_blank">x264						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/osmedia.html" target="_blank">开源多媒体项目源代码分析</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45938927#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/50966924" target="_blank" strategy="BlogCommendFromGuangxin_0">
				<em>x264</em>代码剖析（十五）：核心算法之<em>宏块</em><em>编码</em>中的变换<em>编码</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/50966924" target="_blank" >
				<em>x264</em>代码剖析（十五）：核心算法之<em>宏块</em><em>编码</em>中的变换<em>编码</em>
 
        为了进一步节省图像的传输码率，需要对图像进行压缩，通常采用变换<em>编码</em>及量化来消除图像中的相关性以减少图像<em>编码</em>的动态范围。...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/FRD2009041510" title="FRD2009041510" target="_blank">
					<img src="https://avatar.csdn.net/6/9/9/3_frd2009041510.jpg" alt="FRD2009041510" class="avatar-pic">
					<span class="name">FRD2009041510</span>
				</a>
			</p>
			<p>
				<span class="date">2016-03-23 21:58:35</span>
			</p>
			<p>
				<span class="read-num">阅读数：1682</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367" target="_blank" strategy="BlogCommendFromGuangxin_1">
				<em>x264</em><em>源代码</em><em>简单</em><em>分析</em>：<em>编码</em>器主干<em>部分</em>-1			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367" target="_blank" >
				本文<em>分析</em><em>x264</em><em>编码</em>器主干<em>部分</em>的<em>源代码</em>。“主干<em>部分</em>”指的就是lib<em>x264</em>中最核心的接口函数——<em>x264</em>_<em>encode</em>r_<em>encode</em>()，以及相关的几个接口函数<em>x264</em>_<em>encode</em>r_open()...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-05-11 17:10:51</span>
			</p>
			<p>
				<span class="read-num">阅读数：12776</span>
			</p>
		</div>
	</div>
								<!-- 第四范式广告开关 -->
<script>window.p4sdk_enable_recommendBox=true</script>
			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/ricky90/article/details/79436422" target="_blank" strategy="BlogCommendFromGuangxin_2">
				从ffmpeg中抓取mv/mb_type/dct_coeff/qp和MBSize等数据（H.264）			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/ricky90/article/details/79436422" target="_blank" >
				    ffmpeg是一个很复杂的库，在我看来，比JM要复杂很多，刨除其包含各种编解码方案，算法的全面性，以及其各种平台的汇编优化等因素，其运行逻辑结构和函数之间的调用关系等都要复杂很多。今天我们不泛...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/ricky90" title="ricky90" target="_blank">
					<img src="https://avatar.csdn.net/7/3/7/3_ricky90.jpg" alt="ricky90" class="avatar-pic">
					<span class="name">ricky90</span>
				</a>
			</p>
			<p>
				<span class="date">2018-05-05 10:52:04</span>
			</p>
			<p>
				<span class="read-num">阅读数：176</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/Blaze_boy/article/details/50118333" target="_blank" strategy="BlogCommendFromGuangxin_3">
				DCT<em>编码</em>原理<em>分析</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/Blaze_boy/article/details/50118333" target="_blank" >
				二维DCT变换

2012年11月30日 分类：学习笔记<em>x264</em>图像处理



目录

1.一维DCT变换2.二维DCT变换3.二维DCT反变换4.整数DCT变换

写这篇文章的目...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/Blaze_boy" title="Blaze_boy" target="_blank">
					<img src="https://avatar.csdn.net/5/4/A/3_blaze_boy.jpg" alt="Blaze_boy" class="avatar-pic">
					<span class="name">Blaze_boy</span>
				</a>
			</p>
			<p>
				<span class="date">2015-11-30 20:37:03</span>
			</p>
			<p>
				<span class="read-num">阅读数：3108</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/tigertandengtai/article/details/70143171" target="_blank" strategy="BlogCommendFromGuangxin_4">
				实验三  基于DCT<em>编码</em>的JPEG压缩			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/tigertandengtai/article/details/70143171" target="_blank" >
				基于DCT<em>编码</em>的JPEG压缩			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/tigertandengtai" title="tigertandengtai" target="_blank">
					<img src="https://avatar.csdn.net/C/9/3/3_tigertandengtai.jpg" alt="tigertandengtai" class="avatar-pic">
					<span class="name">tigertandengtai</span>
				</a>
			</p>
			<p>
				<span class="date">2017-04-12 15:27:32</span>
			</p>
			<p>
				<span class="read-num">阅读数：907</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45917757" target="_blank" strategy="BlogCommendFromBaidu_5">
				<em>x264</em><em>源代码</em><em>简单</em><em>分析</em>：<em>宏块</em><em>分析</em>（Analysis）<em>部分</em>-帧内<em>宏块</em>（Intra）			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45917757" target="_blank" >
				本文记录<em>x264</em>的 <em>x264</em>_slice_write()函数中调用的<em>x264</em>_macroblock_analyse()的<em>源代码</em>。<em>x264</em>_macroblock_analyse()对应着<em>x264</em>中的<em>分析</em>...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-05-22 16:08:02</span>
			</p>
			<p>
				<span class="read-num">阅读数：9527</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/shaqoneal/article/details/53959053" target="_blank" strategy="BlogCommendFromBaidu_6">
				【H.264/AVC视频编解码技术详解】十二、解析H.264码流的<em>宏块</em>结构（下）：H.264帧内<em>编码</em><em>宏块</em>的预测结构			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/shaqoneal/article/details/53959053" target="_blank" >
				《H.264/AVC视频编解码技术详解》视频教程已经在“CSDN学院”上线，视频中详述了H.264的背景、标准协议和实现，并通过一个实战工程的形式对H.264的标准进行解析和实现，欢迎观看！“纸上得来...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/shaqoneal" title="shaqoneal" target="_blank">
					<img src="https://avatar.csdn.net/C/5/8/3_shaqoneal.jpg" alt="shaqoneal" class="avatar-pic">
					<span class="name">shaqoneal</span>
				</a>
			</p>
			<p>
				<span class="date">2016-12-31 23:28:49</span>
			</p>
			<p>
				<span class="read-num">阅读数：1673</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/u011867581/article/details/44217645" target="_blank" strategy="BlogCommendFromBaidu_7">
				Skip<em>宏块</em>与Direct预测模式浅析			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/u011867581/article/details/44217645" target="_blank" >
				原文转自：http://bbs.chinavideo.org/forum.php?mod=viewthread&amp;tid=994
B_Skip类型<em>宏块</em>（200503版标准，表7-14最后一行）：   ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/u011867581" title="u011867581" target="_blank">
					<img src="https://avatar.csdn.net/4/A/9/3_u011867581.jpg" alt="u011867581" class="avatar-pic">
					<span class="name">u011867581</span>
				</a>
			</p>
			<p>
				<span class="date">2015-03-12 09:46:34</span>
			</p>
			<p>
				<span class="read-num">阅读数：514</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/dssxk/article/details/51853460" target="_blank" strategy="BlogCommendFromBaidu_8">
				<em>x264</em><em>编码</em>详细文字全过程			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/dssxk/article/details/51853460" target="_blank" >
				<em>x264</em><em>编码</em>详细文字全过程

（1）       <em>x264</em>_param_default( <em>x264</em>_param_t *param ) 

作用： 对<em>编码</em>器进行参数设定

cqm:量化表相关信息

  ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/dssxk" title="dssxk" target="_blank">
					<img src="https://avatar.csdn.net/A/D/B/3_dssxk.jpg" alt="dssxk" class="avatar-pic">
					<span class="name">dssxk</span>
				</a>
			</p>
			<p>
				<span class="date">2016-07-07 18:33:31</span>
			</p>
			<p>
				<span class="read-num">阅读数：2488</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/chenchong_219/article/details/37996385" target="_blank" strategy="BlogCommendFromBaidu_9">
				<em>X264</em><em>编码</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/chenchong_219/article/details/37996385" target="_blank" >
				前面讲到了关于NAL打包成RTP后进行发送，那么这些NAL应该怎么得到呢？当然如果有现成的H264数据就可以直接用了，但是一般我们的摄像头采集的数据都不是H264格式的，那就需要<em>编码</em>。而且在我们这个项...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/chenchong_219" title="chenchong_219" target="_blank">
					<img src="https://avatar.csdn.net/0/E/3/3_chenchong_219.jpg" alt="chenchong_219" class="avatar-pic">
					<span class="name">chenchong_219</span>
				</a>
			</p>
			<p>
				<span class="date">2014-07-20 20:45:38</span>
			</p>
			<p>
				<span class="read-num">阅读数：9806</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45938927" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421166">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>5</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "x264源代码简单分析：宏块编码（Encode）部分";
    var ChannelId = 16;
    var articleId = "45938927";
    var commentscount = 2;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/45938927";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "libx264+%E5%9C%BA%E7%BC%96%E7%A0%81";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"x264源代码简单分析：宏块编码（Encode）部分");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=libx264+%E5%9C%BA%E7%BC%96%E7%A0%81"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>