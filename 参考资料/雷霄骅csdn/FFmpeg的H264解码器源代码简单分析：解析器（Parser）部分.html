<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/45001033"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文继续分析FFmpeg中libavcodec的H.264解码器（H.264 Decoder）。上篇文章概述了FFmpeg中H.264解码器的结构；从这篇文章开始，具体研究H.264解码器的源代码。本文分析H.264解码器中解析器（Parser）部分的源代码。这部分的代码用于分割H.264的NALU，并且解析SPS、PPS、SEI等信息。解析H.264码流（对应AVCodecParser结构体中的函数）和解码H.264码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。" />
    <meta name="keywords" content="FFmpeg,H.264" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分 - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45001033"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年04月12日 00:37:12</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：38195</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p><span style="white-space:pre;"></span></p><p>=====================================================</p><p>H.264源代码分析文章列表：</p><p>【编码 - x264】</p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45536607">x264源代码简单分析：概述</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45583217">x264源代码简单分析：x264命令行工具（x264.exe）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45644367">x264源代码简单分析：编码器主干部分-1</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45719905">x264源代码简单分析：编码器主干部分-2</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45790195">x264源代码简单分析：x264_slice_write()</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45870269">x264源代码简单分析：滤波（Filter）部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45917757">x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45936267">x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45938927">x264源代码简单分析：宏块编码（Encode）部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45944811">x264源代码简单分析：熵编码（Entropy Encoding）部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45960409">FFmpeg与libx264接口源代码简单分析</a></p><p>【解码 - libavcodec H.264 解码器】</p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">FFmpeg的H.264解码器源代码简单分析：概述</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45001033">FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45042755">FFmpeg的H.264解码器源代码简单分析：解码器主干部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45114453">FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45143075">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45195291">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/45224579">FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分</a></p><p>=====================================================</p><br /><p><span style="white-space:pre;">	</span>本文继续分析FFmpeg中libavcodec的H.264解码器（H.264 Decoder）。上篇文章概述了FFmpeg中H.264解码器的结构；从这篇文章开始，具体研究H.264解码器的源代码。本文分析H.264解码器中解析器（Parser）部分的源代码。这部分的代码用于分割H.264的NALU，并且解析SPS、PPS、SEI等信息。解析H.264码流（对应AVCodecParser结构体中的函数）和解码H.264码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。</p><br /><h2>函数调用关系图</h2><p>解析器（Parser）部分的源代码在整个H.264解码器中的位置如下图所示。</p><p style="text-align:center;"><a href="http://img.my.csdn.net/uploads/201504/04/1428080288_9350.jpg"><img src="https://img-blog.csdn.net/20150412001008013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></a><br /></p><p style="text-align:center;"><a href="https://my.csdn.net/leixiaohua1020/album/detail/1806347">单击查看更清晰的图片</a></p><p style="text-align:center;"><br /></p><p>解析器（Parser）部分的源代码的调用关系如下图所示。</p><p style="text-align:center;"><a href="http://img.my.csdn.net/uploads/201504/12/1428770475_6759.jpg"><img src="https://img-blog.csdn.net/20150412001238526" alt="" /></a><br /></p><p style="text-align:center;"><a href="https://my.csdn.net/leixiaohua1020/album/detail/1806771">单击查看更清晰的图片</a><br /></p>从图中可以看出，H.264的解析器（Parser）在解析数据的时候调用h264_parse()，h264_parse()调用了parse_nal_units()，parse_nal_units()则调用了一系列解析特定NALU的函数。H.264的解码器（Decoder）在解码数据的时候调用h264_decode_frame()，h264_decode_frame()调用了decode_nal_units()，decode_nal_units()也同样调用了一系列解析不同NALU的函数。<br />图中简单列举了几个解析特定NALU的函数：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">ff_h264_decode_nal()：解析NALU Header<br />ff_h264_decode_seq_parameter_set()：解析SPS<br />ff_h264_decode_picture_parameter_set()：解析PPS<br />ff_h264_decode_sei()：解析SEI</blockquote>H.264解码器与H.264解析器最主要的不同的地方在于它调用了ff_h264_execute_decode_slices()函数进行了解码工作。这篇文章只分析H.264解析器的源代码，至于H.264解码器的源代码，则在后面几篇文章中再进行分析。<br /><br /><h2>ff_h264_decoder</h2>ff_h264_decoder是FFmpeg的H.264解码器对应的AVCodec结构体。它的定义位于libavcodec\h264.c，如下所示。<br /><pre class="cpp">AVCodec ff_h264_decoder = {
    .name                  = "h264",
    .long_name             = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_H264,
    .priv_data_size        = sizeof(H264Context),
    .init                  = ff_h264_decode_init,
    .close                 = h264_decode_end,
    .decode                = h264_decode_frame,
    .capabilities          = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 |
                             CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS |
                             CODEC_CAP_FRAME_THREADS,
    .flush                 = flush_dpb,
    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),
    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),
    .profiles              = NULL_IF_CONFIG_SMALL(profiles),
    .priv_class            = &amp;h264_class,
};</pre><br />从ff_h264_decoder的定义可以看出：解码器初始化的函数指针init()指向ff_h264_decode_init()函数，解码的函数指针decode()指向h264_decode_frame()函数，解码器关闭的函数指针close()指向h264_decode_end()函数。<br />有关H.264解码器这方面的源代码在以后的文章中再进行详细的分析。在这里我们只需要知道h264_decode_frame()内部调用了decode_nal_units()，而decode_nal_units()调用了和H.264解析器（Parser）有关的源代码就可以了。<br /><br /><h2>ff_h264_parser</h2>ff_h264_parser是FFmpeg的H.264解析器对应的AVCodecParser结构体。它的定义位于libavcodec\h264_parser.c，如下所示。<br /><pre class="cpp">AVCodecParser ff_h264_parser = {
    .codec_ids      = { AV_CODEC_ID_H264 },
    .priv_data_size = sizeof(H264Context),
    .parser_init    = init,
    .parser_parse   = h264_parse,
    .parser_close   = close,
    .split          = h264_split,
};</pre><br />从ff_h264_parser的定义可以看出：AVCodecParser初始化的函数指针parser_init()指向init()函数；解析数据的函数指针parser_parse()指向h264_parse()函数；销毁的函数指针parser_close()指向close()函数。下面分别看看这些函数。<br /><br /><h2>init() [对应于AVCodecParser-&gt; parser_init()]</h2>ff_h264_parser结构体中AVCodecParser的parser_init()指向init()函数。该函数完成了AVCodecParser的初始化工作。函数的定义很简单，如下所示。<br /><pre class="cpp">static av_cold int init(AVCodecParserContext *s)
{
    H264Context *h = s-&gt;priv_data;
    h-&gt;thread_context[0]   = h;
    h-&gt;slice_context_count = 1;
    ff_h264dsp_init(&amp;h-&gt;h264dsp, 8, 1);
    return 0;
}</pre><br /><h2>close() [对应于AVCodecParser-&gt; parser_close()]</h2>ff_h264_parser结构体中AVCodecParser的parser_close()指向close()函数。该函数完成了AVCodecParser的关闭工作。函数的定义也比较简单，如下所示。<br /><pre class="cpp">static void close(AVCodecParserContext *s)
{
    H264Context *h   = s-&gt;priv_data;
    ParseContext *pc = &amp;h-&gt;parse_context;

    av_freep(&amp;pc-&gt;buffer);
    ff_h264_free_context(h);
}</pre><br /><h2>h264_parse() [对应于AVCodecParser-&gt; parser_parse()]</h2>ff_h264_parser结构体中AVCodecParser的parser_parse()指向h264_parse()函数。该函数完成了AVCodecParser的解析工作（在这里就是H.264码流的解析工作）。h264_parse()的定义位于libavcodec\h264_parser.c，如下所示。<br /><pre class="cpp">//解析H.264码流
//输出一个完整的NAL，存储于poutbuf中
static int h264_parse(AVCodecParserContext *s,
                      AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    H264Context *h   = s-&gt;priv_data;
    ParseContext *pc = &amp;h-&gt;parse_context;
    int next;
    //如果还没有解析过1帧，就调用这里解析extradata
    if (!h-&gt;got_first) {
        h-&gt;got_first = 1;
        if (avctx-&gt;extradata_size) {
            h-&gt;avctx = avctx;
            // must be done like in decoder, otherwise opening the parser,
            // letting it create extradata and then closing and opening again
            // will cause has_b_frames to be always set.
            // Note that estimate_timings_from_pts does exactly this.
            if (!avctx-&gt;has_b_frames)
                h-&gt;low_delay = 1;
            //解析AVCodecContext的extradata
            ff_h264_decode_extradata(h, avctx-&gt;extradata, avctx-&gt;extradata_size);
        }
    }
    //输入的数据是完整的一帧？
    //这里通过设置flags的PARSER_FLAG_COMPLETE_FRAMES来确定
    if (s-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) {
    	//和缓存大小一样
        next = buf_size;
    } else {
    	//查找帧结尾（帧开始）位置
    	//以“起始码”为依据（0x000001或0x00000001）
        next = h264_find_frame_end(h, buf, buf_size);
        //组帧
        if (ff_combine_frame(pc, next, &amp;buf, &amp;buf_size) &lt; 0) {
            *poutbuf      = NULL;
            *poutbuf_size = 0;
            return buf_size;
        }

        if (next &lt; 0 &amp;&amp; next != END_NOT_FOUND) {
            av_assert1(pc-&gt;last_index + next &gt;= 0);
            h264_find_frame_end(h, &amp;pc-&gt;buffer[pc-&gt;last_index + next], -next); // update state
        }
    }
    //解析NALU，从SPS、PPS、SEI等中获得一些基本信息。
    //此时buf中存储的是完整的1帧数据
    parse_nal_units(s, avctx, buf, buf_size);

    if (avctx-&gt;framerate.num)
        avctx-&gt;time_base = av_inv_q(av_mul_q(avctx-&gt;framerate, (AVRational){avctx-&gt;ticks_per_frame, 1}));
    if (h-&gt;sei_cpb_removal_delay &gt;= 0) {
        s-&gt;dts_sync_point    = h-&gt;sei_buffering_period_present;
        s-&gt;dts_ref_dts_delta = h-&gt;sei_cpb_removal_delay;
        s-&gt;pts_dts_delta     = h-&gt;sei_dpb_output_delay;
    } else {
        s-&gt;dts_sync_point    = INT_MIN;
        s-&gt;dts_ref_dts_delta = INT_MIN;
        s-&gt;pts_dts_delta     = INT_MIN;
    }

    if (s-&gt;flags &amp; PARSER_FLAG_ONCE) {
        s-&gt;flags &amp;= PARSER_FLAG_COMPLETE_FRAMES;
    }
    //分割后的帧数据输出至poutbuf
    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return next;
}
</pre><br />从源代码可以看出，h264_parse()主要完成了以下3步工作：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">（1）如果是第一次解析，则首先调用ff_h264_decode_extradata()解析AVCodecContext的extradata（里面实际上存储了H.264的SPS、PPS）。<br />（2）如果传入的flags 中包含PARSER_FLAG_COMPLETE_FRAMES，则说明传入的是完整的一帧数据，不作任何处理；如果不包含PARSER_FLAG_COMPLETE_FRAMES，则说明传入的不是完整的一帧数据而是任意一段H.264数据，则需要调用h264_find_frame_end()通过查找“起始码”（0x00000001或者0x000001）的方法，分离出完整的一帧数据。<br /><p>（3）调用parse_nal_units()完成了NALU的解析工作。</p></blockquote>下面分别看一下这3步中涉及到的函数：ff_h264_decode_extradata()，h264_find_frame_end()，parse_nal_units()。<br /><br /><h2>ff_h264_decode_extradata()</h2>ff_h264_decode_extradata()用于解析AVCodecContext的extradata（里面实际上存储了H.264的SPS、PPS）。ff_h264_decode_extradata()的定义如下所示。<br /><pre class="cpp">//解析extradata
//最常见的就是解析AVCodecContext的extradata。其中extradata实际上存储的就是SPS、PPS
int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)
{
    AVCodecContext *avctx = h-&gt;avctx;
    int ret;

    if (!buf || size &lt;= 0)
        return -1;

    if (buf[0] == 1) {
        int i, cnt, nalsize;
        const unsigned char *p = buf;

        //AVC1 描述:H.264 bitstream without start codes.是不带起始码0×00000001的。MKV/MOV/FLV中的H.264属于这种类型
        //H264 描述:H.264 bitstream with start codes.是带有起始码0×00000001的。MPEGTS中的H.264，或者H.264裸流属于这种类型
        h-&gt;is_avc = 1;
        //数据量太小
        //随意测了一个视频
        //SPS: 30 Byte
        //PPS: 6 Byte
        if (size &lt; 7) {
            av_log(avctx, AV_LOG_ERROR,
                   "avcC %d too short\n", size);
            return AVERROR_INVALIDDATA;
        }
        /* sps and pps in the avcC always have length coded with 2 bytes,
         * so put a fake nal_length_size = 2 while parsing them */
        h-&gt;nal_length_size = 2;
        // Decode sps from avcC
        //解码SPS
        cnt = *(p + 5) &amp; 0x1f; // Number of sps
        p  += 6;
        for (i = 0; i &lt; cnt; i++) {
            nalsize = AV_RB16(p) + 2;
            if(nalsize &gt; size - (p-buf))
                return AVERROR_INVALIDDATA;
            //解析
            ret = decode_nal_units(h, p, nalsize, 1);
            if (ret &lt; 0) {
                av_log(avctx, AV_LOG_ERROR,
                       "Decoding sps %d from avcC failed\n", i);
                return ret;
            }
            p += nalsize;
        }
        // Decode pps from avcC
        //解码PPS
        cnt = *(p++); // Number of pps
        for (i = 0; i &lt; cnt; i++) {
            nalsize = AV_RB16(p) + 2;
            if(nalsize &gt; size - (p-buf))
                return AVERROR_INVALIDDATA;
            ret = decode_nal_units(h, p, nalsize, 1);
            if (ret &lt; 0) {
                av_log(avctx, AV_LOG_ERROR,
                       "Decoding pps %d from avcC failed\n", i);
                return ret;
            }
            p += nalsize;
        }
        // Store right nal length size that will be used to parse all other nals
        h-&gt;nal_length_size = (buf[4] &amp; 0x03) + 1;
    } else {
        h-&gt;is_avc = 0;
        //解析
        ret = decode_nal_units(h, buf, size, 1);
        if (ret &lt; 0)
            return ret;
    }
    return size;
}
</pre><br />从源代码中可以看出，ff_h264_decode_extradata()调用decode_nal_units()解析SPS、PPS信息。有关decode_nal_units()的源代码在后续文章中再进行分析。<br /><br /><h2>h264_find_frame_end()</h2>h264_find_frame_end()用于查找H.264码流中的“起始码”（start code）。在H.264码流中有两种起始码：0x000001和0x00000001。其中4Byte的长度的起始码最为常见。只有当一个完整的帧被编为多个slice的时候，包含这些slice的NALU才会使用3Byte的起始码。h264_find_frame_end()的定义位于libavcodec\h264_parser.c，如下所示。<br /><pre class="cpp">//查找帧结尾（帧开始）位置
//
//几种状态state：
//2 - 找到1个0
//1 - 找到2个0
//0 - 找到大于等于3个0
//4 - 找到2个0和1个1，即001（即找到了起始码）
//5 - 找到至少3个0和1个1，即0001等等（即找到了起始码）
//7 - 初始化状态
//&gt;=8 - 找到2个Slice Header
//
//关于起始码startcode的两种形式：3字节的0x000001和4字节的0x00000001
//3字节的0x000001只有一种场合下使用，就是一个完整的帧被编为多个slice的时候，
//包含这些slice的nalu使用3字节起始码。其余场合都是4字节的。
//
static int h264_find_frame_end(H264Context *h, const uint8_t *buf,
                               int buf_size)
{
    int i, j;
    uint32_t state;
    ParseContext *pc = &amp;h-&gt;parse_context;
    int next_avc= h-&gt;is_avc ? 0 : buf_size;

//    mb_addr= pc-&gt;mb_addr - 1;
    state = pc-&gt;state;
    if (state &gt; 13)
        state = 7;

    if (h-&gt;is_avc &amp;&amp; !h-&gt;nal_length_size)
        av_log(h-&gt;avctx, AV_LOG_ERROR, "AVC-parser: nal length size invalid\n");
    //
    //每次循环前进1个字节，读取该字节的值
    //根据此前的状态state做不同的处理
    //state取值为4,5代表找到了起始码
    //类似于一个状态机，简单画一下状态转移图：
    //                            +-----+
    //                            |     |
    //                            v     |
    // 7--(0)--&gt;2--(0)--&gt;1--(0)--&gt;0-(0)-+
    // ^        |        |        |
    // |       (1)      (1)      (1)
    // |        |        |        |
    // +--------+        v        v
    //                   4        5
    //
    for (i = 0; i &lt; buf_size; i++) {
    	//超过了
        if (i &gt;= next_avc) {
            int nalsize = 0;
            i = next_avc;
            for (j = 0; j &lt; h-&gt;nal_length_size; j++)
                nalsize = (nalsize &lt;&lt; 8) | buf[i++];
            if (nalsize &lt;= 0 || nalsize &gt; buf_size - i) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "AVC-parser: nal size %d remaining %d\n", nalsize, buf_size - i);
                return buf_size;
            }
            next_avc = i + nalsize;
            state    = 5;
        }
        //初始state为7
        if (state == 7) {
        	//查找startcode的候选者？
        	//从一段内存中查找取值为0的元素的位置并返回
        	//增加i取值
            i += h-&gt;h264dsp.startcode_find_candidate(buf + i, next_avc - i);
            //因为找到1个0，状态转换为2
            if (i &lt; next_avc)
                state = 2;
        } else if (state &lt;= 2) {       //找到0时候的state。包括1个0（状态2），2个0（状态1），或者3个及3个以上0（状态0）。
            if (buf[i] == 1)           //发现了一个1
                state ^= 5;            //状态转换关系：2-&gt;7, 1-&gt;4, 0-&gt;5。状态4代表找到了001，状态5代表找到了0001
            else if (buf[i])
                state = 7;             //恢复初始
            else                       //发现了一个0
                state &gt;&gt;= 1;           // 2-&gt;1, 1-&gt;0, 0-&gt;0
        } else if (state &lt;= 5) {
        	//状态4代表找到了001，状态5代表找到了0001
        	//获取NALU类型
        	//NALU Header（1Byte）的后5bit
            int nalu_type = buf[i] &amp; 0x1F;

            if (nalu_type == NAL_SEI || nalu_type == NAL_SPS ||
                nalu_type == NAL_PPS || nalu_type == NAL_AUD) {
                //SPS，PPS，SEI类型的NALU
                if (pc-&gt;frame_start_found) {    //如果之前已找到了帧头
                    i++;
                    goto found;
                }
            } else if (nalu_type == NAL_SLICE || nalu_type == NAL_DPA ||
                       nalu_type == NAL_IDR_SLICE) {
            	//表示有slice header的NALU
            	//大于等于8的状态表示找到了两个帧头，但没有找到帧尾的状态
                state += 8;
                continue;
            }
            //上述两个条件都不满足，回归初始状态（state取值7）
            state = 7;
        } else {
            h-&gt;parse_history[h-&gt;parse_history_count++]= buf[i];
            if (h-&gt;parse_history_count&gt;5) {
                unsigned int mb, last_mb= h-&gt;parse_last_mb;
                GetBitContext gb;

                init_get_bits(&amp;gb, h-&gt;parse_history, 8*h-&gt;parse_history_count);
                h-&gt;parse_history_count=0;
                mb= get_ue_golomb_long(&amp;gb);
                h-&gt;parse_last_mb= mb;
                if (pc-&gt;frame_start_found) {
                    if (mb &lt;= last_mb)
                        goto found;
                } else
                    pc-&gt;frame_start_found = 1;
                state = 7;
            }
        }
    }
    pc-&gt;state = state;
    if (h-&gt;is_avc)
        return next_avc;
    //没找到
    return END_NOT_FOUND;

found:
    pc-&gt;state             = 7;
    pc-&gt;frame_start_found = 0;
    if (h-&gt;is_avc)
        return next_avc;
    //state=4时候，state &amp; 5=4
    //找到的是001（长度为3），i减小3+1=4，标识帧结尾
    //state=5时候，state &amp; 5=5
    //找到的是0001（长度为4），i减小4+1=5，标识帧结尾
    return i - (state &amp; 5) - 5 * (state &gt; 7);
}
</pre><br />从源代码可以看出，h264_find_frame_end()使用了一种类似于状态机的方式查找起始码。函数中的for()循环每执行一遍，状态机的状态就会改变一次。该状态机主要包含以下几种状态：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">7 - 初始化状态<br />2 - 找到1个0<br />1 - 找到2个0<br />0 - 找到大于等于3个0<br />4 - 找到2个0和1个1，即001（即找到了起始码）<br />5 - 找到至少3个0和1个1，即0001等等（即找到了起始码）<br />&gt;=8 - 找到2个Slice Header</blockquote><p>这些状态之间的状态转移图如下所示。图中粉红色代表初始状态，绿色代表找到“起始码”的状态。</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20150412002408621" alt="" /><br /></p><p><span style="white-space:pre;">	</span>如图所示，h264_find_frame_end()初始化时候位于状态“7”；当找到1个“0”之后，状态从“7”变为“2”；在状态“2”下，如果再次找到1个“0”，则状态变为“1”；在状态“1”下，如果找到“1”，则状态变换为“4”，表明找到了“0x000001”起始码；在状态“1”下，如果找到“0”，则状态变换为“0”；在状态“0”下，如果找到“1”，则状态变换为“5” ，表明找到了“0x000001”起始码。</p><p><br /></p><strong>startcode_find_candidate()</strong><br /><span style="white-space:pre;">	</span>其中，在查找数据中第1个“0”的时候，使用了H264DSPContext结构体中的startcode_find_candidate()函数。startcode_find_candidate()除了包含C语言版本的函数外，还包含了ARMV6等平台下经过汇编优化的函数（估计效率会比C语言版本函数高一些）。C语言版本的函数ff_startcode_find_candidate_c()的定义很简单，位于libavcodec\startcode.c，如下所示。<br /><pre class="cpp">int ff_startcode_find_candidate_c(const uint8_t *buf, int size)
{
    int i = 0;
    for (; i &lt; size; i++)
        if (!buf[i])
            break;
    return i;
}</pre><br /><h2>parse_nal_units()</h2>parse_nal_units()用于解析NALU，从SPS、PPS、SEI等中获得一些基本信息。在该函数中，根据NALU的不同，分别调用不同的函数进行具体的处理。parse_nal_units()的定义位于libavcodec\h264_parser.c，如下所示。<br /><pre class="cpp">/**
 * Parse NAL units of found picture and decode some basic information.
 *
 * @param s parser context.
 * @param avctx codec context.
 * @param buf buffer with field/frame data.
 * @param buf_size size of the buffer.
 */
//解析NALU，从SPS、PPS、SEI等中获得一些基本信息。
static inline int parse_nal_units(AVCodecParserContext *s,
                                  AVCodecContext *avctx,
                                  const uint8_t * const buf, int buf_size)
{
    H264Context *h         = s-&gt;priv_data;
    int buf_index, next_avc;
    unsigned int pps_id;
    unsigned int slice_type;
    int state = -1, got_reset = 0;
    const uint8_t *ptr;
    int q264 = buf_size &gt;=4 &amp;&amp; !memcmp("Q264", buf, 4);
    int field_poc[2];

    /* set some sane default values */
    s-&gt;pict_type         = AV_PICTURE_TYPE_I;
    s-&gt;key_frame         = 0;
    s-&gt;picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;

    h-&gt;avctx = avctx;
    ff_h264_reset_sei(h);
    h-&gt;sei_fpa.frame_packing_arrangement_cancel_flag = -1;

    if (!buf_size)
        return 0;

    buf_index     = 0;
    next_avc      = h-&gt;is_avc ? 0 : buf_size;
    for (;;) {
        int src_length, dst_length, consumed, nalsize = 0;

        if (buf_index &gt;= next_avc) {
            nalsize = get_avc_nalsize(h, buf, buf_size, &amp;buf_index);
            if (nalsize &lt; 0)
                break;
            next_avc = buf_index + nalsize;
        } else {
            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);
            if (buf_index &gt;= buf_size)
                break;
            if (buf_index &gt;= next_avc)
                continue;
        }
        src_length = next_avc - buf_index;
        //NALU Header (1 Byte)
        state = buf[buf_index];
        switch (state &amp; 0x1f) {
        case NAL_SLICE:
        case NAL_IDR_SLICE:
            // Do not walk the whole buffer just to decode slice header
            if ((state &amp; 0x1f) == NAL_IDR_SLICE || ((state &gt;&gt; 5) &amp; 0x3) == 0) {
                /* IDR or disposable slice
                 * No need to decode many bytes because MMCOs shall not be present. */
                if (src_length &gt; 60)
                    src_length = 60;
            } else {
                /* To decode up to MMCOs */
                if (src_length &gt; 1000)
                    src_length = 1000;
            }
            break;
        }
        //解析NAL Header，获得nal_unit_type等信息
        ptr = ff_h264_decode_nal(h, buf + buf_index, &amp;dst_length,
                                 &amp;consumed, src_length);
        if (!ptr || dst_length &lt; 0)
            break;

        buf_index += consumed;
        //初始化GetBitContext
        //H264Context-&gt;gb
        //后面的解析都是从这里获取数据
        init_get_bits(&amp;h-&gt;gb, ptr, 8 * dst_length);
        switch (h-&gt;nal_unit_type) {
        case NAL_SPS:
        	//解析SPS
            ff_h264_decode_seq_parameter_set(h);
            break;
        case NAL_PPS:
        	//解析PPS
            ff_h264_decode_picture_parameter_set(h, h-&gt;gb.size_in_bits);
            break;
        case NAL_SEI:
        	//解析SEI
            ff_h264_decode_sei(h);
            break;
        case NAL_IDR_SLICE:
        	//如果是IDR Slice
        	//赋值AVCodecParserContext的key_frame为1
            s-&gt;key_frame = 1;

            h-&gt;prev_frame_num        = 0;
            h-&gt;prev_frame_num_offset = 0;
            h-&gt;prev_poc_msb          =
            h-&gt;prev_poc_lsb          = 0;
        /* fall through */
        case NAL_SLICE:
        	//获取Slice的一些信息
        	//跳过first_mb_in_slice这一字段
            get_ue_golomb_long(&amp;h-&gt;gb);  // skip first_mb_in_slice
            //获取帧类型（I,B,P）
            slice_type   = get_ue_golomb_31(&amp;h-&gt;gb);
            //赋值到AVCodecParserContext的pict_type（外部可以访问到）
            s-&gt;pict_type = golomb_to_pict_type[slice_type % 5];
            //关键帧
            if (h-&gt;sei_recovery_frame_cnt &gt;= 0) {
                /* key frame, since recovery_frame_cnt is set */
            	//赋值AVCodecParserContext的key_frame为1
                s-&gt;key_frame = 1;
            }
            //获取 PPS ID
            pps_id = get_ue_golomb(&amp;h-&gt;gb);
            if (pps_id &gt;= MAX_PPS_COUNT) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       "pps_id %u out of range\n", pps_id);
                return -1;
            }
            if (!h-&gt;pps_buffers[pps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       "non-existing PPS %u referenced\n", pps_id);
                return -1;
            }
            h-&gt;pps = *h-&gt;pps_buffers[pps_id];
            if (!h-&gt;sps_buffers[h-&gt;pps.sps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       "non-existing SPS %u referenced\n", h-&gt;pps.sps_id);
                return -1;
            }
            h-&gt;sps       = *h-&gt;sps_buffers[h-&gt;pps.sps_id];
            h-&gt;frame_num = get_bits(&amp;h-&gt;gb, h-&gt;sps.log2_max_frame_num);

            if(h-&gt;sps.ref_frame_count &lt;= 1 &amp;&amp; h-&gt;pps.ref_count[0] &lt;= 1 &amp;&amp; s-&gt;pict_type == AV_PICTURE_TYPE_I)
                s-&gt;key_frame = 1;
            //获得“型”和“级”
            //赋值到AVCodecContext的profile和level
            avctx-&gt;profile = ff_h264_get_profile(&amp;h-&gt;sps);
            avctx-&gt;level   = h-&gt;sps.level_idc;

            if (h-&gt;sps.frame_mbs_only_flag) {
                h-&gt;picture_structure = PICT_FRAME;
            } else {
                if (get_bits1(&amp;h-&gt;gb)) { // field_pic_flag
                    h-&gt;picture_structure = PICT_TOP_FIELD + get_bits1(&amp;h-&gt;gb); // bottom_field_flag
                } else {
                    h-&gt;picture_structure = PICT_FRAME;
                }
            }

            if (h-&gt;nal_unit_type == NAL_IDR_SLICE)
                get_ue_golomb(&amp;h-&gt;gb); /* idr_pic_id */
            if (h-&gt;sps.poc_type == 0) {
                h-&gt;poc_lsb = get_bits(&amp;h-&gt;gb, h-&gt;sps.log2_max_poc_lsb);

                if (h-&gt;pps.pic_order_present == 1 &amp;&amp;
                    h-&gt;picture_structure == PICT_FRAME)
                    h-&gt;delta_poc_bottom = get_se_golomb(&amp;h-&gt;gb);
            }

            if (h-&gt;sps.poc_type == 1 &amp;&amp;
                !h-&gt;sps.delta_pic_order_always_zero_flag) {
                h-&gt;delta_poc[0] = get_se_golomb(&amp;h-&gt;gb);

                if (h-&gt;pps.pic_order_present == 1 &amp;&amp;
                    h-&gt;picture_structure == PICT_FRAME)
                    h-&gt;delta_poc[1] = get_se_golomb(&amp;h-&gt;gb);
            }

            /* Decode POC of this picture.
             * The prev_ values needed for decoding POC of the next picture are not set here. */
            field_poc[0] = field_poc[1] = INT_MAX;
            ff_init_poc(h, field_poc, &amp;s-&gt;output_picture_number);

            /* Continue parsing to check if MMCO_RESET is present.
             * FIXME: MMCO_RESET could appear in non-first slice.
             *        Maybe, we should parse all undisposable non-IDR slice of this
             *        picture until encountering MMCO_RESET in a slice of it. */
            if (h-&gt;nal_ref_idc &amp;&amp; h-&gt;nal_unit_type != NAL_IDR_SLICE) {
                got_reset = scan_mmco_reset(s);
                if (got_reset &lt; 0)
                    return got_reset;
            }

            /* Set up the prev_ values for decoding POC of the next picture. */
            h-&gt;prev_frame_num        = got_reset ? 0 : h-&gt;frame_num;
            h-&gt;prev_frame_num_offset = got_reset ? 0 : h-&gt;frame_num_offset;
            if (h-&gt;nal_ref_idc != 0) {
                if (!got_reset) {
                    h-&gt;prev_poc_msb = h-&gt;poc_msb;
                    h-&gt;prev_poc_lsb = h-&gt;poc_lsb;
                } else {
                    h-&gt;prev_poc_msb = 0;
                    h-&gt;prev_poc_lsb =
                        h-&gt;picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];
                }
            }
            //包含“场”概念的时候，先不管
            if (h-&gt;sps.pic_struct_present_flag) {
                switch (h-&gt;sei_pic_struct) {
                case SEI_PIC_STRUCT_TOP_FIELD:
                case SEI_PIC_STRUCT_BOTTOM_FIELD:
                    s-&gt;repeat_pict = 0;
                    break;
                case SEI_PIC_STRUCT_FRAME:
                case SEI_PIC_STRUCT_TOP_BOTTOM:
                case SEI_PIC_STRUCT_BOTTOM_TOP:
                    s-&gt;repeat_pict = 1;
                    break;
                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:
                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:
                    s-&gt;repeat_pict = 2;
                    break;
                case SEI_PIC_STRUCT_FRAME_DOUBLING:
                    s-&gt;repeat_pict = 3;
                    break;
                case SEI_PIC_STRUCT_FRAME_TRIPLING:
                    s-&gt;repeat_pict = 5;
                    break;
                default:
                    s-&gt;repeat_pict = h-&gt;picture_structure == PICT_FRAME ? 1 : 0;
                    break;
                }
            } else {
                s-&gt;repeat_pict = h-&gt;picture_structure == PICT_FRAME ? 1 : 0;
            }

            if (h-&gt;picture_structure == PICT_FRAME) {
                s-&gt;picture_structure = AV_PICTURE_STRUCTURE_FRAME;
                if (h-&gt;sps.pic_struct_present_flag) {
                    switch (h-&gt;sei_pic_struct) {
                    case SEI_PIC_STRUCT_TOP_BOTTOM:
                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:
                        s-&gt;field_order = AV_FIELD_TT;
                        break;
                    case SEI_PIC_STRUCT_BOTTOM_TOP:
                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:
                        s-&gt;field_order = AV_FIELD_BB;
                        break;
                    default:
                        s-&gt;field_order = AV_FIELD_PROGRESSIVE;
                        break;
                    }
                } else {
                    if (field_poc[0] &lt; field_poc[1])
                        s-&gt;field_order = AV_FIELD_TT;
                    else if (field_poc[0] &gt; field_poc[1])
                        s-&gt;field_order = AV_FIELD_BB;
                    else
                        s-&gt;field_order = AV_FIELD_PROGRESSIVE;
                }
            } else {
                if (h-&gt;picture_structure == PICT_TOP_FIELD)
                    s-&gt;picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;
                else
                    s-&gt;picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;
                s-&gt;field_order = AV_FIELD_UNKNOWN;
            }

            return 0; /* no need to evaluate the rest */
        }
    }
    if (q264)
        return 0;
    /* didn't find a picture! */
    av_log(h-&gt;avctx, AV_LOG_ERROR, "missing picture in access unit with size %d\n", buf_size);
    return -1;
}
</pre><br />从源代码可以看出，parse_nal_units()主要做了以下几步处理：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">（1）对于所有的NALU，都调用ff_h264_decode_nal解析NALU的Header，得到nal_unit_type等信息<br />（2）根据nal_unit_type的不同，调用不同的解析函数进行处理。例如：<blockquote style="margin:0 0 0 40px;border:none;padding:0px;">a)解析SPS的时候调用ff_h264_decode_seq_parameter_set()</blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">b)解析PPS的时候调用ff_h264_decode_picture_parameter_set()</blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">c)解析SEI的时候调用ff_h264_decode_sei()</blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">d)解析IDR Slice / Slice的时候，获取slice_type等一些信息。</blockquote></blockquote><br /><h2>ff_h264_decode_nal()</h2>ff_h264_decode_nal()用于解析NAL Header，获得nal_unit_type等信息。该函数的定义位于libavcodec\h264.c，如下所示。<br /><pre class="cpp">//解析NAL Header，获得nal_unit_type等信息
const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src,
                                  int *dst_length, int *consumed, int length)
{
    int i, si, di;
    uint8_t *dst;
    int bufidx;

    // src[0]&amp;0x80; // forbidden bit
    //
    // 1 byte NALU头
    // forbidden_zero_bit: 1bit
    // nal_ref_idc: 2bit
    // nal_unit_type: 5bit
    // nal_ref_idc指示NAL的优先级，取值0-3，值越高，代表NAL越重要
    h-&gt;nal_ref_idc   = src[0] &gt;&gt; 5;
    // nal_unit_type指示NAL的类型
    h-&gt;nal_unit_type = src[0] &amp; 0x1F;
    //后移1Byte
    src++;
    //未处理数据长度减1
    length--;

    //起始码:0x000001
    //保留:0x000002
    //防止竞争:0x000003
    //既表示NALU的开始，又表示NALU的结束
    //STARTCODE_TEST这个宏在后面用到
    //得到length
    //length是指当前NALU单元长度，这里不包括nalu头信息长度（即1个字节）
#define STARTCODE_TEST                                                  \
    if (i + 2 &lt; length &amp;&amp; src[i + 1] == 0 &amp;&amp; src[i + 2] &lt;= 3) {         \
        if (src[i + 2] != 3 &amp;&amp; src[i + 2] != 0) {                       \
            /* 取值为1或者2（保留用），为起始码。startcode, so we must be past the end */\
            length = i;                                                 \
        }                                                               \
        break;                                                          \
    }

#if HAVE_FAST_UNALIGNED
#define FIND_FIRST_ZERO                                                 \
    if (i &gt; 0 &amp;&amp; !src[i])                                               \
        i--;                                                            \
    while (src[i])                                                      \
        i++

#if HAVE_FAST_64BIT
    for (i = 0; i + 1 &lt; length; i += 9) {
        if (!((~AV_RN64A(src + i) &amp;
               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &amp;
              0x8000800080008080ULL))
            continue;
        FIND_FIRST_ZERO;
        STARTCODE_TEST;
        i -= 7;
    }
#else
    for (i = 0; i + 1 &lt; length; i += 5) {
        if (!((~AV_RN32A(src + i) &amp;
               (AV_RN32A(src + i) - 0x01000101U)) &amp;
              0x80008080U))
            continue;
        FIND_FIRST_ZERO;
        STARTCODE_TEST;
        i -= 3;
    }
#endif
#else
    for (i = 0; i + 1 &lt; length; i += 2) {
        if (src[i])
            continue;
        if (i &gt; 0 &amp;&amp; src[i - 1] == 0)
            i--;
        //起始码检测
        STARTCODE_TEST;
    }
#endif

    // use second escape buffer for inter data
    bufidx = h-&gt;nal_unit_type == NAL_DPC ? 1 : 0;

    av_fast_padded_malloc(&amp;h-&gt;rbsp_buffer[bufidx], &amp;h-&gt;rbsp_buffer_size[bufidx], length+MAX_MBPAIR_SIZE);
    dst = h-&gt;rbsp_buffer[bufidx];

    if (!dst)
        return NULL;

    if(i&gt;=length-1){ //no escaped 0
        *dst_length= length;
        *consumed= length+1; //+1 for the header
        if(h-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_FAST){
            return src;
        }else{
            memcpy(dst, src, length);
            return dst;
        }
    }

    memcpy(dst, src, i);
    si = di = i;
    while (si + 2 &lt; length) {
        // remove escapes (very rare 1:2^22)
        if (src[si + 2] &gt; 3) {
            dst[di++] = src[si++];
            dst[di++] = src[si++];
        } else if (src[si] == 0 &amp;&amp; src[si + 1] == 0 &amp;&amp; src[si + 2] != 0) {
            if (src[si + 2] == 3) { // escape
                dst[di++]  = 0;
                dst[di++]  = 0;
                si        += 3;
                continue;
            } else // next start code
                goto nsc;
        }

        dst[di++] = src[si++];
    }
    while (si &lt; length)
        dst[di++] = src[si++];

nsc:
    memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);

    *dst_length = di;
    *consumed   = si + 1; // +1 for the header
    /* FIXME store exact number of bits in the getbitcontext
     * (it is needed for decoding) */
    return dst;
}
</pre><br /><span style="white-space:pre;">	</span>从源代码可以看出，ff_h264_decode_nal()首先从NALU Header（NALU第1个字节）中解析出了nal_ref_idc，nal_unit_type字段的值。然后函数进入了一个for()循环进行起始码检测。<br /><span style="white-space:pre;">	</span>起始码检测这里稍微有点复杂，其中包含了一个STARTCODE_TEST的宏。这个宏用于做具体的起始码的判断。这部分的代码还没有细看，以后有时间再进行补充。<br /><br /><br /><h2>ff_h264_decode_seq_parameter_set()</h2>ff_h264_decode_seq_parameter_set()用于解析H.264码流中的SPS。该函数的定义位于libavcodec\h264_ps.c，如下所示。<br /><pre class="cpp">//解码SPS
int ff_h264_decode_seq_parameter_set(H264Context *h)
{
    int profile_idc, level_idc, constraint_set_flags = 0;
    unsigned int sps_id;
    int i, log2_max_frame_num_minus4;

    SPS *sps;
    //profile型，8bit
    //注意get_bits()
    profile_idc           = get_bits(&amp;h-&gt;gb, 8);
    constraint_set_flags |= get_bits1(&amp;h-&gt;gb) &lt;&lt; 0;   // constraint_set0_flag
    constraint_set_flags |= get_bits1(&amp;h-&gt;gb) &lt;&lt; 1;   // constraint_set1_flag
    constraint_set_flags |= get_bits1(&amp;h-&gt;gb) &lt;&lt; 2;   // constraint_set2_flag
    constraint_set_flags |= get_bits1(&amp;h-&gt;gb) &lt;&lt; 3;   // constraint_set3_flag
    constraint_set_flags |= get_bits1(&amp;h-&gt;gb) &lt;&lt; 4;   // constraint_set4_flag
    constraint_set_flags |= get_bits1(&amp;h-&gt;gb) &lt;&lt; 5;   // constraint_set5_flag
    skip_bits(&amp;h-&gt;gb, 2);                             // reserved_zero_2bits
    //level级，8bit
    level_idc = get_bits(&amp;h-&gt;gb, 8);
    //该SPS的ID号，该ID号将被picture引用
    //注意：get_ue_golomb()
    sps_id    = get_ue_golomb_31(&amp;h-&gt;gb);

    if (sps_id &gt;= MAX_SPS_COUNT) {
        av_log(h-&gt;avctx, AV_LOG_ERROR, "sps_id %u out of range\n", sps_id);
        return AVERROR_INVALIDDATA;
    }
    //赋值给这个结构体
    sps = av_mallocz(sizeof(SPS));
    if (!sps)
        return AVERROR(ENOMEM);
    //赋值
    sps-&gt;sps_id               = sps_id;
    sps-&gt;time_offset_length   = 24;
    sps-&gt;profile_idc          = profile_idc;
    sps-&gt;constraint_set_flags = constraint_set_flags;
    sps-&gt;level_idc            = level_idc;
    sps-&gt;full_range           = -1;

    memset(sps-&gt;scaling_matrix4, 16, sizeof(sps-&gt;scaling_matrix4));
    memset(sps-&gt;scaling_matrix8, 16, sizeof(sps-&gt;scaling_matrix8));
    sps-&gt;scaling_matrix_present = 0;
    sps-&gt;colorspace = 2; //AVCOL_SPC_UNSPECIFIED
    //Profile对应关系
    if (sps-&gt;profile_idc == 100 ||  // High profile
        sps-&gt;profile_idc == 110 ||  // High10 profile
        sps-&gt;profile_idc == 122 ||  // High422 profile
        sps-&gt;profile_idc == 244 ||  // High444 Predictive profile
        sps-&gt;profile_idc ==  44 ||  // Cavlc444 profile
        sps-&gt;profile_idc ==  83 ||  // Scalable Constrained High profile (SVC)
        sps-&gt;profile_idc ==  86 ||  // Scalable High Intra profile (SVC)
        sps-&gt;profile_idc == 118 ||  // Stereo High profile (MVC)
        sps-&gt;profile_idc == 128 ||  // Multiview High profile (MVC)
        sps-&gt;profile_idc == 138 ||  // Multiview Depth High profile (MVCD)
        sps-&gt;profile_idc == 144) {  // old High444 profile

    	//色度取样
    	//0代表单色
    	//1代表4:2:0
    	//2代表4:2:2
    	//3代表4:4:4
        sps-&gt;chroma_format_idc = get_ue_golomb_31(&amp;h-&gt;gb);
        if (sps-&gt;chroma_format_idc &gt; 3U) {
            avpriv_request_sample(h-&gt;avctx, "chroma_format_idc %u",
                                  sps-&gt;chroma_format_idc);
            goto fail;
        } else if (sps-&gt;chroma_format_idc == 3) {
            sps-&gt;residual_color_transform_flag = get_bits1(&amp;h-&gt;gb);
            if (sps-&gt;residual_color_transform_flag) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "separate color planes are not supported\n");
                goto fail;
            }
        }
        //bit_depth_luma_minus8
        //加8之后为亮度颜色深度
        //该值取值范围应该在0到4之间。即颜色深度支持0-12bit
        sps-&gt;bit_depth_luma   = get_ue_golomb(&amp;h-&gt;gb) + 8;
        //加8之后为色度颜色深度
        sps-&gt;bit_depth_chroma = get_ue_golomb(&amp;h-&gt;gb) + 8;
        if (sps-&gt;bit_depth_chroma != sps-&gt;bit_depth_luma) {
            avpriv_request_sample(h-&gt;avctx,
                                  "Different chroma and luma bit depth");
            goto fail;
        }
        if (sps-&gt;bit_depth_luma &gt; 14U || sps-&gt;bit_depth_chroma &gt; 14U) {
            av_log(h-&gt;avctx, AV_LOG_ERROR, "illegal bit depth value (%d, %d)\n",
                   sps-&gt;bit_depth_luma, sps-&gt;bit_depth_chroma);
            goto fail;
        }
        sps-&gt;transform_bypass = get_bits1(&amp;h-&gt;gb);
        decode_scaling_matrices(h, sps, NULL, 1,
                                sps-&gt;scaling_matrix4, sps-&gt;scaling_matrix8);
    } else {
    	//默认
        sps-&gt;chroma_format_idc = 1;
        sps-&gt;bit_depth_luma    = 8;
        sps-&gt;bit_depth_chroma  = 8;
    }
    //log2_max_frame_num_minus4为另一个句法元素frame_num服务
    //fram_num的解码函数是ue（v），函数中的v 在这里指定：
    //     v = log2_max_frame_num_minus4 + 4
    //从另一个角度看，这个句法元素同时也指明了frame_num 的所能达到的最大值：
    //     MaxFrameNum = 2^( log2_max_frame_num_minus4 + 4 )
    log2_max_frame_num_minus4 = get_ue_golomb(&amp;h-&gt;gb);
    if (log2_max_frame_num_minus4 &lt; MIN_LOG2_MAX_FRAME_NUM - 4 ||
        log2_max_frame_num_minus4 &gt; MAX_LOG2_MAX_FRAME_NUM - 4) {
        av_log(h-&gt;avctx, AV_LOG_ERROR,
               "log2_max_frame_num_minus4 out of range (0-12): %d\n",
               log2_max_frame_num_minus4);
        goto fail;
    }
    sps-&gt;log2_max_frame_num = log2_max_frame_num_minus4 + 4;
    //pic_order_cnt_type 指明了poc (picture order count) 的编码方法
    //poc标识图像的播放顺序。
    //由于H.264使用了B帧预测，使得图像的解码顺序并不一定等于播放顺序，但它们之间存在一定的映射关系
    //poc 可以由frame-num 通过映射关系计算得来，也可以索性由编码器显式地传送。
    //H.264 中一共定义了三种poc 的编码方法
    sps-&gt;poc_type = get_ue_golomb_31(&amp;h-&gt;gb);
    //3种poc的编码方法
    if (sps-&gt;poc_type == 0) { // FIXME #define
        unsigned t = get_ue_golomb(&amp;h-&gt;gb);
        if (t&gt;12) {
            av_log(h-&gt;avctx, AV_LOG_ERROR, "log2_max_poc_lsb (%d) is out of range\n", t);
            goto fail;
        }
        sps-&gt;log2_max_poc_lsb = t + 4;
    } else if (sps-&gt;poc_type == 1) { // FIXME #define
        sps-&gt;delta_pic_order_always_zero_flag = get_bits1(&amp;h-&gt;gb);
        sps-&gt;offset_for_non_ref_pic           = get_se_golomb(&amp;h-&gt;gb);
        sps-&gt;offset_for_top_to_bottom_field   = get_se_golomb(&amp;h-&gt;gb);
        sps-&gt;poc_cycle_length                 = get_ue_golomb(&amp;h-&gt;gb);

        if ((unsigned)sps-&gt;poc_cycle_length &gt;=
            FF_ARRAY_ELEMS(sps-&gt;offset_for_ref_frame)) {
            av_log(h-&gt;avctx, AV_LOG_ERROR,
                   "poc_cycle_length overflow %d\n", sps-&gt;poc_cycle_length);
            goto fail;
        }

        for (i = 0; i &lt; sps-&gt;poc_cycle_length; i++)
            sps-&gt;offset_for_ref_frame[i] = get_se_golomb(&amp;h-&gt;gb);
    } else if (sps-&gt;poc_type != 2) {
        av_log(h-&gt;avctx, AV_LOG_ERROR, "illegal POC type %d\n", sps-&gt;poc_type);
        goto fail;
    }
    //num_ref_frames 指定参考帧队列可能达到的最大长度，解码器依照这个句法元素的值开辟存储区，这个存储区用于存放已解码的参考帧，
    //H.264 规定最多可用16 个参考帧，因此最大值为16。
    sps-&gt;ref_frame_count = get_ue_golomb_31(&amp;h-&gt;gb);
    if (h-&gt;avctx-&gt;codec_tag == MKTAG('S', 'M', 'V', '2'))
        sps-&gt;ref_frame_count = FFMAX(2, sps-&gt;ref_frame_count);
    if (sps-&gt;ref_frame_count &gt; H264_MAX_PICTURE_COUNT - 2 ||
        sps-&gt;ref_frame_count &gt; 16U) {
        av_log(h-&gt;avctx, AV_LOG_ERROR,
               "too many reference frames %d\n", sps-&gt;ref_frame_count);
        goto fail;
    }
    sps-&gt;gaps_in_frame_num_allowed_flag = get_bits1(&amp;h-&gt;gb);
    //加1后为图像宽（以宏块为单位）
    //以像素为单位图像宽度（亮度）：width=mb_width*16
    sps-&gt;mb_width                       = get_ue_golomb(&amp;h-&gt;gb) + 1;
    //加1后为图像高（以宏块为单位）
    //以像素为单位图像高度（亮度）：height=mb_height*16
    sps-&gt;mb_height                      = get_ue_golomb(&amp;h-&gt;gb) + 1;
    //检查一下
    if ((unsigned)sps-&gt;mb_width  &gt;= INT_MAX / 16 ||
        (unsigned)sps-&gt;mb_height &gt;= INT_MAX / 16 ||
        av_image_check_size(16 * sps-&gt;mb_width,
                            16 * sps-&gt;mb_height, 0, h-&gt;avctx)) {
        av_log(h-&gt;avctx, AV_LOG_ERROR, "mb_width/height overflow\n");
        goto fail;
    }

    sps-&gt;frame_mbs_only_flag = get_bits1(&amp;h-&gt;gb);
    if (!sps-&gt;frame_mbs_only_flag)
        sps-&gt;mb_aff = get_bits1(&amp;h-&gt;gb);
    else
        sps-&gt;mb_aff = 0;

    sps-&gt;direct_8x8_inference_flag = get_bits1(&amp;h-&gt;gb);

#ifndef ALLOW_INTERLACE
    if (sps-&gt;mb_aff)
        av_log(h-&gt;avctx, AV_LOG_ERROR,
               "MBAFF support not included; enable it at compile-time.\n");
#endif
    //裁剪输出，没研究过
    sps-&gt;crop = get_bits1(&amp;h-&gt;gb);
    if (sps-&gt;crop) {
        int crop_left   = get_ue_golomb(&amp;h-&gt;gb);
        int crop_right  = get_ue_golomb(&amp;h-&gt;gb);
        int crop_top    = get_ue_golomb(&amp;h-&gt;gb);
        int crop_bottom = get_ue_golomb(&amp;h-&gt;gb);
        int width  = 16 * sps-&gt;mb_width;
        int height = 16 * sps-&gt;mb_height * (2 - sps-&gt;frame_mbs_only_flag);

        if (h-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_IGNORE_CROP) {
            av_log(h-&gt;avctx, AV_LOG_DEBUG, "discarding sps cropping, original "
                                           "values are l:%d r:%d t:%d b:%d\n",
                   crop_left, crop_right, crop_top, crop_bottom);

            sps-&gt;crop_left   =
            sps-&gt;crop_right  =
            sps-&gt;crop_top    =
            sps-&gt;crop_bottom = 0;
        } else {
            int vsub   = (sps-&gt;chroma_format_idc == 1) ? 1 : 0;
            int hsub   = (sps-&gt;chroma_format_idc == 1 ||
                          sps-&gt;chroma_format_idc == 2) ? 1 : 0;
            int step_x = 1 &lt;&lt; hsub;
            int step_y = (2 - sps-&gt;frame_mbs_only_flag) &lt;&lt; vsub;

            if (crop_left &amp; (0x1F &gt;&gt; (sps-&gt;bit_depth_luma &gt; 8)) &amp;&amp;
                !(h-&gt;avctx-&gt;flags &amp; CODEC_FLAG_UNALIGNED)) {
                crop_left &amp;= ~(0x1F &gt;&gt; (sps-&gt;bit_depth_luma &gt; 8));
                av_log(h-&gt;avctx, AV_LOG_WARNING,
                       "Reducing left cropping to %d "
                       "chroma samples to preserve alignment.\n",
                       crop_left);
            }

            if (crop_left  &gt; (unsigned)INT_MAX / 4 / step_x ||
                crop_right &gt; (unsigned)INT_MAX / 4 / step_x ||
                crop_top   &gt; (unsigned)INT_MAX / 4 / step_y ||
                crop_bottom&gt; (unsigned)INT_MAX / 4 / step_y ||
                (crop_left + crop_right ) * step_x &gt;= width ||
                (crop_top  + crop_bottom) * step_y &gt;= height
            ) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "crop values invalid %d %d %d %d / %d %d\n", crop_left, crop_right, crop_top, crop_bottom, width, height);
                goto fail;
            }

            sps-&gt;crop_left   = crop_left   * step_x;
            sps-&gt;crop_right  = crop_right  * step_x;
            sps-&gt;crop_top    = crop_top    * step_y;
            sps-&gt;crop_bottom = crop_bottom * step_y;
        }
    } else {
        sps-&gt;crop_left   =
        sps-&gt;crop_right  =
        sps-&gt;crop_top    =
        sps-&gt;crop_bottom =
        sps-&gt;crop        = 0;
    }

    sps-&gt;vui_parameters_present_flag = get_bits1(&amp;h-&gt;gb);
    if (sps-&gt;vui_parameters_present_flag) {
        int ret = decode_vui_parameters(h, sps);
        if (ret &lt; 0)
            goto fail;
    }

    if (!sps-&gt;sar.den)
        sps-&gt;sar.den = 1;
    //Debug的时候可以输出一些信息
    if (h-&gt;avctx-&gt;debug &amp; FF_DEBUG_PICT_INFO) {
        static const char csp[4][5] = { "Gray", "420", "422", "444" };
        av_log(h-&gt;avctx, AV_LOG_DEBUG,
               "sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %"PRId32"/%"PRId32" b%d reo:%d\n",
               sps_id, sps-&gt;profile_idc, sps-&gt;level_idc,
               sps-&gt;poc_type,
               sps-&gt;ref_frame_count,
               sps-&gt;mb_width, sps-&gt;mb_height,
               sps-&gt;frame_mbs_only_flag ? "FRM" : (sps-&gt;mb_aff ? "MB-AFF" : "PIC-AFF"),
               sps-&gt;direct_8x8_inference_flag ? "8B8" : "",
               sps-&gt;crop_left, sps-&gt;crop_right,
               sps-&gt;crop_top, sps-&gt;crop_bottom,
               sps-&gt;vui_parameters_present_flag ? "VUI" : "",
               csp[sps-&gt;chroma_format_idc],
               sps-&gt;timing_info_present_flag ? sps-&gt;num_units_in_tick : 0,
               sps-&gt;timing_info_present_flag ? sps-&gt;time_scale : 0,
               sps-&gt;bit_depth_luma,
               sps-&gt;bitstream_restriction_flag ? sps-&gt;num_reorder_frames : -1
               );
    }
    sps-&gt;new = 1;

    av_free(h-&gt;sps_buffers[sps_id]);
    h-&gt;sps_buffers[sps_id] = sps;

    return 0;

fail:
    av_free(sps);
    return -1;
}
</pre><br />解析SPS源代码并不是很有“技术含量”。只要参考ITU-T的《H.264标准》就可以理解了，不再做过多详细的分析。<br /><br /><h2>ff_h264_decode_picture_parameter_set()</h2>ff_h264_decode_picture_parameter_set()用于解析H.264码流中的PPS。该函数的定义位于libavcodec\h264_ps.c，如下所示。<br /><pre class="cpp">//解码PPS
int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length)
{
	//获取PPS ID
    unsigned int pps_id = get_ue_golomb(&amp;h-&gt;gb);
    PPS *pps;
    SPS *sps;
    int qp_bd_offset;
    int bits_left;

    if (pps_id &gt;= MAX_PPS_COUNT) {
        av_log(h-&gt;avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id);
        return AVERROR_INVALIDDATA;
    }
    //解析后赋值给PPS这个结构体
    pps = av_mallocz(sizeof(PPS));
    if (!pps)
        return AVERROR(ENOMEM);
    //该PPS引用的SPS的ID
    pps-&gt;sps_id = get_ue_golomb_31(&amp;h-&gt;gb);
    if ((unsigned)pps-&gt;sps_id &gt;= MAX_SPS_COUNT ||
        !h-&gt;sps_buffers[pps-&gt;sps_id]) {
        av_log(h-&gt;avctx, AV_LOG_ERROR, "sps_id %u out of range\n", pps-&gt;sps_id);
        goto fail;
    }
    sps = h-&gt;sps_buffers[pps-&gt;sps_id];
    qp_bd_offset = 6 * (sps-&gt;bit_depth_luma - 8);
    if (sps-&gt;bit_depth_luma &gt; 14) {
        av_log(h-&gt;avctx, AV_LOG_ERROR,
               "Invalid luma bit depth=%d\n",
               sps-&gt;bit_depth_luma);
        goto fail;
    } else if (sps-&gt;bit_depth_luma == 11 || sps-&gt;bit_depth_luma == 13) {
        av_log(h-&gt;avctx, AV_LOG_ERROR,
               "Unimplemented luma bit depth=%d\n",
               sps-&gt;bit_depth_luma);
        goto fail;
    }
    //entropy_coding_mode_flag
    //0表示熵编码使用CAVLC，1表示熵编码使用CABAC
    pps-&gt;cabac             = get_bits1(&amp;h-&gt;gb);
    pps-&gt;pic_order_present = get_bits1(&amp;h-&gt;gb);
    pps-&gt;slice_group_count = get_ue_golomb(&amp;h-&gt;gb) + 1;
    if (pps-&gt;slice_group_count &gt; 1) {
        pps-&gt;mb_slice_group_map_type = get_ue_golomb(&amp;h-&gt;gb);
        av_log(h-&gt;avctx, AV_LOG_ERROR, "FMO not supported\n");
        switch (pps-&gt;mb_slice_group_map_type) {
        case 0:
#if 0
    |       for (i = 0; i &lt;= num_slice_groups_minus1; i++)  |   |      |
    |           run_length[i]                               |1  |ue(v) |
#endif
            break;
        case 2:
#if 0
    |       for (i = 0; i &lt; num_slice_groups_minus1; i++) { |   |      |
    |           top_left_mb[i]                              |1  |ue(v) |
    |           bottom_right_mb[i]                          |1  |ue(v) |
    |       }                                               |   |      |
#endif
            break;
        case 3:
        case 4:
        case 5:
#if 0
    |       slice_group_change_direction_flag               |1  |u(1)  |
    |       slice_group_change_rate_minus1                  |1  |ue(v) |
#endif
            break;
        case 6:
#if 0
    |       slice_group_id_cnt_minus1                       |1  |ue(v) |
    |       for (i = 0; i &lt;= slice_group_id_cnt_minus1; i++)|   |      |
    |           slice_group_id[i]                           |1  |u(v)  |
#endif
            break;
        }
    }
    //num_ref_idx_l0_active_minus1 加１后指明目前参考帧队列的长度，即有多少个参考帧
    //读者可能还记得在SPS中有句法元素num_ref_frames 也是跟参考帧队列有关，它们的区
    //别是num_ref_frames 指明参考帧队列的最大值， 解码器用它的值来分配内存空间；
    //num_ref_idx_l0_active_minus1 指明在这个队列中当前实际的、已存在的参考帧数目，这从它的名字
    //“active”中也可以看出来。
    pps-&gt;ref_count[0] = get_ue_golomb(&amp;h-&gt;gb) + 1;
    pps-&gt;ref_count[1] = get_ue_golomb(&amp;h-&gt;gb) + 1;
    if (pps-&gt;ref_count[0] - 1 &gt; 32 - 1 || pps-&gt;ref_count[1] - 1 &gt; 32 - 1) {
        av_log(h-&gt;avctx, AV_LOG_ERROR, "reference overflow (pps)\n");
        goto fail;
    }
    //P Slice 是否使用加权预测？
    pps-&gt;weighted_pred                        = get_bits1(&amp;h-&gt;gb);
    //B Slice 是否使用加权预测？
    pps-&gt;weighted_bipred_idc                  = get_bits(&amp;h-&gt;gb, 2);
    //QP初始值。读取后需要加26
    pps-&gt;init_qp                              = get_se_golomb(&amp;h-&gt;gb) + 26 + qp_bd_offset;
    //SP和SI的QP初始值（没怎么见过这两种帧）
    pps-&gt;init_qs                              = get_se_golomb(&amp;h-&gt;gb) + 26 + qp_bd_offset;
    pps-&gt;chroma_qp_index_offset[0]            = get_se_golomb(&amp;h-&gt;gb);
    pps-&gt;deblocking_filter_parameters_present = get_bits1(&amp;h-&gt;gb);
    pps-&gt;constrained_intra_pred               = get_bits1(&amp;h-&gt;gb);
    pps-&gt;redundant_pic_cnt_present            = get_bits1(&amp;h-&gt;gb);

    pps-&gt;transform_8x8_mode = 0;
    // contents of sps/pps can change even if id doesn't, so reinit
    h-&gt;dequant_coeff_pps = -1;
    memcpy(pps-&gt;scaling_matrix4, h-&gt;sps_buffers[pps-&gt;sps_id]-&gt;scaling_matrix4,
           sizeof(pps-&gt;scaling_matrix4));
    memcpy(pps-&gt;scaling_matrix8, h-&gt;sps_buffers[pps-&gt;sps_id]-&gt;scaling_matrix8,
           sizeof(pps-&gt;scaling_matrix8));

    bits_left = bit_length - get_bits_count(&amp;h-&gt;gb);
    if (bits_left &gt; 0 &amp;&amp; more_rbsp_data_in_pps(h, pps)) {
        pps-&gt;transform_8x8_mode = get_bits1(&amp;h-&gt;gb);
        decode_scaling_matrices(h, h-&gt;sps_buffers[pps-&gt;sps_id], pps, 0,
                                pps-&gt;scaling_matrix4, pps-&gt;scaling_matrix8);
        // second_chroma_qp_index_offset
        pps-&gt;chroma_qp_index_offset[1] = get_se_golomb(&amp;h-&gt;gb);
    } else {
        pps-&gt;chroma_qp_index_offset[1] = pps-&gt;chroma_qp_index_offset[0];
    }

    build_qp_table(pps, 0, pps-&gt;chroma_qp_index_offset[0], sps-&gt;bit_depth_luma);
    build_qp_table(pps, 1, pps-&gt;chroma_qp_index_offset[1], sps-&gt;bit_depth_luma);
    if (pps-&gt;chroma_qp_index_offset[0] != pps-&gt;chroma_qp_index_offset[1])
        pps-&gt;chroma_qp_diff = 1;

    if (h-&gt;avctx-&gt;debug &amp; FF_DEBUG_PICT_INFO) {
        av_log(h-&gt;avctx, AV_LOG_DEBUG,
               "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n",
               pps_id, pps-&gt;sps_id,
               pps-&gt;cabac ? "CABAC" : "CAVLC",
               pps-&gt;slice_group_count,
               pps-&gt;ref_count[0], pps-&gt;ref_count[1],
               pps-&gt;weighted_pred ? "weighted" : "",
               pps-&gt;init_qp, pps-&gt;init_qs, pps-&gt;chroma_qp_index_offset[0], pps-&gt;chroma_qp_index_offset[1],
               pps-&gt;deblocking_filter_parameters_present ? "LPAR" : "",
               pps-&gt;constrained_intra_pred ? "CONSTR" : "",
               pps-&gt;redundant_pic_cnt_present ? "REDU" : "",
               pps-&gt;transform_8x8_mode ? "8x8DCT" : "");
    }

    av_free(h-&gt;pps_buffers[pps_id]);
    h-&gt;pps_buffers[pps_id] = pps;
    return 0;

fail:
    av_free(pps);
    return -1;
}
</pre><br />和解析SPS类似，解析PPS源代码并不是很有“技术含量”。只要参考ITU-T的《H.264标准》就可以理解，不再做过多详细的分析。<br /><br /><h2>ff_h264_decode_sei()</h2>ff_h264_decode_sei()用于解析H.264码流中的SEI。该函数的定义位于libavcodec\h264_sei.c，如下所示。<br /><pre class="cpp">//SEI补充增强信息单元
int ff_h264_decode_sei(H264Context *h)
{
    while (get_bits_left(&amp;h-&gt;gb) &gt; 16 &amp;&amp; show_bits(&amp;h-&gt;gb, 16)) {
        int type = 0;
        unsigned size = 0;
        unsigned next;
        int ret  = 0;

        do {
            if (get_bits_left(&amp;h-&gt;gb) &lt; 8)
                return AVERROR_INVALIDDATA;
            type += show_bits(&amp;h-&gt;gb, 8);
        } while (get_bits(&amp;h-&gt;gb, 8) == 255);

        do {
            if (get_bits_left(&amp;h-&gt;gb) &lt; 8)
                return AVERROR_INVALIDDATA;
            size += show_bits(&amp;h-&gt;gb, 8);
        } while (get_bits(&amp;h-&gt;gb, 8) == 255);

        if (h-&gt;avctx-&gt;debug&amp;FF_DEBUG_STARTCODE)
            av_log(h-&gt;avctx, AV_LOG_DEBUG, "SEI %d len:%d\n", type, size);

        if (size &gt; get_bits_left(&amp;h-&gt;gb) / 8) {
            av_log(h-&gt;avctx, AV_LOG_ERROR, "SEI type %d size %d truncated at %d\n",
                   type, 8*size, get_bits_left(&amp;h-&gt;gb));
            return AVERROR_INVALIDDATA;
        }
        next = get_bits_count(&amp;h-&gt;gb) + 8 * size;

        switch (type) {
        case SEI_TYPE_PIC_TIMING: // Picture timing SEI
            ret = decode_picture_timing(h);
            if (ret &lt; 0)
                return ret;
            break;
        case SEI_TYPE_USER_DATA_ITU_T_T35:
            if (decode_user_data_itu_t_t35(h, size) &lt; 0)
                return -1;
            break;
            //x264的编码参数信息一般都会存储在USER_DATA_UNREGISTERED
            //其他种类的SEI见得很少
        case SEI_TYPE_USER_DATA_UNREGISTERED:
            ret = decode_unregistered_user_data(h, size);
            if (ret &lt; 0)
                return ret;
            break;
        case SEI_TYPE_RECOVERY_POINT:
            ret = decode_recovery_point(h);
            if (ret &lt; 0)
                return ret;
            break;
        case SEI_TYPE_BUFFERING_PERIOD:
            ret = decode_buffering_period(h);
            if (ret &lt; 0)
                return ret;
            break;
        case SEI_TYPE_FRAME_PACKING:
            ret = decode_frame_packing_arrangement(h);
            if (ret &lt; 0)
                return ret;
            break;
        case SEI_TYPE_DISPLAY_ORIENTATION:
            ret = decode_display_orientation(h);
            if (ret &lt; 0)
                return ret;
            break;
        default:
            av_log(h-&gt;avctx, AV_LOG_DEBUG, "unknown SEI type %d\n", type);
        }
        skip_bits_long(&amp;h-&gt;gb, next - get_bits_count(&amp;h-&gt;gb));

        // FIXME check bits here
        align_get_bits(&amp;h-&gt;gb);
    }

    return 0;
}
</pre><br />在《H.264官方标准》中，SEI的种类是非常多的。在ff_h264_decode_sei()中包含以下种类的SEI：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">SEI_TYPE_BUFFERING_PERIOD<br />SEI_TYPE_PIC_TIMING<br />SEI_TYPE_USER_DATA_ITU_T_T35<br />SEI_TYPE_USER_DATA_UNREGISTERED<br />SEI_TYPE_RECOVERY_POINT<br />SEI_TYPE_FRAME_PACKING<br />SEI_TYPE_DISPLAY_ORIENTATION</blockquote>其中的大部分种类的SEI信息我并没有接触过。唯一接触比较多的就是SEI_TYPE_USER_DATA_UNREGISTERED类型的信息了。使用X264编码视频的时候，会自动将配置信息以SEI_TYPE_USER_DATA_UNREGISTERED（用户数据未注册SEI）的形式写入码流。<br /><p>从ff_h264_decode_sei()的定义可以看出，该函数根据不同的SEI类型调用不同的解析函数。当SEI类型为SEI_TYPE_USER_DATA_UNREGISTERED的时候，就会调用decode_unregistered_user_data()函数。</p><p><br /></p><strong>decode_unregistered_user_data()</strong><br />decode_unregistered_user_data()的定义如下所示。从代码可以看出该函数只是简单的提取了X264的版本信息。<br /><pre class="cpp">//x264的编码参数信息一般都会存储在USER_DATA_UNREGISTERED
static int decode_unregistered_user_data(H264Context *h, int size)
{
    uint8_t user_data[16 + 256];
    int e, build, i;

    if (size &lt; 16)
        return AVERROR_INVALIDDATA;

    for (i = 0; i &lt; sizeof(user_data) - 1 &amp;&amp; i &lt; size; i++)
        user_data[i] = get_bits(&amp;h-&gt;gb, 8);
    //user_data内容示例：x264 core 118
    //int sscanf(const char *buffer,const char *format,[argument ]...);
    //sscanf会从buffer里读进数据，依照format的格式将数据写入到argument里。
    user_data[i] = 0;
    e = sscanf(user_data + 16, "x264 - core %d", &amp;build);
    if (e == 1 &amp;&amp; build &gt; 0)
        h-&gt;x264_build = build;
    if (e == 1 &amp;&amp; build == 1 &amp;&amp; !strncmp(user_data+16, "x264 - core 0000", 16))
        h-&gt;x264_build = 67;

    if (h-&gt;avctx-&gt;debug &amp; FF_DEBUG_BUGS)
        av_log(h-&gt;avctx, AV_LOG_DEBUG, "user data:\"%s\"\n", user_data + 16);

    for (; i &lt; size; i++)
        skip_bits(&amp;h-&gt;gb, 8);

    return 0;
}
</pre><br /><br /><h2>解析Slice Header</h2>对于包含图像压缩编码的Slice，解析器（Parser）并不进行解码处理，而是简单提取一些Slice Header中的信息。该部分的代码并没有写成一个函数，而是直接写到了parse_nal_units()里面，截取出来如下所示。<br /><pre class="cpp">case NAL_IDR_SLICE:
        	//如果是IDR Slice
        	//赋值AVCodecParserContext的key_frame为1
            s-&gt;key_frame = 1;

            h-&gt;prev_frame_num        = 0;
            h-&gt;prev_frame_num_offset = 0;
            h-&gt;prev_poc_msb          =
            h-&gt;prev_poc_lsb          = 0;
        /* fall through */
        case NAL_SLICE:
        	//获取Slice的一些信息
        	//跳过first_mb_in_slice这一字段
            get_ue_golomb_long(&amp;h-&gt;gb);  // skip first_mb_in_slice
            //获取帧类型（I,B,P）
            slice_type   = get_ue_golomb_31(&amp;h-&gt;gb);
            //赋值到AVCodecParserContext的pict_type（外部可以访问到）
            s-&gt;pict_type = golomb_to_pict_type[slice_type % 5];
            //关键帧
            if (h-&gt;sei_recovery_frame_cnt &gt;= 0) {
                /* key frame, since recovery_frame_cnt is set */
            	//赋值AVCodecParserContext的key_frame为1
                s-&gt;key_frame = 1;
            }
            //获取 PPS ID
            pps_id = get_ue_golomb(&amp;h-&gt;gb);
            if (pps_id &gt;= MAX_PPS_COUNT) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       "pps_id %u out of range\n", pps_id);
                return -1;
            }
            if (!h-&gt;pps_buffers[pps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       "non-existing PPS %u referenced\n", pps_id);
                return -1;
            }
            h-&gt;pps = *h-&gt;pps_buffers[pps_id];
            if (!h-&gt;sps_buffers[h-&gt;pps.sps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       "non-existing SPS %u referenced\n", h-&gt;pps.sps_id);
                return -1;
            }
            h-&gt;sps       = *h-&gt;sps_buffers[h-&gt;pps.sps_id];
            h-&gt;frame_num = get_bits(&amp;h-&gt;gb, h-&gt;sps.log2_max_frame_num);

            if(h-&gt;sps.ref_frame_count &lt;= 1 &amp;&amp; h-&gt;pps.ref_count[0] &lt;= 1 &amp;&amp; s-&gt;pict_type == AV_PICTURE_TYPE_I)
                s-&gt;key_frame = 1;
            //获得“型”和“级”
            //赋值到AVCodecContext的profile和level
            avctx-&gt;profile = ff_h264_get_profile(&amp;h-&gt;sps);
            avctx-&gt;level   = h-&gt;sps.level_idc;

            if (h-&gt;sps.frame_mbs_only_flag) {
                h-&gt;picture_structure = PICT_FRAME;
            } else {
                if (get_bits1(&amp;h-&gt;gb)) { // field_pic_flag
                    h-&gt;picture_structure = PICT_TOP_FIELD + get_bits1(&amp;h-&gt;gb); // bottom_field_flag
                } else {
                    h-&gt;picture_structure = PICT_FRAME;
                }
            }

            if (h-&gt;nal_unit_type == NAL_IDR_SLICE)
                get_ue_golomb(&amp;h-&gt;gb); /* idr_pic_id */
            if (h-&gt;sps.poc_type == 0) {
                h-&gt;poc_lsb = get_bits(&amp;h-&gt;gb, h-&gt;sps.log2_max_poc_lsb);

                if (h-&gt;pps.pic_order_present == 1 &amp;&amp;
                    h-&gt;picture_structure == PICT_FRAME)
                    h-&gt;delta_poc_bottom = get_se_golomb(&amp;h-&gt;gb);
            }

            if (h-&gt;sps.poc_type == 1 &amp;&amp;
                !h-&gt;sps.delta_pic_order_always_zero_flag) {
                h-&gt;delta_poc[0] = get_se_golomb(&amp;h-&gt;gb);

                if (h-&gt;pps.pic_order_present == 1 &amp;&amp;
                    h-&gt;picture_structure == PICT_FRAME)
                    h-&gt;delta_poc[1] = get_se_golomb(&amp;h-&gt;gb);
            }

            /* Decode POC of this picture.
             * The prev_ values needed for decoding POC of the next picture are not set here. */
            field_poc[0] = field_poc[1] = INT_MAX;
            ff_init_poc(h, field_poc, &amp;s-&gt;output_picture_number);

            /* Continue parsing to check if MMCO_RESET is present.
             * FIXME: MMCO_RESET could appear in non-first slice.
             *        Maybe, we should parse all undisposable non-IDR slice of this
             *        picture until encountering MMCO_RESET in a slice of it. */
            if (h-&gt;nal_ref_idc &amp;&amp; h-&gt;nal_unit_type != NAL_IDR_SLICE) {
                got_reset = scan_mmco_reset(s);
                if (got_reset &lt; 0)
                    return got_reset;
            }

            /* Set up the prev_ values for decoding POC of the next picture. */
            h-&gt;prev_frame_num        = got_reset ? 0 : h-&gt;frame_num;
            h-&gt;prev_frame_num_offset = got_reset ? 0 : h-&gt;frame_num_offset;
            if (h-&gt;nal_ref_idc != 0) {
                if (!got_reset) {
                    h-&gt;prev_poc_msb = h-&gt;poc_msb;
                    h-&gt;prev_poc_lsb = h-&gt;poc_lsb;
                } else {
                    h-&gt;prev_poc_msb = 0;
                    h-&gt;prev_poc_lsb =
                        h-&gt;picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];
                }
            }
</pre><br />可以看出该部分代码提取了根据NALU Header、Slice Header中的信息赋值了一些字段，比如说AVCodecParserContext中的key_frame、pict_type，H264Context中的sps、pps、frame_num等等。<br /><br /><br /><br /><strong><span style="color:#990000;">雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</span></strong><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/45001033		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&t=blog" target="_blank">FFmpeg						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=H.264&t=blog" target="_blank">H.264						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=解码&t=blog" target="_blank">解码						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=源代码&t=blog" target="_blank">源代码						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=NALU&t=blog" target="_blank">NALU						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795"  target="_blank">FFMPEG						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">FFmpeg</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45001033#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/SerenityMoon/article/details/52174437" target="_blank" strategy="BlogCommendFromBaidu_0">
				编译<em>ffmpeg</em>并支持H264			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/SerenityMoon/article/details/52174437" target="_blank" >
				<em>ffmpeg</em>中自带h264的解码，但是没有包含编码，所以再执行avcodec_find_encoder(CODEC_ID_H264)时返回的结果为NULL，需要额外添加x264支持h264的编码。
...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/SerenityMoon" title="SerenityMoon" target="_blank">
					<img src="https://avatar.csdn.net/2/E/6/3_serenitymoon.jpg" alt="SerenityMoon" class="avatar-pic">
					<span class="name">SerenityMoon</span>
				</a>
			</p>
			<p>
				<span class="date">2016-08-10 17:22:31</span>
			</p>
			<p>
				<span class="read-num">阅读数：2859</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/ab7936573/article/details/73743517" target="_blank" strategy="BlogCommendFromBaidu_1">
				<em>FFMPEG</em>系列之五：H264视频流直播			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/ab7936573/article/details/73743517" target="_blank" >
				转载自：http://www.spirithy.com/2016/11/15/<em>ffmpeg</em>_fifth/

这篇应该暂时是<em>FFMPEG</em>系统的收官之作了，要做的事情很<em>简单</em>：把编码得到的（置于MP4容...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/ab7936573" title="ab7936573" target="_blank">
					<img src="https://avatar.csdn.net/3/8/B/3_ab7936573.jpg" alt="ab7936573" class="avatar-pic">
					<span class="name">ab7936573</span>
				</a>
			</p>
			<p>
				<span class="date">2017-06-26 18:54:19</span>
			</p>
			<p>
				<span class="read-num">阅读数：886</span>
			</p>
		</div>
	</div>
								<div class="recommend-item-box recommend-ad-box" id="ad1"></div>
				<script>
				  var width = $("div.recommend-box").outerWidth() - 48;
					NEWS_FEED({
						w: width,
						h : 90,
						showid : 'GNKXx7',
						placeholderId: "ad1",
						inject : 'define',
						define : {
							imagePosition : 'right',
							imageBorderRadius : 0,
							imageWidth: 120,
							imageHeight: 90,
							imageFill : 'clip',
							displayImage : true,
							displayTitle : true,
							titleFontSize: 20,
							titleFontColor: '#333',
							titleFontFamily : 'Microsoft Yahei',
							titleFontWeight: 'bold',
							titlePaddingTop : 0,
							titlePaddingRight : 0,
							titlePaddingBottom : 10,
							titlePaddingLeft : 0,
							displayDesc : true,
							descFontSize: 14,
							descFontColor: '#6b6b6b',
							descFontFamily : 'Microsoft Yahei',
							paddingTop : 0,
							paddingRight : 0,
							paddingBottom : 0,
							paddingLeft : 0,
							backgroundColor: '#fff',
							hoverColor: '#ca0c16'
						}
					})
				</script>

			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/baidu_31872269/article/details/78575743" target="_blank" strategy="BlogCommendFromBaidu_2">
				<em>ffmpeg</em>解码h264文件，opencv显示			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/baidu_31872269/article/details/78575743" target="_blank" >
				H264.h#include 
#include 
#include 
#include 
#include typedef struct
{
    int startcodeprefix_len;...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/baidu_31872269" title="baidu_31872269" target="_blank">
					<img src="https://avatar.csdn.net/1/A/D/3_baidu_31872269.jpg" alt="baidu_31872269" class="avatar-pic">
					<span class="name">baidu_31872269</span>
				</a>
			</p>
			<p>
				<span class="date">2017-11-19 18:08:32</span>
			</p>
			<p>
				<span class="read-num">阅读数：180</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/yunge812/article/details/79709307" target="_blank" strategy="BlogCommendFromBaidu_3">
				<em>FFMPEG</em>实现RTSP中H264数据流解码  并且实时播放			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/yunge812/article/details/79709307" target="_blank" >
				主要过程和<em>ffmpeg</em>实现视频播放的过程差不多 
可以参考：https://blog.csdn.net/yunge812/article/details/79342089

主要改动原始文件的读取 
...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/yunge812" title="yunge812" target="_blank">
					<img src="https://avatar.csdn.net/C/E/8/3_yunge812.jpg" alt="yunge812" class="avatar-pic">
					<span class="name">yunge812</span>
				</a>
			</p>
			<p>
				<span class="date">2018-03-27 10:34:07</span>
			</p>
			<p>
				<span class="read-num">阅读数：798</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/qq_41051855/article/details/79051667" target="_blank" strategy="BlogCommendFromBaidu_4">
				<em>FFmpeg</em>实时解码H264			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/qq_41051855/article/details/79051667" target="_blank" >
				    <em>ffmpeg</em>的解码过程在前面已经稍微总结了下，这里主要是测试一下用<em>ffmpeg</em>如何进行实时的解码。    在解码之前，我们先做好准备工作，调用摄像头。编码的过程中，进行入队出队操作，出队后的数...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/qq_41051855" title="qq_41051855" target="_blank">
					<img src="https://avatar.csdn.net/F/0/6/3_qq_41051855.jpg" alt="qq_41051855" class="avatar-pic">
					<span class="name">qq_41051855</span>
				</a>
			</p>
			<p>
				<span class="date">2018-01-13 15:24:47</span>
			</p>
			<p>
				<span class="read-num">阅读数：2001</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/evsqiezi/article/details/55668595" target="_blank" strategy="BlogCommendFromBaidu_5">
				<em>ffmpeg</em>--解码h264			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/evsqiezi/article/details/55668595" target="_blank" >
				<em>H.264</em><em>解码器</em>（Decoder）在初始化的时候调用了ff_h264_decode_init()，ff_h264_decode_init()又调用了下面几个函数进行<em>解码器</em>汇编函数的初始化工作（仅举了几...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/evsqiezi" title="evsqiezi" target="_blank">
					<img src="https://avatar.csdn.net/D/0/5/3_evsqiezi.jpg" alt="evsqiezi" class="avatar-pic">
					<span class="name">evsqiezi</span>
				</a>
			</p>
			<p>
				<span class="date">2017-02-18 16:54:28</span>
			</p>
			<p>
				<span class="read-num">阅读数：1394</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/jinatom/article/details/7938037" target="_blank" strategy="BlogCommendFromBaidu_6">
				用<em>ffmpeg</em>把H264数据流解码成YUV420P			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/jinatom/article/details/7938037" target="_blank" >
				转自http://blog.csdn.net/vheavens/article/details/7528463

在网上找了很久这方面的内容，发现网上的代码都太旧了，所使用的函数旧到连最新版本的f...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/jinatom" title="jinatom" target="_blank">
					<img src="https://avatar.csdn.net/5/9/2/3_jinatom.jpg" alt="jinatom" class="avatar-pic">
					<span class="name">jinatom</span>
				</a>
			</p>
			<p>
				<span class="date">2012-09-03 15:02:31</span>
			</p>
			<p>
				<span class="read-num">阅读数：9685</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/25430425" target="_blank" strategy="BlogCommendFromBaidu_7">
				最<em>简单</em>的基于<em>FFMPEG</em>的视频编码器（YUV编码为<em>H.264</em>）			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/25430425" target="_blank" >
				本文介绍一个最<em>简单</em>的基于<em>FFMPEG</em>的视频编码器。该编码器实现了YUV420P的像素数据编码为<em>H.264</em>的压缩编码数据。编码器代码十分<em>简单</em>，但是每一行代码都很重要，适合好好研究一下。弄清楚了本代码也就...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2014-05-12 00:42:25</span>
			</p>
			<p>
				<span class="read-num">阅读数：117229</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/OnafioO/article/details/74451920" target="_blank" strategy="BlogCommendFromBaidu_8">
				<em>ffmpeg</em> h264转h265			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/OnafioO/article/details/74451920" target="_blank" >
				<em>ffmpeg</em> -i d:\soft\720p.mp4 -c:v libx265 -b:v 5000k d:\soft\myvideo.mp4
这里码率是5000k，编码是h265
h265的解码貌似用...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/OnafioO" title="OnafioO" target="_blank">
					<img src="https://avatar.csdn.net/6/4/B/3_onafioo.jpg" alt="OnafioO" class="avatar-pic">
					<span class="name">OnafioO</span>
				</a>
			</p>
			<p>
				<span class="date">2017-07-05 15:16:34</span>
			</p>
			<p>
				<span class="read-num">阅读数：3388</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/zhuqing_739/article/details/6636857" target="_blank" strategy="BlogCommendFromBaidu_9">
				利用<em>ffmpeg</em>0.6.1把.h264纯码流打包成.mp4 .avi等格式			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/zhuqing_739/article/details/6636857" target="_blank" >
				一直比较困惑一个问题，都说<em>ffmpeg</em>功能很强大，但是自己一直没有去研究一下，今天终于见识了一下它的强大之处了！
首先当然是在linux下编译和安装成功<em>ffmpeg</em>，关于具体的安装流程，可以参考我前...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/zhuqing_739" title="zhuqing_739" target="_blank">
					<img src="https://avatar.csdn.net/0/3/9/3_zhuqing_739.jpg" alt="zhuqing_739" class="avatar-pic">
					<span class="name">zhuqing_739</span>
				</a>
			</p>
			<p>
				<span class="date">2011-07-27 10:27:33</span>
			</p>
			<p>
				<span class="read-num">阅读数：9950</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45001033" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421180">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>10</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分";
    var ChannelId = 16;
    var articleId = "45001033";
    var commentscount = 2;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/45001033";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "sps_id+0+out+of+range";
    var needInsertBaidu = true;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=sps_id+0+out+of+range"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>