<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/46412607"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="上篇文章概述了FFmpeg中HEVC（H.265）解码器的结构；从这篇文章开始，具体研究HEVC解码器的源代码。本文分析HEVC解码器中解析器（Parser）部分的源代码。这部分的代码用于分割HEVC的NALU，并且解析SPS、PPS、SEI等信息。解析HEVC码流（对应AVCodecParser结构体中的函数）和解码HEVC码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相" />
    <meta name="keywords" content="FFmpeg,解析" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分 - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46412607"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年06月09日 23:19:48</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：13150</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p><span style="white-space:pre;"></span></p><p>=====================================================</p><p>HEVC源代码分析文章列表：</p><p>【解码 -libavcodec HEVC 解码器】</p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/46412023">FFmpeg的HEVC解码器源代码简单分析：概述</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/46412607">FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/46412897">FFmpeg的HEVC解码器源代码简单分析：解码器主干部分</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/46414483">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-PU</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/46451119">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/46483721">FFmpeg的HEVC解码器源代码简单分析：环路滤波（LoopFilter）</a></p><p>=====================================================</p><br /><p><span style="white-space:pre;">	</span>上篇文章概述了FFmpeg的libavcodec中HEVC（H.265）解码器的结构；从这篇文章开始，具体研究HEVC解码器的源代码。本文分析HEVC解码器中解析器（Parser）部分的源代码。这部分的代码用于分割HEVC的NALU，并且解析SPS、PPS、SEI等信息。解析HEVC码流（对应AVCodecParser结构体中的函数）和解码HEVC码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。</p><p><br /></p><h2>函数调用关系图</h2><p>FFmpeg HEVC解析器（Parser）部分在整个HEVC解码器中的位置如下图所示。</p><p style="text-align:center;"><a href="http://img.my.csdn.net/uploads/201506/08/1433745138_2962.png"><img src="https://img-blog.csdn.net/20150608145347835" alt="" /></a><br /></p><div style="text-align:center;"><a href="https://my.csdn.net/leixiaohua1020/album/detail/1809621">单击查看更清晰的大图</a></div><br /><p>HEVC解析器（Parser）部分的源代码的调用关系如下图所示。</p><p style="text-align:center;"><a href="http://img.my.csdn.net/uploads/201506/08/1433746581_8304.png"><img src="https://img-blog.csdn.net/20150608145301041" alt="" /></a><br /></p><div style="text-align:center;"><a href="https://my.csdn.net/leixiaohua1020/album/detail/1809623">单击查看更清晰的大图</a></div><p><br /></p>从图中可以看出，HEVC解析器调用了parse_nal_units()，HEVC解码器调用了decode_nal_units()，而上述两个函数都调用了下面几个解析函数：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">ff_hevc_decode_nal_vps()：解析VPS。<br />ff_hevc_decode_nal_sps()：解析SPS。<br />ff_hevc_decode_nal_pps()：解析PPS。<br />ff_hevc_decode_nal_sei()：解析SEI。</blockquote>下文将会分别这几个函数。<br /><br /><h2>ff_hevc_decoder</h2>ff_hevc_decoder是HEVC解码器对应的AVCodec结构体。该结构体的定义位于libavcodec\hevc.c，如下所示。<br /><pre class="cpp">AVCodec ff_hevc_decoder = {
    .name                  = "hevc",
    .long_name             = NULL_IF_CONFIG_SMALL("HEVC (High Efficiency Video Coding)"),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_HEVC,
    .priv_data_size        = sizeof(HEVCContext),
    .priv_class            = &amp;hevc_decoder_class,
    .init                  = hevc_decode_init,
    .close                 = hevc_decode_free,
    .decode                = hevc_decode_frame,
    .flush                 = hevc_decode_flush,
    .update_thread_context = hevc_update_thread_context,
    .init_thread_copy      = hevc_init_thread_copy,
    .capabilities          = CODEC_CAP_DR1 | CODEC_CAP_DELAY |
                             CODEC_CAP_SLICE_THREADS | CODEC_CAP_FRAME_THREADS,
    .profiles              = NULL_IF_CONFIG_SMALL(profiles),
};</pre>从源代码中可以看出，HEVC解码器的解码函数是hevc_decode_frame()。由于本文主要分析HEVC解析器，所以不对解码函数进行分析。在这里只需要知道hevc_decode_frame()调用了decode_nal_units()，而decode_nal_units()最终调用了ff_hevc_decode_nal_sps()等解析函数即可。<br /><br /><h2>ff_hevc_parser</h2>ff_hevc_parser是HEVC解析器对应的AVCodecParser结构体。该结构体的定义位于libavcodec\hevc_parser.c，如下所示。<br /><pre class="cpp">AVCodecParser ff_hevc_parser = {
    .codec_ids      = { AV_CODEC_ID_HEVC },
    .priv_data_size = sizeof(HEVCParseContext),
    .parser_init    = hevc_init,
    .parser_parse   = hevc_parse,
    .parser_close   = hevc_close,
    .split          = hevc_split,
};</pre>从源代码可以看出，HEVC解析器的初始化函数是hevc_init()，解析函数是hevc_parse()，关闭函数是hevc_close()。<br /><br /><h2>hevc_init()</h2>hevc_init()是HEVC解析器的初始化函数，该函数的定义如下所示。<br /><pre class="cpp">static int hevc_init(AVCodecParserContext *s)
{
    HEVCContext  *h  = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;h;
    h-&gt;HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    h-&gt;skipped_bytes_pos_size = INT_MAX;

    return 0;
}</pre>可以看出hevc_init()简单地给内部成员变量分配了内存。<br /><br /><h2>hevc_close()</h2>hevc_close()是HEVC解析器的关闭函数，该函数的定义如下所示。<br /><pre class="cpp">static void hevc_close(AVCodecParserContext *s)
{
    int i;
    HEVCContext  *h  = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;h;
    ParseContext *pc = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;pc;

    av_freep(&amp;h-&gt;skipped_bytes_pos);
    av_freep(&amp;h-&gt;HEVClc);
    av_freep(&amp;pc-&gt;buffer);

    for (i = 0; i &lt; FF_ARRAY_ELEMS(h-&gt;vps_list); i++)
        av_buffer_unref(&amp;h-&gt;vps_list[i]);
    for (i = 0; i &lt; FF_ARRAY_ELEMS(h-&gt;sps_list); i++)
        av_buffer_unref(&amp;h-&gt;sps_list[i]);
    for (i = 0; i &lt; FF_ARRAY_ELEMS(h-&gt;pps_list); i++)
        av_buffer_unref(&amp;h-&gt;pps_list[i]);

    av_buffer_unref(&amp;h-&gt;current_sps);
    h-&gt;sps = NULL;

    for (i = 0; i &lt; h-&gt;nals_allocated; i++)
        av_freep(&amp;h-&gt;nals[i].rbsp_buffer);
    av_freep(&amp;h-&gt;nals);
    h-&gt;nals_allocated = 0;
}</pre>可以看出hevc_close()释放了内部成员变量的内存。<br /><br /><h2>hevc_parse()</h2>hevc_parse()是HEVC解析器中最关键的解析函数。该函数的定义如下所示。<br /><pre class="cpp">/*
 * 解析码流
 *
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 */
static int hevc_parse(AVCodecParserContext *s,
                      AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    int next;
    ParseContext *pc = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;pc;
    //PARSER_FLAG_COMPLETE_FRAMES为1的时候说明传入的就是完整的1帧数据
    //这时候不用再分割NALU
    //PARSER_FLAG_COMPLETE_FRAMES为0的时候说明传入的是任意一段数据
    //需要先分离出完整的NALU
    if (s-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) {
        next = buf_size;
    } else {
    	//分割NALU
    	//通过查找起始码0x000001的方法
        next = hevc_find_frame_end(s, buf, buf_size);
        //合并
        if (ff_combine_frame(pc, next, &amp;buf, &amp;buf_size) &lt; 0) {
            *poutbuf      = NULL;
            *poutbuf_size = 0;
            return buf_size;
        }
    }
    //解析NALU内容（不解码）
    parse_nal_units(s, avctx, buf, buf_size);

    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return next;
}
</pre><br />从源代码可以看出，hevc_parse()主要做了两步工作：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">（1）判断传入的flags 中是否包含PARSER_FLAG_COMPLETE_FRAMES。如果包含，则说明传入的是完整的一帧数据，不作任何处理；如果不包含，则说明传入的不是完整的一帧数据而是任意一段HEVC数据，则需要调用hevc_find_frame_end()通过查找“起始码”（0x00000001或者0x000001）的方法，分离出完整的一帧数据。<br />（2）调用parse_nal_units()完成了NALU的解析工作。</blockquote>下面分别看一下这两步中的两个函数。<br /><br /><h2>hevc_find_frame_end()</h2>hevc_find_frame_end()用于从HEVC码流中分离出完整的NALU。该函数的定义位于libavcodec\hevc_parser.c，如下所示。<br /><pre class="cpp">/**
 * Find the end of the current frame in the bitstream.
 * @return the position of the first byte of the next frame, or END_NOT_FOUND
 */
//分割NALU
static int hevc_find_frame_end(AVCodecParserContext *s, const uint8_t *buf,
                               int buf_size)
{
    int i;
    ParseContext *pc = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;pc;
    //一个一个字节进行处理
    for (i = 0; i &lt; buf_size; i++) {
        int nut;
        //state64可以存8个字节
        //buf[i]存入state64
        pc-&gt;state64 = (pc-&gt;state64 &lt;&lt; 8) | buf[i];

        //起始码定义#define START_CODE 0x000001
        //state64右移24bit之后，再对比是否为起始码0x000001
        if (((pc-&gt;state64 &gt;&gt; 3 * 8) &amp; 0xFFFFFF) != START_CODE)
            continue;
        //找到起始码之后
        /*
         * 此时state64内容如下：
         *               |      Start Code    | NALU Header |
         * |------|------|------|------|------|------|------|------|
         *
         *               |  buf |  buf |  buf |  buf |  buf | buf  |
         *               | [t-5]| [t-4]| [t-3]| [t-2]| [t-1]|  [t] |
         *
         * Start Code:
         * 0x000001
         *
         * NALU Header:
         * forbidden_zero_bit: 1bit。取值0。
         * nal_unit_type: 6 bit。NALU类型。
         * nuh_layer_id: 6 bit。目前取值为0（保留以后使用）.
         * nuh_temporal_id_plus1: 3 bit。减1后为NALU时域层标识号TemporalID。
         *
         */
        //state64右移16bit之后，state64最低字节为起始码后面的1Byte。即为NALU Header的前一个字节
        //NALU Header的前一个字节中，第1bit为forbidden_zero_bit，取值为0；
        //2-7bit为nal_unit_type；第8bit为nuh_layer_id，取值为0。

        //在这里state64右移(16+1)bit，然后相与0x3F(00111111)
        //即得到了nal_unit_type
        nut = (pc-&gt;state64 &gt;&gt; 2 * 8 + 1) &amp; 0x3F;

        // Beginning of access unit
        if ((nut &gt;= NAL_VPS &amp;&amp; nut &lt;= NAL_AUD) || nut == NAL_SEI_PREFIX ||
            (nut &gt;= 41 &amp;&amp; nut &lt;= 44) || (nut &gt;= 48 &amp;&amp; nut &lt;= 55)) {
            if (pc-&gt;frame_start_found) {
                pc-&gt;frame_start_found = 0;
                //返回起始码开始位置
                return i - 5;
            }
        } else if (nut &lt;= NAL_RASL_R ||
                   (nut &gt;= NAL_BLA_W_LP &amp;&amp; nut &lt;= NAL_CRA_NUT)) {
            int first_slice_segment_in_pic_flag = buf[i] &gt;&gt; 7;
            if (first_slice_segment_in_pic_flag) {
                if (!pc-&gt;frame_start_found) {
                    pc-&gt;frame_start_found = 1;
                } else { // First slice of next frame found
                    pc-&gt;frame_start_found = 0;
                    //返回起始码开始位置
                    return i - 5;
                }
            }
        }
    }

    return END_NOT_FOUND;
}
</pre><br />从源代码可以看出，hevc_find_frame_end()使用ParseContext中的state64临时缓存读取的字节。state64是一个uint64_t类型的变量，一共可以存储8Byte的数据。函数体的for()循环一次读取一个字节，读取完成后将该字节放入state64变量中；接着与起始码“0x000001”进行比较，如果不相等则继续读取，如果相等的话则提取NALU Header中nal_unit_type信息做相应处理后返回起始码开始的位置。<br /><br /><h2>parse_nal_units()</h2>parse_nal_units()用于解析一些NALU（VPS、SPS、PPS）的信息。该函数的定义位于libavcodec\hevc_parser.c，如下所示。<br /><pre class="cpp">/**
 * Parse NAL units of found picture and decode some basic information.
 *
 * @param s parser context.
 * @param avctx codec context.
 * @param buf buffer with field/frame data.
 * @param buf_size size of the buffer.
 *
 * 解析NALU内容（不解码）
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 */
static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx,
                      const uint8_t *buf, int buf_size)
{
    HEVCContext   *h  = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;h;
    GetBitContext *gb = &amp;h-&gt;HEVClc-&gt;gb;
    SliceHeader   *sh = &amp;h-&gt;sh;
    const uint8_t *buf_end = buf + buf_size;
    int state = -1, i;
    HEVCNAL *nal;

    /* set some sane default values */
    s-&gt;pict_type         = AV_PICTURE_TYPE_I;
    s-&gt;key_frame         = 0;
    s-&gt;picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;

    h-&gt;avctx = avctx;

    if (!buf_size)
        return 0;

    if (h-&gt;nals_allocated &lt; 1) {
        HEVCNAL *tmp = av_realloc_array(h-&gt;nals, 1, sizeof(*tmp));
        if (!tmp)
            return AVERROR(ENOMEM);
        h-&gt;nals = tmp;
        memset(h-&gt;nals, 0, sizeof(*tmp));
        h-&gt;nals_allocated = 1;
    }

    nal = &amp;h-&gt;nals[0];

    for (;;) {
        int src_length, consumed;
        buf = avpriv_find_start_code(buf, buf_end, &amp;state);
        if (--buf + 2 &gt;= buf_end)
            break;
        src_length = buf_end - buf;

        h-&gt;nal_unit_type = (*buf &gt;&gt; 1) &amp; 0x3f;
        h-&gt;temporal_id   = (*(buf + 1) &amp; 0x07) - 1;
        if (h-&gt;nal_unit_type &lt;= NAL_CRA_NUT) {
            // Do not walk the whole buffer just to decode slice segment header
            if (src_length &gt; 20)
                src_length = 20;
        }
        //类似于H.264解析器中的ff_h264_decode_nal()
        consumed = ff_hevc_extract_rbsp(h, buf, src_length, nal);
        if (consumed &lt; 0)
            return consumed;

        init_get_bits8(gb, nal-&gt;data + 2, nal-&gt;size);
        /*
         * 几种NALU之间的关系
         *                           +--SS1
         *                           |
         *                 +--PPS1&lt;--+
         *                 |         |
         *       +--SPS1&lt;--+         +--SS2
         *       |         |
         * VPS&lt;--+         +--PPS2
         *       |
         *       +--SPS2
         *
         */
        //解析不同种类的NALU
        switch (h-&gt;nal_unit_type) {
        case NAL_VPS:
        	//解析VPS
        	//VPS主要传输视频分级信息，有利于兼容可分级视频编码以及多视点视频编码
            ff_hevc_decode_nal_vps(h);
            break;
        case NAL_SPS:
        	//解析SPS
            ff_hevc_decode_nal_sps(h);
            break;
        case NAL_PPS:
        	//解析PPS
            ff_hevc_decode_nal_pps(h);
            break;
        case NAL_SEI_PREFIX:
        case NAL_SEI_SUFFIX:
        	//解析SEI
            ff_hevc_decode_nal_sei(h);
            break;
        case NAL_TRAIL_N:
        case NAL_TRAIL_R:
        case NAL_TSA_N:
        case NAL_TSA_R:
        case NAL_STSA_N:
        case NAL_STSA_R:
        case NAL_RADL_N:
        case NAL_RADL_R:
        case NAL_RASL_N:
        case NAL_RASL_R:
        case NAL_BLA_W_LP:
        case NAL_BLA_W_RADL:
        case NAL_BLA_N_LP:
        case NAL_IDR_W_RADL:
        case NAL_IDR_N_LP:
        case NAL_CRA_NUT:

        	//解析 SS Header

        	//按照解码顺序，当前SS是否为第1个SS（Slice Segment）
            sh-&gt;first_slice_in_pic_flag = get_bits1(gb);
            s-&gt;picture_structure = h-&gt;picture_struct;
            s-&gt;field_order = h-&gt;picture_struct;

            //IRAP, Intra Random Access Point, 随机介入点
            //包括 IDR, CRA, BLA
            if (IS_IRAP(h)) {
            	//设置关键帧
                s-&gt;key_frame = 1;
                sh-&gt;no_output_of_prior_pics_flag = get_bits1(gb);
            }
            //当前Slice引用的PPS的ID号
            sh-&gt;pps_id = get_ue_golomb(gb);
            if (sh-&gt;pps_id &gt;= MAX_PPS_COUNT || !h-&gt;pps_list[sh-&gt;pps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "PPS id out of range: %d\n", sh-&gt;pps_id);
                return AVERROR_INVALIDDATA;
            }
            h-&gt;pps = (HEVCPPS*)h-&gt;pps_list[sh-&gt;pps_id]-&gt;data;

            if (h-&gt;pps-&gt;sps_id &gt;= MAX_SPS_COUNT || !h-&gt;sps_list[h-&gt;pps-&gt;sps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", h-&gt;pps-&gt;sps_id);
                return AVERROR_INVALIDDATA;
            }
            if (h-&gt;sps != (HEVCSPS*)h-&gt;sps_list[h-&gt;pps-&gt;sps_id]-&gt;data) {
                h-&gt;sps = (HEVCSPS*)h-&gt;sps_list[h-&gt;pps-&gt;sps_id]-&gt;data;
                h-&gt;vps = (HEVCVPS*)h-&gt;vps_list[h-&gt;sps-&gt;vps_id]-&gt;data;
            }
            //当前Slice不是第一个SS
            if (!sh-&gt;first_slice_in_pic_flag) {
                int slice_address_length;
                //当前SS是否依赖SS
                if (h-&gt;pps-&gt;dependent_slice_segments_enabled_flag)
                    sh-&gt;dependent_slice_segment_flag = get_bits1(gb);
                else
                    sh-&gt;dependent_slice_segment_flag = 0;

                slice_address_length = av_ceil_log2_c(h-&gt;sps-&gt;ctb_width *
                                                      h-&gt;sps-&gt;ctb_height);
                //当前SS中第一个CTU的地址
                sh-&gt;slice_segment_addr = get_bits(gb, slice_address_length);
                if (sh-&gt;slice_segment_addr &gt;= h-&gt;sps-&gt;ctb_width * h-&gt;sps-&gt;ctb_height) {
                    av_log(h-&gt;avctx, AV_LOG_ERROR, "Invalid slice segment address: %u.\n",
                           sh-&gt;slice_segment_addr);
                    return AVERROR_INVALIDDATA;
                }
            } else
                sh-&gt;dependent_slice_segment_flag = 0;//独立SS

            if (sh-&gt;dependent_slice_segment_flag)//依赖SS
                break;

            for (i = 0; i &lt; h-&gt;pps-&gt;num_extra_slice_header_bits; i++)
                skip_bits(gb, 1); // slice_reserved_undetermined_flag[]

            //slice type定义：
            //  0: B Slice
            //  1: P Slice
            //  2: I Slice
            sh-&gt;slice_type = get_ue_golomb(gb);//
            if (!(sh-&gt;slice_type == I_SLICE || sh-&gt;slice_type == P_SLICE ||
                  sh-&gt;slice_type == B_SLICE)) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "Unknown slice type: %d.\n",
                       sh-&gt;slice_type);
                return AVERROR_INVALIDDATA;
            }
            s-&gt;pict_type = sh-&gt;slice_type == B_SLICE ? AV_PICTURE_TYPE_B :
                           sh-&gt;slice_type == P_SLICE ? AV_PICTURE_TYPE_P :
                                                       AV_PICTURE_TYPE_I;

            if (h-&gt;pps-&gt;output_flag_present_flag)
                sh-&gt;pic_output_flag = get_bits1(gb);

            if (h-&gt;sps-&gt;separate_colour_plane_flag)
                sh-&gt;colour_plane_id = get_bits(gb, 2);

            if (!IS_IDR(h)) {
            	//不是IDR，则计算POC
                sh-&gt;pic_order_cnt_lsb = get_bits(gb, h-&gt;sps-&gt;log2_max_poc_lsb);
                s-&gt;output_picture_number = h-&gt;poc = ff_hevc_compute_poc(h, sh-&gt;pic_order_cnt_lsb);
            } else
                s-&gt;output_picture_number = h-&gt;poc = 0;

            if (h-&gt;temporal_id == 0 &amp;&amp;
                h-&gt;nal_unit_type != NAL_TRAIL_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_TSA_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_STSA_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_RADL_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_RASL_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_RADL_R &amp;&amp;
                h-&gt;nal_unit_type != NAL_RASL_R)
                h-&gt;pocTid0 = h-&gt;poc;

            return 0; /* no need to evaluate the rest */
        }
        buf += consumed;
    }
    /* didn't find a picture! */
    av_log(h-&gt;avctx, AV_LOG_ERROR, "missing picture in access unit\n");
    return -1;
}
</pre><br />从源代码可以看出，parse_nal_units()根据nal_unit_type的不同，调用不同的解析函数进行处理。例如：<br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">a)解析VPS的时候调用ff_hevc_decode_nal_vps()<br />b)解析SPS的时候调用ff_hevc_decode_nal_sps()<br />c)解析PPS的时候调用ff_hevc_decode_nal_pps()<br />d)解析SEI的时候调用ff_hevc_decode_nal_sei()<br />e)解析SS Header的一部分信息。</blockquote>下文简单分析这几种NALU的解析函数。<br /><br /><h2>ff_hevc_decode_nal_vps()</h2>目前还没有研究过VPS，所以没有分析该函数。<br /><br /><br /><h2>ff_hevc_decode_nal_sps()</h2>ff_hevc_decode_nal_sps()用于解析HEVC码流中的SPS。该函数的定义位于libavcodec\hevc_ps.c，如下所示。<br /><pre class="cpp">//解析SPS
int ff_hevc_decode_nal_sps(HEVCContext *s)
{
    const AVPixFmtDescriptor *desc;
    GetBitContext *gb = &amp;s-&gt;HEVClc-&gt;gb;
    int ret = 0;
    unsigned int sps_id = 0;
    int log2_diff_max_min_transform_block_size;
    int bit_depth_chroma, start, vui_present, sublayer_ordering_info;
    int i;

    HEVCSPS *sps;
    AVBufferRef *sps_buf = av_buffer_allocz(sizeof(*sps));

    if (!sps_buf)
        return AVERROR(ENOMEM);
    sps = (HEVCSPS*)sps_buf-&gt;data;

    av_log(s-&gt;avctx, AV_LOG_DEBUG, "Decoding SPS\n");

    // Coded parameters
    // 当前引用的VPS的ID
    sps-&gt;vps_id = get_bits(gb, 4);
    if (sps-&gt;vps_id &gt;= MAX_VPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "VPS id out of range: %d\n", sps-&gt;vps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    if (!s-&gt;vps_list[sps-&gt;vps_id]) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "VPS %d does not exist\n",
               sps-&gt;vps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //时域子层的最大数目
    sps-&gt;max_sub_layers = get_bits(gb, 3) + 1;
    if (sps-&gt;max_sub_layers &gt; MAX_SUB_LAYERS) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "sps_max_sub_layers out of range: %d\n",
               sps-&gt;max_sub_layers);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    skip_bits1(gb); // temporal_id_nesting_flag

    if (parse_ptl(s, &amp;sps-&gt;ptl, sps-&gt;max_sub_layers) &lt; 0)
        goto err;
    //当前SPS的ID
    sps_id = get_ue_golomb_long(gb);
    if (sps_id &gt;= MAX_SPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", sps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    /*
	 * chroma_format_idc色度取样格式
	 * 0: Y
	 * 1: YUV420P
	 * 2: YUV422P
	 * 3: YUV444P
	 */
    sps-&gt;chroma_format_idc = get_ue_golomb_long(gb);
    if (!(sps-&gt;chroma_format_idc == 1 || sps-&gt;chroma_format_idc == 2 || sps-&gt;chroma_format_idc == 3)) {
        avpriv_report_missing_feature(s-&gt;avctx, "chroma_format_idc != {1, 2, 3}\n");
        ret = AVERROR_PATCHWELCOME;
        goto err;
    }
    //YUV444的时候，标记是否对3个分量单独编码
    if (sps-&gt;chroma_format_idc == 3)
        sps-&gt;separate_colour_plane_flag = get_bits1(gb);

    if (sps-&gt;separate_colour_plane_flag)
        sps-&gt;chroma_format_idc = 0;
    //宽和高
    sps-&gt;width  = get_ue_golomb_long(gb);
    sps-&gt;height = get_ue_golomb_long(gb);
    if ((ret = av_image_check_size(sps-&gt;width,
                                   sps-&gt;height, 0, s-&gt;avctx)) &lt; 0)
        goto err;
    //裁剪相关
    if (get_bits1(gb)) { // pic_conformance_flag
        //TODO: * 2 is only valid for 420
        sps-&gt;pic_conf_win.left_offset   = get_ue_golomb_long(gb) * 2;
        sps-&gt;pic_conf_win.right_offset  = get_ue_golomb_long(gb) * 2;
        sps-&gt;pic_conf_win.top_offset    = get_ue_golomb_long(gb) * 2;
        sps-&gt;pic_conf_win.bottom_offset = get_ue_golomb_long(gb) * 2;

        if (s-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_IGNORE_CROP) {
            av_log(s-&gt;avctx, AV_LOG_DEBUG,
                   "discarding sps conformance window, "
                   "original values are l:%u r:%u t:%u b:%u\n",
                   sps-&gt;pic_conf_win.left_offset,
                   sps-&gt;pic_conf_win.right_offset,
                   sps-&gt;pic_conf_win.top_offset,
                   sps-&gt;pic_conf_win.bottom_offset);

            sps-&gt;pic_conf_win.left_offset   =
            sps-&gt;pic_conf_win.right_offset  =
            sps-&gt;pic_conf_win.top_offset    =
            sps-&gt;pic_conf_win.bottom_offset = 0;
        }
        sps-&gt;output_window = sps-&gt;pic_conf_win;
    }
    //亮度像素的颜色位深
    sps-&gt;bit_depth   = get_ue_golomb_long(gb) + 8;
    //色度像素的颜色位深
    bit_depth_chroma = get_ue_golomb_long(gb) + 8;
    if (bit_depth_chroma != sps-&gt;bit_depth) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "Luma bit depth (%d) is different from chroma bit depth (%d), "
               "this is unsupported.\n",
               sps-&gt;bit_depth, bit_depth_chroma);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //根据颜色位深和色度采样格式设定pix_fmt
    switch (sps-&gt;bit_depth) {
    case 8:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P;
       break;
    case 9:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P9;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P9;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P9;
        break;
    case 10:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P10;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P10;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P10;
        break;
    case 12:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P12;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P12;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P12;
        break;
    default:
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "4:2:0, 4:2:2, 4:4:4 supports are currently specified for 8, 10 and 12 bits.\n");
        ret = AVERROR_PATCHWELCOME;
        goto err;
    }

    desc = av_pix_fmt_desc_get(sps-&gt;pix_fmt);
    if (!desc) {
        ret = AVERROR(EINVAL);
        goto err;
    }

    sps-&gt;hshift[0] = sps-&gt;vshift[0] = 0;
    sps-&gt;hshift[2] = sps-&gt;hshift[1] = desc-&gt;log2_chroma_w;
    sps-&gt;vshift[2] = sps-&gt;vshift[1] = desc-&gt;log2_chroma_h;

    sps-&gt;pixel_shift = sps-&gt;bit_depth &gt; 8;

    //用于计算POC
    sps-&gt;log2_max_poc_lsb = get_ue_golomb_long(gb) + 4;
    if (sps-&gt;log2_max_poc_lsb &gt; 16) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "log2_max_pic_order_cnt_lsb_minus4 out range: %d\n",
               sps-&gt;log2_max_poc_lsb - 4);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    sublayer_ordering_info = get_bits1(gb);
    start = sublayer_ordering_info ? 0 : sps-&gt;max_sub_layers - 1;
    for (i = start; i &lt; sps-&gt;max_sub_layers; i++) {
        sps-&gt;temporal_layer[i].max_dec_pic_buffering = get_ue_golomb_long(gb) + 1;
        sps-&gt;temporal_layer[i].num_reorder_pics      = get_ue_golomb_long(gb);
        sps-&gt;temporal_layer[i].max_latency_increase  = get_ue_golomb_long(gb) - 1;
        if (sps-&gt;temporal_layer[i].max_dec_pic_buffering &gt; MAX_DPB_SIZE) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, "sps_max_dec_pic_buffering_minus1 out of range: %d\n",
                   sps-&gt;temporal_layer[i].max_dec_pic_buffering - 1);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }
        if (sps-&gt;temporal_layer[i].num_reorder_pics &gt; sps-&gt;temporal_layer[i].max_dec_pic_buffering - 1) {
            av_log(s-&gt;avctx, AV_LOG_WARNING, "sps_max_num_reorder_pics out of range: %d\n",
                   sps-&gt;temporal_layer[i].num_reorder_pics);
            if (s-&gt;avctx-&gt;err_recognition &amp; AV_EF_EXPLODE ||
                sps-&gt;temporal_layer[i].num_reorder_pics &gt; MAX_DPB_SIZE - 1) {
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            sps-&gt;temporal_layer[i].max_dec_pic_buffering = sps-&gt;temporal_layer[i].num_reorder_pics + 1;
        }
    }

    if (!sublayer_ordering_info) {
        for (i = 0; i &lt; start; i++) {
            sps-&gt;temporal_layer[i].max_dec_pic_buffering = sps-&gt;temporal_layer[start].max_dec_pic_buffering;
            sps-&gt;temporal_layer[i].num_reorder_pics      = sps-&gt;temporal_layer[start].num_reorder_pics;
            sps-&gt;temporal_layer[i].max_latency_increase  = sps-&gt;temporal_layer[start].max_latency_increase;
        }
    }
    //亮度编码块-最小尺寸
    sps-&gt;log2_min_cb_size                    = get_ue_golomb_long(gb) + 3;
    //亮度编码块-最大尺寸和最小尺寸插值
    sps-&gt;log2_diff_max_min_coding_block_size = get_ue_golomb_long(gb);
    //亮度变换块-最小尺寸
    sps-&gt;log2_min_tb_size                    = get_ue_golomb_long(gb) + 2;
    //亮度变换块-最大尺寸和最小尺寸插值
    log2_diff_max_min_transform_block_size   = get_ue_golomb_long(gb);
    sps-&gt;log2_max_trafo_size                 = log2_diff_max_min_transform_block_size +
                                               sps-&gt;log2_min_tb_size;

    if (sps-&gt;log2_min_tb_size &gt;= sps-&gt;log2_min_cb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid value for log2_min_tb_size");
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //帧间预测变换块-最大划分深度
    sps-&gt;max_transform_hierarchy_depth_inter = get_ue_golomb_long(gb);
    //帧内预测变换块-最大划分深度
    sps-&gt;max_transform_hierarchy_depth_intra = get_ue_golomb_long(gb);
    //是否使用量化矩阵
    sps-&gt;scaling_list_enable_flag = get_bits1(gb);
    if (sps-&gt;scaling_list_enable_flag) {
        set_default_scaling_list_data(&amp;sps-&gt;scaling_list);

        if (get_bits1(gb)) {
            ret = scaling_list_data(s, &amp;sps-&gt;scaling_list, sps);
            if (ret &lt; 0)
                goto err;
        }
    }
    //是否使用非对称划分模式
    sps-&gt;amp_enabled_flag = get_bits1(gb);
    //是否在去块效应滤波过程中使用样点自适应补偿SAO
    sps-&gt;sao_enabled      = get_bits1(gb);
    //允许PCM编码
    sps-&gt;pcm_enabled_flag = get_bits1(gb);
    //有关PCM编码的参数
    if (sps-&gt;pcm_enabled_flag) {
        sps-&gt;pcm.bit_depth   = get_bits(gb, 4) + 1;
        sps-&gt;pcm.bit_depth_chroma = get_bits(gb, 4) + 1;
        sps-&gt;pcm.log2_min_pcm_cb_size = get_ue_golomb_long(gb) + 3;
        sps-&gt;pcm.log2_max_pcm_cb_size = sps-&gt;pcm.log2_min_pcm_cb_size +
                                        get_ue_golomb_long(gb);
        if (sps-&gt;pcm.bit_depth &gt; sps-&gt;bit_depth) {
            av_log(s-&gt;avctx, AV_LOG_ERROR,
                   "PCM bit depth (%d) is greater than normal bit depth (%d)\n",
                   sps-&gt;pcm.bit_depth, sps-&gt;bit_depth);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }

        sps-&gt;pcm.loop_filter_disable_flag = get_bits1(gb);
    }
    //短期参考num_short_term_ref_pic_set
    sps-&gt;nb_st_rps = get_ue_golomb_long(gb);
    if (sps-&gt;nb_st_rps &gt; MAX_SHORT_TERM_RPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "Too many short term RPS: %d.\n",
               sps-&gt;nb_st_rps);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    for (i = 0; i &lt; sps-&gt;nb_st_rps; i++) {
        if ((ret = ff_hevc_decode_short_term_rps(s, &amp;sps-&gt;st_rps[i],
                                                 sps, 0)) &lt; 0)
            goto err;
    }
    //长期参考num_long_term_ref_pic_set
    sps-&gt;long_term_ref_pics_present_flag = get_bits1(gb);
    if (sps-&gt;long_term_ref_pics_present_flag) {
        sps-&gt;num_long_term_ref_pics_sps = get_ue_golomb_long(gb);
        if (sps-&gt;num_long_term_ref_pics_sps &gt; 31U) {
            av_log(0, AV_LOG_ERROR, "num_long_term_ref_pics_sps %d is out of range.\n",
                   sps-&gt;num_long_term_ref_pics_sps);
            goto err;
        }
        for (i = 0; i &lt; sps-&gt;num_long_term_ref_pics_sps; i++) {
            sps-&gt;lt_ref_pic_poc_lsb_sps[i]       = get_bits(gb, sps-&gt;log2_max_poc_lsb);
            sps-&gt;used_by_curr_pic_lt_sps_flag[i] = get_bits1(gb);
        }
    }
    //是否使用时域MV预测
    sps-&gt;sps_temporal_mvp_enabled_flag          = get_bits1(gb);
    //滤波过程是否使用双线性插值
    sps-&gt;sps_strong_intra_smoothing_enable_flag = get_bits1(gb);
    sps-&gt;vui.sar = (AVRational){0, 1};
    vui_present = get_bits1(gb);
    if (vui_present)
        decode_vui(s, sps);

    if (get_bits1(gb)) { // sps_extension_flag
        int sps_extension_flag[1];
        for (i = 0; i &lt; 1; i++)
            sps_extension_flag[i] = get_bits1(gb);
        skip_bits(gb, 7); //sps_extension_7bits = get_bits(gb, 7);
        if (sps_extension_flag[0]) {
            int extended_precision_processing_flag;
            int high_precision_offsets_enabled_flag;
            int cabac_bypass_alignment_enabled_flag;

            sps-&gt;transform_skip_rotation_enabled_flag = get_bits1(gb);
            sps-&gt;transform_skip_context_enabled_flag  = get_bits1(gb);
            sps-&gt;implicit_rdpcm_enabled_flag = get_bits1(gb);

            sps-&gt;explicit_rdpcm_enabled_flag = get_bits1(gb);

            extended_precision_processing_flag = get_bits1(gb);
            if (extended_precision_processing_flag)
                av_log(s-&gt;avctx, AV_LOG_WARNING,
                   "extended_precision_processing_flag not yet implemented\n");

            sps-&gt;intra_smoothing_disabled_flag       = get_bits1(gb);
            high_precision_offsets_enabled_flag  = get_bits1(gb);
            if (high_precision_offsets_enabled_flag)
                av_log(s-&gt;avctx, AV_LOG_WARNING,
                   "high_precision_offsets_enabled_flag not yet implemented\n");

            sps-&gt;persistent_rice_adaptation_enabled_flag = get_bits1(gb);

            cabac_bypass_alignment_enabled_flag  = get_bits1(gb);
            if (cabac_bypass_alignment_enabled_flag)
                av_log(s-&gt;avctx, AV_LOG_WARNING,
                   "cabac_bypass_alignment_enabled_flag not yet implemented\n");
        }
    }
    if (s-&gt;apply_defdispwin) {
        sps-&gt;output_window.left_offset   += sps-&gt;vui.def_disp_win.left_offset;
        sps-&gt;output_window.right_offset  += sps-&gt;vui.def_disp_win.right_offset;
        sps-&gt;output_window.top_offset    += sps-&gt;vui.def_disp_win.top_offset;
        sps-&gt;output_window.bottom_offset += sps-&gt;vui.def_disp_win.bottom_offset;
    }
    if (sps-&gt;output_window.left_offset &amp; (0x1F &gt;&gt; (sps-&gt;pixel_shift)) &amp;&amp;
        !(s-&gt;avctx-&gt;flags &amp; CODEC_FLAG_UNALIGNED)) {
        sps-&gt;output_window.left_offset &amp;= ~(0x1F &gt;&gt; (sps-&gt;pixel_shift));
        av_log(s-&gt;avctx, AV_LOG_WARNING, "Reducing left output window to %d "
               "chroma samples to preserve alignment.\n",
               sps-&gt;output_window.left_offset);
    }
    sps-&gt;output_width  = sps-&gt;width -
                         (sps-&gt;output_window.left_offset + sps-&gt;output_window.right_offset);
    sps-&gt;output_height = sps-&gt;height -
                         (sps-&gt;output_window.top_offset + sps-&gt;output_window.bottom_offset);
    if (sps-&gt;output_width &lt;= 0 || sps-&gt;output_height &lt;= 0) {
        av_log(s-&gt;avctx, AV_LOG_WARNING, "Invalid visible frame dimensions: %dx%d.\n",
               sps-&gt;output_width, sps-&gt;output_height);
        if (s-&gt;avctx-&gt;err_recognition &amp; AV_EF_EXPLODE) {
            ret = AVERROR_INVALIDDATA;
            goto err;
        }
        av_log(s-&gt;avctx, AV_LOG_WARNING,
               "Displaying the whole video surface.\n");
        memset(&amp;sps-&gt;pic_conf_win, 0, sizeof(sps-&gt;pic_conf_win));
        memset(&amp;sps-&gt;output_window, 0, sizeof(sps-&gt;output_window));
        sps-&gt;output_width               = sps-&gt;width;
        sps-&gt;output_height              = sps-&gt;height;
    }

    // Inferred parameters
    // 推算出来的参数
    sps-&gt;log2_ctb_size = sps-&gt;log2_min_cb_size +
                         sps-&gt;log2_diff_max_min_coding_block_size;
    sps-&gt;log2_min_pu_size = sps-&gt;log2_min_cb_size - 1;

    sps-&gt;ctb_width  = (sps-&gt;width  + (1 &lt;&lt; sps-&gt;log2_ctb_size) - 1) &gt;&gt; sps-&gt;log2_ctb_size;
    sps-&gt;ctb_height = (sps-&gt;height + (1 &lt;&lt; sps-&gt;log2_ctb_size) - 1) &gt;&gt; sps-&gt;log2_ctb_size;
    sps-&gt;ctb_size   = sps-&gt;ctb_width * sps-&gt;ctb_height;

    sps-&gt;min_cb_width  = sps-&gt;width  &gt;&gt; sps-&gt;log2_min_cb_size;
    sps-&gt;min_cb_height = sps-&gt;height &gt;&gt; sps-&gt;log2_min_cb_size;
    sps-&gt;min_tb_width  = sps-&gt;width  &gt;&gt; sps-&gt;log2_min_tb_size;
    sps-&gt;min_tb_height = sps-&gt;height &gt;&gt; sps-&gt;log2_min_tb_size;
    sps-&gt;min_pu_width  = sps-&gt;width  &gt;&gt; sps-&gt;log2_min_pu_size;
    sps-&gt;min_pu_height = sps-&gt;height &gt;&gt; sps-&gt;log2_min_pu_size;
    sps-&gt;tb_mask       = (1 &lt;&lt; (sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size)) - 1;

    sps-&gt;qp_bd_offset = 6 * (sps-&gt;bit_depth - 8);

    if (sps-&gt;width  &amp; ((1 &lt;&lt; sps-&gt;log2_min_cb_size) - 1) ||
        sps-&gt;height &amp; ((1 &lt;&lt; sps-&gt;log2_min_cb_size) - 1)) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid coded frame dimensions.\n");
        goto err;
    }

    if (sps-&gt;log2_ctb_size &gt; MAX_LOG2_CTB_SIZE) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "CTB size out of range: 2^%d\n", sps-&gt;log2_ctb_size);
        goto err;
    }
    if (sps-&gt;max_transform_hierarchy_depth_inter &gt; sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "max_transform_hierarchy_depth_inter out of range: %d\n",
               sps-&gt;max_transform_hierarchy_depth_inter);
        goto err;
    }
    if (sps-&gt;max_transform_hierarchy_depth_intra &gt; sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "max_transform_hierarchy_depth_intra out of range: %d\n",
               sps-&gt;max_transform_hierarchy_depth_intra);
        goto err;
    }
    if (sps-&gt;log2_max_trafo_size &gt; FFMIN(sps-&gt;log2_ctb_size, 5)) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "max transform block size out of range: %d\n",
               sps-&gt;log2_max_trafo_size);
        goto err;
    }

    if (get_bits_left(gb) &lt; 0) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "Overread SPS by %d bits\n", -get_bits_left(gb));
        goto err;
    }

    if (s-&gt;avctx-&gt;debug &amp; FF_DEBUG_BITSTREAM) {
        av_log(s-&gt;avctx, AV_LOG_DEBUG,
               "Parsed SPS: id %d; coded wxh: %dx%d; "
               "cropped wxh: %dx%d; pix_fmt: %s.\n",
               sps_id, sps-&gt;width, sps-&gt;height,
               sps-&gt;output_width, sps-&gt;output_height,
               av_get_pix_fmt_name(sps-&gt;pix_fmt));
    }

    /* check if this is a repeat of an already parsed SPS, then keep the
     * original one.
     * otherwise drop all PPSes that depend on it */
    if (s-&gt;sps_list[sps_id] &amp;&amp;
        !memcmp(s-&gt;sps_list[sps_id]-&gt;data, sps_buf-&gt;data, sps_buf-&gt;size)) {
        av_buffer_unref(&amp;sps_buf);
    } else {
        for (i = 0; i &lt; FF_ARRAY_ELEMS(s-&gt;pps_list); i++) {
            if (s-&gt;pps_list[i] &amp;&amp; ((HEVCPPS*)s-&gt;pps_list[i]-&gt;data)-&gt;sps_id == sps_id)
                av_buffer_unref(&amp;s-&gt;pps_list[i]);
        }
        if (s-&gt;sps_list[sps_id] &amp;&amp; s-&gt;sps == (HEVCSPS*)s-&gt;sps_list[sps_id]-&gt;data) {
            av_buffer_unref(&amp;s-&gt;current_sps);
            s-&gt;current_sps = av_buffer_ref(s-&gt;sps_list[sps_id]);
            if (!s-&gt;current_sps)
                s-&gt;sps = NULL;
        }
        av_buffer_unref(&amp;s-&gt;sps_list[sps_id]);
        s-&gt;sps_list[sps_id] = sps_buf;
    }

    return 0;

err:
    av_buffer_unref(&amp;sps_buf);
    return ret;
}
</pre><br />解析SPS源代码并不是很有“技术含量”。只要参考ITU-T的《HEVC标准》就可以理解了，不再做过多详细的分析。<br /><br /><h2>ff_hevc_decode_nal_pps()</h2>ff_hevc_decode_nal_pps()用于解析HEVC码流中的PPS。该函数的定义位于libavcodec\hevc_ps.c，如下所示。<br /><pre class="cpp">//解析PPS
int ff_hevc_decode_nal_pps(HEVCContext *s)
{
    GetBitContext *gb = &amp;s-&gt;HEVClc-&gt;gb;
    HEVCSPS      *sps = NULL;
    int pic_area_in_ctbs;
    int log2_diff_ctb_min_tb_size;
    int i, j, x, y, ctb_addr_rs, tile_id;
    int ret = 0;
    unsigned int pps_id = 0;

    AVBufferRef *pps_buf;
    HEVCPPS *pps = av_mallocz(sizeof(*pps));

    if (!pps)
        return AVERROR(ENOMEM);

    pps_buf = av_buffer_create((uint8_t *)pps, sizeof(*pps),
                               hevc_pps_free, NULL, 0);
    if (!pps_buf) {
        av_freep(&amp;pps);
        return AVERROR(ENOMEM);
    }

    av_log(s-&gt;avctx, AV_LOG_DEBUG, "Decoding PPS\n");

    // Default values
    // 默认值
    pps-&gt;loop_filter_across_tiles_enabled_flag = 1;
    pps-&gt;num_tile_columns                      = 1;
    pps-&gt;num_tile_rows                         = 1;
    pps-&gt;uniform_spacing_flag                  = 1;
    pps-&gt;disable_dbf                           = 0;
    pps-&gt;beta_offset                           = 0;
    pps-&gt;tc_offset                             = 0;
    pps-&gt;log2_max_transform_skip_block_size    = 2;

    // Coded parameters
    //当前PPS的ID
    pps_id = get_ue_golomb_long(gb);
    if (pps_id &gt;= MAX_PPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "PPS id out of range: %d\n", pps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //引用的SPS的ID
    pps-&gt;sps_id = get_ue_golomb_long(gb);
    if (pps-&gt;sps_id &gt;= MAX_SPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", pps-&gt;sps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    if (!s-&gt;sps_list[pps-&gt;sps_id]) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "SPS %u does not exist.\n", pps-&gt;sps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    sps = (HEVCSPS *)s-&gt;sps_list[pps-&gt;sps_id]-&gt;data;
    //判断当前Slice是否包含依赖片
    pps-&gt;dependent_slice_segments_enabled_flag = get_bits1(gb);
    pps-&gt;output_flag_present_flag              = get_bits1(gb);
    pps-&gt;num_extra_slice_header_bits           = get_bits(gb, 3);

    pps-&gt;sign_data_hiding_flag = get_bits1(gb);
    //在CABAC中用何种方式确定上下文变量的初始值
    pps-&gt;cabac_init_present_flag = get_bits1(gb);
    //list0中参考图像数目的默认最大值
    pps-&gt;num_ref_idx_l0_default_active = get_ue_golomb_long(gb) + 1;
    //list1中参考图像数目的默认最大值
    pps-&gt;num_ref_idx_l1_default_active = get_ue_golomb_long(gb) + 1;
    //亮度分量QP的初始值
    pps-&gt;pic_init_qp_minus26 = get_se_golomb(gb);

    pps-&gt;constrained_intra_pred_flag = get_bits1(gb);
    pps-&gt;transform_skip_enabled_flag = get_bits1(gb);

    pps-&gt;cu_qp_delta_enabled_flag = get_bits1(gb);
    pps-&gt;diff_cu_qp_delta_depth   = 0;
    if (pps-&gt;cu_qp_delta_enabled_flag)
        pps-&gt;diff_cu_qp_delta_depth = get_ue_golomb_long(gb);

    if (pps-&gt;diff_cu_qp_delta_depth &lt; 0 ||
        pps-&gt;diff_cu_qp_delta_depth &gt; sps-&gt;log2_diff_max_min_coding_block_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "diff_cu_qp_delta_depth %d is invalid\n",
               pps-&gt;diff_cu_qp_delta_depth);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    pps-&gt;cb_qp_offset = get_se_golomb(gb);
    if (pps-&gt;cb_qp_offset &lt; -12 || pps-&gt;cb_qp_offset &gt; 12) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_cb_qp_offset out of range: %d\n",
               pps-&gt;cb_qp_offset);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    pps-&gt;cr_qp_offset = get_se_golomb(gb);
    if (pps-&gt;cr_qp_offset &lt; -12 || pps-&gt;cr_qp_offset &gt; 12) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_cr_qp_offset out of range: %d\n",
               pps-&gt;cr_qp_offset);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    pps-&gt;pic_slice_level_chroma_qp_offsets_present_flag = get_bits1(gb);
    //P Slice是否使用加权预测
    pps-&gt;weighted_pred_flag   = get_bits1(gb);
    //B Slice是否使用加权预测
    pps-&gt;weighted_bipred_flag = get_bits1(gb);

    pps-&gt;transquant_bypass_enable_flag    = get_bits1(gb);
    //是否使用tile
    pps-&gt;tiles_enabled_flag               = get_bits1(gb);
    pps-&gt;entropy_coding_sync_enabled_flag = get_bits1(gb);

    if (pps-&gt;tiles_enabled_flag) {
    	//Tile的列数
        pps-&gt;num_tile_columns = get_ue_golomb_long(gb) + 1;
        //Tile的行数
        pps-&gt;num_tile_rows    = get_ue_golomb_long(gb) + 1;
        if (pps-&gt;num_tile_columns == 0 ||
            pps-&gt;num_tile_columns &gt;= sps-&gt;width) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, "num_tile_columns_minus1 out of range: %d\n",
                   pps-&gt;num_tile_columns - 1);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }
        if (pps-&gt;num_tile_rows == 0 ||
            pps-&gt;num_tile_rows &gt;= sps-&gt;height) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, "num_tile_rows_minus1 out of range: %d\n",
                   pps-&gt;num_tile_rows - 1);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }

        pps-&gt;column_width = av_malloc_array(pps-&gt;num_tile_columns, sizeof(*pps-&gt;column_width));
        pps-&gt;row_height   = av_malloc_array(pps-&gt;num_tile_rows,    sizeof(*pps-&gt;row_height));
        if (!pps-&gt;column_width || !pps-&gt;row_height) {
            ret = AVERROR(ENOMEM);
            goto err;
        }

        pps-&gt;uniform_spacing_flag = get_bits1(gb);
        if (!pps-&gt;uniform_spacing_flag) {
            uint64_t sum = 0;
            //每个Tile的宽度和高度
            for (i = 0; i &lt; pps-&gt;num_tile_columns - 1; i++) {
                pps-&gt;column_width[i] = get_ue_golomb_long(gb) + 1;
                sum                 += pps-&gt;column_width[i];
            }
            if (sum &gt;= sps-&gt;ctb_width) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid tile widths.\n");
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            pps-&gt;column_width[pps-&gt;num_tile_columns - 1] = sps-&gt;ctb_width - sum;

            sum = 0;
            for (i = 0; i &lt; pps-&gt;num_tile_rows - 1; i++) {
                pps-&gt;row_height[i] = get_ue_golomb_long(gb) + 1;
                sum               += pps-&gt;row_height[i];
            }
            if (sum &gt;= sps-&gt;ctb_height) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid tile heights.\n");
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            pps-&gt;row_height[pps-&gt;num_tile_rows - 1] = sps-&gt;ctb_height - sum;
        }
        pps-&gt;loop_filter_across_tiles_enabled_flag = get_bits1(gb);
    }

    pps-&gt;seq_loop_filter_across_slices_enabled_flag = get_bits1(gb);
    //是否存在去方块滤波的控制信息
    pps-&gt;deblocking_filter_control_present_flag = get_bits1(gb);
    if (pps-&gt;deblocking_filter_control_present_flag) {
        pps-&gt;deblocking_filter_override_enabled_flag = get_bits1(gb);
        //是否使用去方块滤波
        pps-&gt;disable_dbf                             = get_bits1(gb);
        if (!pps-&gt;disable_dbf) {
            pps-&gt;beta_offset = get_se_golomb(gb) * 2;
            pps-&gt;tc_offset = get_se_golomb(gb) * 2;
            if (pps-&gt;beta_offset/2 &lt; -6 || pps-&gt;beta_offset/2 &gt; 6) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_beta_offset_div2 out of range: %d\n",
                       pps-&gt;beta_offset/2);
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            if (pps-&gt;tc_offset/2 &lt; -6 || pps-&gt;tc_offset/2 &gt; 6) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_tc_offset_div2 out of range: %d\n",
                       pps-&gt;tc_offset/2);
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
        }
    }

    pps-&gt;scaling_list_data_present_flag = get_bits1(gb);
    if (pps-&gt;scaling_list_data_present_flag) {
        set_default_scaling_list_data(&amp;pps-&gt;scaling_list);
        ret = scaling_list_data(s, &amp;pps-&gt;scaling_list, sps);
        if (ret &lt; 0)
            goto err;
    }
    pps-&gt;lists_modification_present_flag = get_bits1(gb);
    pps-&gt;log2_parallel_merge_level       = get_ue_golomb_long(gb) + 2;
    if (pps-&gt;log2_parallel_merge_level &gt; sps-&gt;log2_ctb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "log2_parallel_merge_level_minus2 out of range: %d\n",
               pps-&gt;log2_parallel_merge_level - 2);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    pps-&gt;slice_header_extension_present_flag = get_bits1(gb);

    if (get_bits1(gb)) { // pps_extension_present_flag
        int pps_range_extensions_flag = get_bits1(gb);
        /* int pps_extension_7bits = */ get_bits(gb, 7);
        if (sps-&gt;ptl.general_ptl.profile_idc == FF_PROFILE_HEVC_REXT &amp;&amp; pps_range_extensions_flag) {
            if ((ret = pps_range_extensions(s, pps, sps)) &lt; 0)
                goto err;
        }
    }

    // Inferred parameters
    pps-&gt;col_bd   = av_malloc_array(pps-&gt;num_tile_columns + 1, sizeof(*pps-&gt;col_bd));
    pps-&gt;row_bd   = av_malloc_array(pps-&gt;num_tile_rows + 1,    sizeof(*pps-&gt;row_bd));
    pps-&gt;col_idxX = av_malloc_array(sps-&gt;ctb_width,    sizeof(*pps-&gt;col_idxX));
    if (!pps-&gt;col_bd || !pps-&gt;row_bd || !pps-&gt;col_idxX) {
        ret = AVERROR(ENOMEM);
        goto err;
    }

    if (pps-&gt;uniform_spacing_flag) {
        if (!pps-&gt;column_width) {
            pps-&gt;column_width = av_malloc_array(pps-&gt;num_tile_columns, sizeof(*pps-&gt;column_width));
            pps-&gt;row_height   = av_malloc_array(pps-&gt;num_tile_rows,    sizeof(*pps-&gt;row_height));
        }
        if (!pps-&gt;column_width || !pps-&gt;row_height) {
            ret = AVERROR(ENOMEM);
            goto err;
        }

        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++) {
            pps-&gt;column_width[i] = ((i + 1) * sps-&gt;ctb_width) / pps-&gt;num_tile_columns -
                                   (i * sps-&gt;ctb_width) / pps-&gt;num_tile_columns;
        }

        for (i = 0; i &lt; pps-&gt;num_tile_rows; i++) {
            pps-&gt;row_height[i] = ((i + 1) * sps-&gt;ctb_height) / pps-&gt;num_tile_rows -
                                 (i * sps-&gt;ctb_height) / pps-&gt;num_tile_rows;
        }
    }

    pps-&gt;col_bd[0] = 0;
    for (i = 0; i &lt; pps-&gt;num_tile_columns; i++)
        pps-&gt;col_bd[i + 1] = pps-&gt;col_bd[i] + pps-&gt;column_width[i];

    pps-&gt;row_bd[0] = 0;
    for (i = 0; i &lt; pps-&gt;num_tile_rows; i++)
        pps-&gt;row_bd[i + 1] = pps-&gt;row_bd[i] + pps-&gt;row_height[i];

    for (i = 0, j = 0; i &lt; sps-&gt;ctb_width; i++) {
        if (i &gt; pps-&gt;col_bd[j])
            j++;
        pps-&gt;col_idxX[i] = j;
    }

    /**
     * 6.5
     */
    pic_area_in_ctbs     = sps-&gt;ctb_width    * sps-&gt;ctb_height;

    pps-&gt;ctb_addr_rs_to_ts = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps-&gt;ctb_addr_rs_to_ts));
    pps-&gt;ctb_addr_ts_to_rs = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps-&gt;ctb_addr_ts_to_rs));
    pps-&gt;tile_id           = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps-&gt;tile_id));
    pps-&gt;min_tb_addr_zs_tab = av_malloc_array((sps-&gt;tb_mask+2) * (sps-&gt;tb_mask+2), sizeof(*pps-&gt;min_tb_addr_zs_tab));
    if (!pps-&gt;ctb_addr_rs_to_ts || !pps-&gt;ctb_addr_ts_to_rs ||
        !pps-&gt;tile_id || !pps-&gt;min_tb_addr_zs_tab) {
        ret = AVERROR(ENOMEM);
        goto err;
    }

    for (ctb_addr_rs = 0; ctb_addr_rs &lt; pic_area_in_ctbs; ctb_addr_rs++) {
        int tb_x   = ctb_addr_rs % sps-&gt;ctb_width;
        int tb_y   = ctb_addr_rs / sps-&gt;ctb_width;
        int tile_x = 0;
        int tile_y = 0;
        int val    = 0;

        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++) {
            if (tb_x &lt; pps-&gt;col_bd[i + 1]) {
                tile_x = i;
                break;
            }
        }

        for (i = 0; i &lt; pps-&gt;num_tile_rows; i++) {
            if (tb_y &lt; pps-&gt;row_bd[i + 1]) {
                tile_y = i;
                break;
            }
        }

        for (i = 0; i &lt; tile_x; i++)
            val += pps-&gt;row_height[tile_y] * pps-&gt;column_width[i];
        for (i = 0; i &lt; tile_y; i++)
            val += sps-&gt;ctb_width * pps-&gt;row_height[i];

        val += (tb_y - pps-&gt;row_bd[tile_y]) * pps-&gt;column_width[tile_x] +
               tb_x - pps-&gt;col_bd[tile_x];

        pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs] = val;
        pps-&gt;ctb_addr_ts_to_rs[val]         = ctb_addr_rs;
    }

    for (j = 0, tile_id = 0; j &lt; pps-&gt;num_tile_rows; j++)
        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++, tile_id++)
            for (y = pps-&gt;row_bd[j]; y &lt; pps-&gt;row_bd[j + 1]; y++)
                for (x = pps-&gt;col_bd[i]; x &lt; pps-&gt;col_bd[i + 1]; x++)
                    pps-&gt;tile_id[pps-&gt;ctb_addr_rs_to_ts[y * sps-&gt;ctb_width + x]] = tile_id;

    pps-&gt;tile_pos_rs = av_malloc_array(tile_id, sizeof(*pps-&gt;tile_pos_rs));
    if (!pps-&gt;tile_pos_rs) {
        ret = AVERROR(ENOMEM);
        goto err;
    }

    for (j = 0; j &lt; pps-&gt;num_tile_rows; j++)
        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++)
            pps-&gt;tile_pos_rs[j * pps-&gt;num_tile_columns + i] = pps-&gt;row_bd[j] * sps-&gt;ctb_width + pps-&gt;col_bd[i];

    log2_diff_ctb_min_tb_size = sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size;
    pps-&gt;min_tb_addr_zs = &amp;pps-&gt;min_tb_addr_zs_tab[1*(sps-&gt;tb_mask+2)+1];
    for (y = 0; y &lt; sps-&gt;tb_mask+2; y++) {
        pps-&gt;min_tb_addr_zs_tab[y*(sps-&gt;tb_mask+2)] = -1;
        pps-&gt;min_tb_addr_zs_tab[y]    = -1;
    }
    for (y = 0; y &lt; sps-&gt;tb_mask+1; y++) {
        for (x = 0; x &lt; sps-&gt;tb_mask+1; x++) {
            int tb_x        = x &gt;&gt; log2_diff_ctb_min_tb_size;
            int tb_y        = y &gt;&gt; log2_diff_ctb_min_tb_size;
            int ctb_addr_rs = sps-&gt;ctb_width * tb_y + tb_x;
            int val         = pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs] &lt;&lt;
                              (log2_diff_ctb_min_tb_size * 2);
            for (i = 0; i &lt; log2_diff_ctb_min_tb_size; i++) {
                int m = 1 &lt;&lt; i;
                val += (m &amp; x ? m * m : 0) + (m &amp; y ? 2 * m * m : 0);
            }
            pps-&gt;min_tb_addr_zs[y * (sps-&gt;tb_mask+2) + x] = val;
        }
    }

    if (get_bits_left(gb) &lt; 0) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "Overread PPS by %d bits\n", -get_bits_left(gb));
        goto err;
    }

    av_buffer_unref(&amp;s-&gt;pps_list[pps_id]);
    s-&gt;pps_list[pps_id] = pps_buf;

    return 0;

err:
    av_buffer_unref(&amp;pps_buf);
    return ret;
}
</pre><br />与解析SPS类似，解析PPS源代码并不是很有“技术含量”。只要参考ITU-T的《H.264标准》就可以理解了，不再做过多详细的分析。<br /><br /><h2>ff_hevc_decode_nal_sei()</h2>ff_hevc_decode_nal_sei()用于解析HEVC码流中的SEI。该函数的定义位于libavcodec\hevc_sei.c，如下所示。<br /><pre class="cpp">//解析SEI
int ff_hevc_decode_nal_sei(HEVCContext *s)
{
    int ret;

    do {
    	//解析SEI信息
        ret = decode_nal_sei_message(s);
        if (ret &lt; 0)
            return(AVERROR(ENOMEM));
    } while (more_rbsp_data(&amp;s-&gt;HEVClc-&gt;gb));
    return 1;
}
</pre><br /><p>从源代码可以看出，ff_hevc_decode_nal_sei()在一个do while循环中调用了另外一个函数decode_nal_sei_message()解析SEI信息。</p><p><br /></p><h3>decode_nal_sei_message()</h3>decode_nal_sei_message()用于解析SEI信息，它的定义如下。<br /><pre class="cpp">//解析SEI信息
static int decode_nal_sei_message(HEVCContext *s)
{
    GetBitContext *gb = &amp;s-&gt;HEVClc-&gt;gb;

    int payload_type = 0;
    int payload_size = 0;
    int byte = 0xFF;
    av_log(s-&gt;avctx, AV_LOG_DEBUG, "Decoding SEI\n");

    while (byte == 0xFF) {
        byte          = get_bits(gb, 8);
        payload_type += byte;
    }
    byte = 0xFF;
    while (byte == 0xFF) {
        byte          = get_bits(gb, 8);
        payload_size += byte;
    }
    if (s-&gt;nal_unit_type == NAL_SEI_PREFIX) {
        if (payload_type == 256 /*&amp;&amp; s-&gt;decode_checksum_sei*/) {
            decode_nal_sei_decoded_picture_hash(s);
        } else if (payload_type == 45) {
            decode_nal_sei_frame_packing_arrangement(s);
        } else if (payload_type == 47) {
            decode_nal_sei_display_orientation(s);
        } else if (payload_type == 1){
            int ret = decode_pic_timing(s);
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
            skip_bits(gb, 8 * payload_size);
            return ret;
        } else if (payload_type == 129){
            active_parameter_sets(s);
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
        } else {
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
            skip_bits(gb, 8*payload_size);
        }
    } else { /* nal_unit_type == NAL_SEI_SUFFIX */
        if (payload_type == 132 /* &amp;&amp; s-&gt;decode_checksum_sei */)
            decode_nal_sei_decoded_picture_hash(s);
        else {
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped SUFFIX SEI %d\n", payload_type);
            skip_bits(gb, 8 * payload_size);
        }
    }
    return 1;
}
</pre><br />从源代码可以看出，decode_nal_sei_message()根据不同的payload_type调用不同的函数进行处理，例如调用decode_nal_sei_decoded_picture_hash()，decode_nal_sei_frame_packing_arrangement()，decode_nal_sei_display_orientation()等等。<br /><br /><br /><br /><br /><strong><span style="color:#990000;">雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020<br /></span></strong><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/46412607		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&t=blog" target="_blank">FFmpeg						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=解析&t=blog" target="_blank">解析						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=VPS&t=blog" target="_blank">VPS						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=SPS&t=blog" target="_blank">SPS						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=PPS&t=blog" target="_blank">PPS						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795"  target="_blank">FFMPEG						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">FFmpeg</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46412607#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45001033" target="_blank" strategy="BlogCommendFromBaidu_0">
				<em>FFmpeg</em>的H.264<em>解码器</em><em>源代码</em><em>简单</em><em>分析</em>：<em>解析器</em>（<em>Parser</em>）<em>部分</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45001033" target="_blank" >
				本文继续<em>分析</em><em>FFmpeg</em>中libavcodec的H.264<em>解码器</em>（H.264 Decoder）。上篇文章概述了<em>FFmpeg</em>中H.264<em>解码器</em>的结构；从这篇文章开始，具体研究H.264<em>解码器</em>的<em>源代码</em>。本...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-04-12 00:37:12</span>
			</p>
			<p>
				<span class="read-num">阅读数：38194</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/u012409883/article/details/41878321" target="_blank" strategy="BlogCommendFromBaidu_1">
				【<em>HEVC</em>学习与研究】11.<em>HEVC</em>参考<em>解码器</em>的设置及参数解析过程			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/u012409883/article/details/41878321" target="_blank" >
				之前已经讨论过如何运行HM的encoder工程，已经可以成功将一个yuv测试序列编码为一个.bin格式的二进制码流。这里我们再看看它的逆过程，即将二进制码流进行解码。

在整个HM的solutio...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/u012409883" title="u012409883" target="_blank">
					<img src="https://avatar.csdn.net/2/1/7/3_u012409883.jpg" alt="u012409883" class="avatar-pic">
					<span class="name">u012409883</span>
				</a>
			</p>
			<p>
				<span class="date">2014-12-11 22:48:10</span>
			</p>
			<p>
				<span class="read-num">阅读数：780</span>
			</p>
		</div>
	</div>
								<div class="recommend-item-box recommend-ad-box" id="ad1"></div>
				<script>
				  var width = $("div.recommend-box").outerWidth() - 48;
					NEWS_FEED({
						w: width,
						h : 90,
						showid : 'GNKXx7',
						placeholderId: "ad1",
						inject : 'define',
						define : {
							imagePosition : 'right',
							imageBorderRadius : 0,
							imageWidth: 120,
							imageHeight: 90,
							imageFill : 'clip',
							displayImage : true,
							displayTitle : true,
							titleFontSize: 20,
							titleFontColor: '#333',
							titleFontFamily : 'Microsoft Yahei',
							titleFontWeight: 'bold',
							titlePaddingTop : 0,
							titlePaddingRight : 0,
							titlePaddingBottom : 10,
							titlePaddingLeft : 0,
							displayDesc : true,
							descFontSize: 14,
							descFontColor: '#6b6b6b',
							descFontFamily : 'Microsoft Yahei',
							paddingTop : 0,
							paddingRight : 0,
							paddingBottom : 0,
							paddingLeft : 0,
							backgroundColor: '#fff',
							hoverColor: '#ca0c16'
						}
					})
				</script>

			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/charleslei/article/details/44088383" target="_blank" strategy="BlogCommendFromBaidu_2">
				<em>HEVC</em>的软解码和硬解码			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/charleslei/article/details/44088383" target="_blank" >
				1.概念



 
从数字视频诞生以来，硬解码和软解码的说法一直伴随着它的发展。数字视频的软解码是指在通用CPU上通过专门的播放软件解码并播放视频；而硬解码则是指在专用的硬件解码模块解码视频...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/charleslei" title="charleslei" target="_blank">
					<img src="https://avatar.csdn.net/7/5/F/3_charleslei.jpg" alt="charleslei" class="avatar-pic">
					<span class="name">charleslei</span>
				</a>
			</p>
			<p>
				<span class="date">2015-03-05 23:03:27</span>
			</p>
			<p>
				<span class="read-num">阅读数：1293</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/jingwawa666/article/details/78704314" target="_blank" strategy="BlogCommendFromBaidu_3">
				<em>HEVC</em>标准及编码流程介绍			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/jingwawa666/article/details/78704314" target="_blank" >
				本系列文章分为三个<em>部分</em>，首先对<em>HEVC</em>标准做一个介绍，然后回顾一下H.264中的码率控制方法，<em>分析</em>为什么不能直接沿用旧的方法，最后具体<em>分析</em><em>HEVC</em>的码率控制方法和相应代码。
<em>HEVC</em>标准介绍
首先我们...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/jingwawa666" title="jingwawa666" target="_blank">
					<img src="https://avatar.csdn.net/0/6/6/3_jingwawa666.jpg" alt="jingwawa666" class="avatar-pic">
					<span class="name">jingwawa666</span>
				</a>
			</p>
			<p>
				<span class="date">2017-12-03 21:12:12</span>
			</p>
			<p>
				<span class="read-num">阅读数：1243</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/46412897" target="_blank" strategy="BlogCommendFromBaidu_4">
				<em>FFmpeg</em>的<em>HEVC</em><em>解码器</em><em>源代码</em><em>简单</em><em>分析</em>：<em>解码器</em>主干<em>部分</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/46412897" target="_blank" >
				本文<em>分析</em><em>FFmpeg</em>的<em>HEVC</em><em>解码器</em>的主干<em>部分</em>。“主干<em>部分</em>”是相对于“CTU解码”、 “环路滤波”这些细节<em>部分</em>而言的。它包含了<em>HEVC</em><em>解码器</em>直到hls_decode_entry()前面的函数调用关系（...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-06-10 16:23:08</span>
			</p>
			<p>
				<span class="read-num">阅读数：10685</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/ww506772362/article/details/40781509" target="_blank" strategy="BlogCommendFromBaidu_5">
				<em>HEVC</em>解码中的SPS解析			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/ww506772362/article/details/40781509" target="_blank" >
				一段<em>HEVC</em>码流可能包含一个或者多个编码视频序列CVS，每个CVS由一个随机接入点开始，即IDR/BLA/CRA。在H.264和<em>HEVC</em>中，序列参数集SPS包含该CVS中所有slice需要的信息。SP...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/ww506772362" title="ww506772362" target="_blank">
					<img src="https://avatar.csdn.net/1/3/9/3_ww506772362.jpg" alt="ww506772362" class="avatar-pic">
					<span class="name">ww506772362</span>
				</a>
			</p>
			<p>
				<span class="date">2014-11-04 11:06:14</span>
			</p>
			<p>
				<span class="read-num">阅读数：1537</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/qq_32430349/article/details/50144125" target="_blank" strategy="BlogCommendFromBaidu_6">
				<em>ffmpeg</em>的<em>HEVC</em>解码<em>源代码</em><em>分析</em>（一）整体框架			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/qq_32430349/article/details/50144125" target="_blank" >
				通过调试<em>ffmpeg</em>对<em>HEVC</em>码流（格式为es流，就是rawvideo）的解码过程，<em>分析</em><em>ffmpeg</em>的<em>HEVC</em>解码过程和实现方法。
首先要说的是调试所用的工程的config为：./configure ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/qq_32430349" title="qq_32430349" target="_blank">
					<img src="https://avatar.csdn.net/C/B/0/3_qq_32430349.jpg" alt="qq_32430349" class="avatar-pic">
					<span class="name">qq_32430349</span>
				</a>
			</p>
			<p>
				<span class="date">2015-12-02 09:53:19</span>
			</p>
			<p>
				<span class="read-num">阅读数：1557</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/pc__wang/article/details/33729047" target="_blank" strategy="BlogCommendFromBaidu_7">
				<em>HEVC</em>码流<em>分析</em>工具			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/pc__wang/article/details/33729047" target="_blank" >
				GITL <em>HEVC</em> Analyzer 是一款开源的<em>HEVC</em>格式的视频码流<em>分析</em>器。			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/pc__wang" title="pc__wang" target="_blank">
					<img src="https://avatar.csdn.net/1/B/1/3_pc__wang.jpg" alt="pc__wang" class="avatar-pic">
					<span class="name">pc__wang</span>
				</a>
			</p>
			<p>
				<span class="date">2014-06-23 13:28:33</span>
			</p>
			<p>
				<span class="read-num">阅读数：1649</span>
			</p>
		</div>
	</div>
						<div class="recommend-item-box recommend-download-box csdn-tracking-statistics clearfix" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
			<div class="content float-left">
				<h4 class="text-truncate">
					<a href="https://download.csdn.net/download/tianzhijiaozi19/8592803" target="_blank" strategy="BlogCommendFromBaidu_8">
						最新版的<em>hevc</em><em>分析</em>工具					</a>
				</h4>
				<p>
					<span class="data">2015年04月14日 </span>
					<span class="size">16.56MB</span>
					<span class="type">下载</span>
				</p>
			</div>
			<div class="img-box float-right">
				<a href="https://download.csdn.net/download/tianzhijiaozi19/8592803" target="_blank" strategy="BlogCommendFromBaidu_8">
					<img src="http://csdnimg.cn/release/download/old_static/images/minetype/zip.svg" alt="">
				</a>
			</div>
		</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/lin453701006/article/details/52797104" target="_blank" strategy="BlogCommendFromBaidu_9">
				<em>HEVC</em>编码结构：序列参数集SPS、图像参数集PPS、视频参数集VPS			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/lin453701006/article/details/52797104" target="_blank" >
				1、序列参数集SPS——H.264/H.265

背景：在码流结构方面，H.265压缩数据采用了类似于H.264的分层结构，将属于图像组GOP（Group Of picture）层、Slice层中共用...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/lin453701006" title="lin453701006" target="_blank">
					<img src="https://avatar.csdn.net/A/5/4/3_lin453701006.jpg" alt="lin453701006" class="avatar-pic">
					<span class="name">lin453701006</span>
				</a>
			</p>
			<p>
				<span class="date">2016-10-12 14:38:58</span>
			</p>
			<p>
				<span class="read-num">阅读数：2617</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46412607" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421160">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>2</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分";
    var ChannelId = 16;
    var articleId = "46412607";
    var commentscount = 2;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/46412607";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "hevc%E8%A7%A3%E7%A0%81%E5%99%A8";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=hevc%E8%A7%A3%E7%A0%81%E5%99%A8"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>