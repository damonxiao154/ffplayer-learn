<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/46451119"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文分析FFmpeg的libavcodec中的HEVC解码器的CTU解码（CTU Decode）部分的源代码。FFmpeg的HEVC解码器调用hls_decode_entry()函数完成了Slice解码工作。hls_decode_entry()则调用了hls_coding_quadtree()完成了CTU解码工作。由于CTU解码部分的内容比较多，因此将这一部分内容拆分成两篇文章：一篇文章记录PU的解码，另一篇文章记录TU解码。本文记录TU的解码过程。" />
    <meta name="keywords" content="FFmpeg,libavcodec" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46451119"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年06月16日 17:14:42</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：6812</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p></p><p>=====================================================</p><p>HEVC源代码分析文章列表：</p><p>【解码 -libavcodec HEVC 解码器】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46412023">FFmpeg的HEVC解码器源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46412607">FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46412897">FFmpeg的HEVC解码器源代码简单分析：解码器主干部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46414483">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-PU</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46451119">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46483721">FFmpeg的HEVC解码器源代码简单分析：环路滤波（LoopFilter）</a></p><p>=====================================================</p><br /><p><span style="white-space:pre">	</span>本文分析FFmpeg的libavcodec中的HEVC解码器的CTU解码（CTU Decode）部分的源代码。FFmpeg的HEVC解码器调用hls_decode_entry()函数完成了Slice解码工作。hls_decode_entry()则调用了hls_coding_quadtree()完成了CTU解码工作。由于CTU解码部分的内容比较多，因此将这一部分内容拆分成两篇文章：一篇文章记录PU的解码，另一篇文章记录TU解码。本文记录TU的解码过程。</p><br /><h2>函数调用关系图</h2><p>FFmpeg HEVC解码器的CTU解码（CTU Decoder）部分在整个HEVC解码器中的位置如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201506/08/1433745138_2962.png"><img src="http://img.blog.csdn.net/20150611022611101" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1809621">单击查看更清晰的大图</a></div><br /><p>CTU解码（CTU Decoder）部分的函数调用关系如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201506/08/1433752698_7362.png"><img src="http://img.blog.csdn.net/20150611022641278" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1809629">单击查看更清晰的大图</a></div><br /><span style="white-space:pre">	</span>从图中可以看出，CTU解码模块对应的函数是hls_coding_quadtree()。该函数是一个递归调用的函数，可以按照四叉树的句法格式解析CTU并获得其中的CU。对于每个CU会调用hls_coding_unit()进行解码。<br /><span style="white-space:pre">	</span>hls_coding_unit()会调用hls_prediction_unit()对CU中的PU进行处理。hls_prediction_unit()调用luma_mc_uni()对亮度单向预测块进行运动补偿处理，调用chroma_mc_uni()对色度单向预测块进行运动补偿处理，调用luma_mc_bi()对亮度单向预测块进行运动补偿处理。<br /><span style="white-space:pre">	</span>hls_coding_unit()会调用hls_transform_tree()对CU中的TU进行处理。hls_transform_tree()是一个递归调用的函数，可以按照四叉树的句法格式解析并获得其中的TU。对于每一个TU会调用hls_transform_unit()进行解码。hls_transform_unit()会进行帧内预测，并且调用ff_hevc_hls_residual_coding()解码DCT残差数据。<br /><br /><h2>hls_decode_entry()</h2>hls_decode_entry()是FFmpeg HEVC解码器中Slice解码的入口函数。该函数的定义如下所示。<br /><pre name="code" class="cpp">//解码入口函数
static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
{
    HEVCContext *s  = avctxt-&gt;priv_data;
    //CTB尺寸
    int ctb_size    = 1 &lt;&lt; s-&gt;sps-&gt;log2_ctb_size;
    int more_data   = 1;
    int x_ctb       = 0;
    int y_ctb       = 0;
    int ctb_addr_ts = s-&gt;pps-&gt;ctb_addr_rs_to_ts[s-&gt;sh.slice_ctb_addr_rs];

    if (!ctb_addr_ts &amp;&amp; s-&gt;sh.dependent_slice_segment_flag) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Impossible initial tile.\n&quot;);
        return AVERROR_INVALIDDATA;
    }

    if (s-&gt;sh.dependent_slice_segment_flag) {
        int prev_rs = s-&gt;pps-&gt;ctb_addr_ts_to_rs[ctb_addr_ts - 1];
        if (s-&gt;tab_slice_address[prev_rs] != s-&gt;sh.slice_addr) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Previous slice segment missing\n&quot;);
            return AVERROR_INVALIDDATA;
        }
    }

    while (more_data &amp;&amp; ctb_addr_ts &lt; s-&gt;sps-&gt;ctb_size) {
        int ctb_addr_rs = s-&gt;pps-&gt;ctb_addr_ts_to_rs[ctb_addr_ts];
        //CTB的位置x和y
        x_ctb = (ctb_addr_rs % ((s-&gt;sps-&gt;width + ctb_size - 1) &gt;&gt; s-&gt;sps-&gt;log2_ctb_size)) &lt;&lt; s-&gt;sps-&gt;log2_ctb_size;
        y_ctb = (ctb_addr_rs / ((s-&gt;sps-&gt;width + ctb_size - 1) &gt;&gt; s-&gt;sps-&gt;log2_ctb_size)) &lt;&lt; s-&gt;sps-&gt;log2_ctb_size;
        //初始化周围的参数
        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);
        //初始化CABAC
        ff_hevc_cabac_init(s, ctb_addr_ts);
        //样点自适应补偿参数
        hls_sao_param(s, x_ctb &gt;&gt; s-&gt;sps-&gt;log2_ctb_size, y_ctb &gt;&gt; s-&gt;sps-&gt;log2_ctb_size);

        s-&gt;deblock[ctb_addr_rs].beta_offset = s-&gt;sh.beta_offset;
        s-&gt;deblock[ctb_addr_rs].tc_offset   = s-&gt;sh.tc_offset;
        s-&gt;filter_slice_edges[ctb_addr_rs]  = s-&gt;sh.slice_loop_filter_across_slices_enabled_flag;
        /*
         * CU示意图
         *
		 * 64x64块
		 *
		 * 深度d=0
		 * split_flag=1时候划分为4个32x32
		 *
		 * +--------+--------+--------+--------+--------+--------+--------+--------+
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * +                                   |                                   +
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * +                                   |                                   +
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * +                                   |                                   +
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * + --  --  --  --  --  --  --  --  --+ --  --  --  --  --  --  --  --  --+
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +                                                                       +
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +                                                                       +
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +                                                                       +
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +--------+--------+--------+--------+--------+--------+--------+--------+
         *
         *
		 * 32x32 块
		 * 深度d=1
		 * split_flag=1时候划分为4个16x16
		 *
		 * +--------+--------+--------+--------+
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * +                 |                 +
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * + --  --  --  --  + --  --  --  --  +
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * +                 |                 +
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * +--------+--------+--------+--------+
         *
         *
		 * 16x16 块
		 * 深度d=2
		 * split_flag=1时候划分为4个8x8
		 *
		 * +--------+--------+
		 * |                 |
		 * |        |        |
		 * |                 |
		 * +  --  --+ --  -- +
		 * |                 |
		 * |        |        |
		 * |                 |
		 * +--------+--------+
         *
         *
         * 8x8块
		 * 深度d=3
		 * split_flag=1时候划分为4个4x4
         *
		 * +----+----+
		 * |    |    |
		 * + -- + -- +
		 * |    |    |
		 * +----+----+
         *
         */
        /*
         * 解析四叉树结构，并且解码
         *
         * hls_coding_quadtree(HEVCContext *s, int x0, int y0, int log2_cb_size, int cb_depth)中：
         * s：HEVCContext上下文结构体
         * x_ctb：CB位置的x坐标
         * y_ctb：CB位置的y坐标
         * log2_cb_size：CB大小取log2之后的值
         * cb_depth：深度
         *
         */
        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s-&gt;sps-&gt;log2_ctb_size, 0);
        if (more_data &lt; 0) {
            s-&gt;tab_slice_address[ctb_addr_rs] = -1;
            return more_data;
        }


        ctb_addr_ts++;
        //保存解码信息以供下次使用
        ff_hevc_save_states(s, ctb_addr_ts);
        //去块效应滤波
        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
    }

    if (x_ctb + ctb_size &gt;= s-&gt;sps-&gt;width &amp;&amp;
        y_ctb + ctb_size &gt;= s-&gt;sps-&gt;height)
        ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size);

    return ctb_addr_ts;
}
</pre><br />从源代码可以看出，hls_decode_entry()主要调用了2个函数进行解码工作：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用hls_coding_quadtree()解码CTU。其中包含了PU和TU的解码。<br />（2）调用ff_hevc_hls_filters()进行滤波。其中包含了去块效应滤波和SAO滤波。</blockquote>本文分析第一步的CTU解码过程。<br /><br /><h2>hls_coding_quadtree()</h2>hls_coding_quadtree()用于解析CTU的四叉树句法结构。该函数的定义如下所示。<br /><pre name="code" class="cpp">/*
 * 解析四叉树结构，并且解码
 * 注意该函数是递归调用
 * 注释和处理：雷霄骅
 *
 *
 * s：HEVCContext上下文结构体
 * x_ctb：CB位置的x坐标
 * y_ctb：CB位置的y坐标
 * log2_cb_size：CB大小取log2之后的值
 * cb_depth：深度
 *
 */
static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
                               int log2_cb_size, int cb_depth)
{
    HEVCLocalContext *lc = s-&gt;HEVClc;
    //CB的大小,split flag=0
    //log2_cb_size为CB大小取log之后的结果
    const int cb_size    = 1 &lt;&lt; log2_cb_size;
    int ret;
    int qp_block_mask = (1&lt;&lt;(s-&gt;sps-&gt;log2_ctb_size - s-&gt;pps-&gt;diff_cu_qp_delta_depth)) - 1;
    int split_cu;

    lc-&gt;ct_depth = cb_depth;
    if (x0 + cb_size &lt;= s-&gt;sps-&gt;width  &amp;&amp;
        y0 + cb_size &lt;= s-&gt;sps-&gt;height &amp;&amp;
        log2_cb_size &gt; s-&gt;sps-&gt;log2_min_cb_size) {
        split_cu = ff_hevc_split_coding_unit_flag_decode(s, cb_depth, x0, y0);
    } else {
        split_cu = (log2_cb_size &gt; s-&gt;sps-&gt;log2_min_cb_size);
    }
    if (s-&gt;pps-&gt;cu_qp_delta_enabled_flag &amp;&amp;
        log2_cb_size &gt;= s-&gt;sps-&gt;log2_ctb_size - s-&gt;pps-&gt;diff_cu_qp_delta_depth) {
        lc-&gt;tu.is_cu_qp_delta_coded = 0;
        lc-&gt;tu.cu_qp_delta          = 0;
    }

    if (s-&gt;sh.cu_chroma_qp_offset_enabled_flag &amp;&amp;
        log2_cb_size &gt;= s-&gt;sps-&gt;log2_ctb_size - s-&gt;pps-&gt;diff_cu_chroma_qp_offset_depth) {
        lc-&gt;tu.is_cu_chroma_qp_offset_coded = 0;
    }

    if (split_cu) {
    	//如果CU还可以继续划分，则继续解析划分后的CU
    	//注意这里是递归调用


    	//CB的大小,split flag=1
        const int cb_size_split = cb_size &gt;&gt; 1;

        /*
         * (x0, y0)  (x1, y0)
		 *     +--------+--------+
		 *     |                 |
		 *     |        |        |
		 *     |                 |
		 *     +  --  --+ --  -- +
		 * (x0, y1)  (x1, y1)    |
		 *     |        |        |
		 *     |                 |
		 *     +--------+--------+
		 *
         */
        const int x1 = x0 + cb_size_split;
        const int y1 = y0 + cb_size_split;

        int more_data = 0;

        //注意：
        //CU大小减半，log2_cb_size-1
        //深度d加1，cb_depth+1
        more_data = hls_coding_quadtree(s, x0, y0, log2_cb_size - 1, cb_depth + 1);
        if (more_data &lt; 0)
            return more_data;

        if (more_data &amp;&amp; x1 &lt; s-&gt;sps-&gt;width) {
            more_data = hls_coding_quadtree(s, x1, y0, log2_cb_size - 1, cb_depth + 1);
            if (more_data &lt; 0)
                return more_data;
        }
        if (more_data &amp;&amp; y1 &lt; s-&gt;sps-&gt;height) {
            more_data = hls_coding_quadtree(s, x0, y1, log2_cb_size - 1, cb_depth + 1);
            if (more_data &lt; 0)
                return more_data;
        }
        if (more_data &amp;&amp; x1 &lt; s-&gt;sps-&gt;width &amp;&amp;
            y1 &lt; s-&gt;sps-&gt;height) {
            more_data = hls_coding_quadtree(s, x1, y1, log2_cb_size - 1, cb_depth + 1);
            if (more_data &lt; 0)
                return more_data;
        }

        if(((x0 + (1&lt;&lt;log2_cb_size)) &amp; qp_block_mask) == 0 &amp;&amp;
            ((y0 + (1&lt;&lt;log2_cb_size)) &amp; qp_block_mask) == 0)
            lc-&gt;qPy_pred = lc-&gt;qp_y;

        if (more_data)
            return ((x1 + cb_size_split) &lt; s-&gt;sps-&gt;width ||
                    (y1 + cb_size_split) &lt; s-&gt;sps-&gt;height);
        else
            return 0;
    } else {

        /*
         * (x0, y0)
		 *     +--------+--------+
		 *     |                 |
		 *     |                 |
		 *     |                 |
		 *     +                 +
		 *     |                 |
		 *     |                 |
		 *     |                 |
		 *     +--------+--------+
         *
         */
    	//注意处理的是不可划分的CU单元
    	//处理CU单元-真正的解码
        ret = hls_coding_unit(s, x0, y0, log2_cb_size);
        if (ret &lt; 0)
            return ret;
        if ((!((x0 + cb_size) %
               (1 &lt;&lt; (s-&gt;sps-&gt;log2_ctb_size))) ||
             (x0 + cb_size &gt;= s-&gt;sps-&gt;width)) &amp;&amp;
            (!((y0 + cb_size) %
               (1 &lt;&lt; (s-&gt;sps-&gt;log2_ctb_size))) ||
             (y0 + cb_size &gt;= s-&gt;sps-&gt;height))) {
            int end_of_slice_flag = ff_hevc_end_of_slice_flag_decode(s);
            return !end_of_slice_flag;
        } else {
            return 1;
        }
    }

    return 0;
}
</pre><br /><p>从源代码可以看出，hls_coding_quadtree()首先调用ff_hevc_split_coding_unit_flag_decode()判断当前CU是否还需要划分。如果需要划分的话，就会递归调用4次hls_coding_quadtree()分别对4个子块继续进行四叉树解析；如果不需要划分，就会调用hls_coding_unit()对CU进行解码。总而言之，hls_coding_quadtree()会解析出来一个CTU中的所有CU，并且对每一个CU逐一调用hls_coding_unit()进行解码。一个CTU中CU的解码顺序如下图所示。图中a, b, c …即代表了的先后顺序。</p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150613173830752" alt="" /><br /></p><br /><h2>hls_coding_unit()</h2>hls_coding_unit()用于解码一个CU。该函数的定义如下所示。<br /><pre name="code" class="cpp">//处理CU单元-真正的解码
//注释和处理：雷霄骅
static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
{
	//CB大小
    int cb_size          = 1 &lt;&lt; log2_cb_size;
    HEVCLocalContext *lc = s-&gt;HEVClc;
    int log2_min_cb_size = s-&gt;sps-&gt;log2_min_cb_size;
    int length           = cb_size &gt;&gt; log2_min_cb_size;
    int min_cb_width     = s-&gt;sps-&gt;min_cb_width;
    //以最小的CB为单位（例如4x4）的时候，当前CB的位置——x坐标和y坐标
    int x_cb             = x0 &gt;&gt; log2_min_cb_size;
    int y_cb             = y0 &gt;&gt; log2_min_cb_size;
    int idx              = log2_cb_size - 2;
    int qp_block_mask    = (1&lt;&lt;(s-&gt;sps-&gt;log2_ctb_size - s-&gt;pps-&gt;diff_cu_qp_delta_depth)) - 1;
    int x, y, ret;

    //设置CU的属性值
    lc-&gt;cu.x                = x0;
    lc-&gt;cu.y                = y0;
    lc-&gt;cu.pred_mode        = MODE_INTRA;
    lc-&gt;cu.part_mode        = PART_2Nx2N;
    lc-&gt;cu.intra_split_flag = 0;

    SAMPLE_CTB(s-&gt;skip_flag, x_cb, y_cb) = 0;

    for (x = 0; x &lt; 4; x++)
        lc-&gt;pu.intra_pred_mode[x] = 1;
    if (s-&gt;pps-&gt;transquant_bypass_enable_flag) {
        lc-&gt;cu.cu_transquant_bypass_flag = ff_hevc_cu_transquant_bypass_flag_decode(s);
        if (lc-&gt;cu.cu_transquant_bypass_flag)
            set_deblocking_bypass(s, x0, y0, log2_cb_size);
    } else
        lc-&gt;cu.cu_transquant_bypass_flag = 0;

    if (s-&gt;sh.slice_type != I_SLICE) {
    	//Skip类型
        uint8_t skip_flag = ff_hevc_skip_flag_decode(s, x0, y0, x_cb, y_cb);
        //设置到skip_flag缓存中
        x = y_cb * min_cb_width + x_cb;
        for (y = 0; y &lt; length; y++) {
            memset(&amp;s-&gt;skip_flag[x], skip_flag, length);
            x += min_cb_width;
        }
        lc-&gt;cu.pred_mode = skip_flag ? MODE_SKIP : MODE_INTER;
    } else {
        x = y_cb * min_cb_width + x_cb;
        for (y = 0; y &lt; length; y++) {
            memset(&amp;s-&gt;skip_flag[x], 0, length);
            x += min_cb_width;
        }
    }

    if (SAMPLE_CTB(s-&gt;skip_flag, x_cb, y_cb)) {
        hls_prediction_unit(s, x0, y0, cb_size, cb_size, log2_cb_size, 0, idx);
        intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);

        if (!s-&gt;sh.disable_deblocking_filter_flag)
            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size);
    } else {
        int pcm_flag = 0;

        //读取预测模式（非 I Slice）
        if (s-&gt;sh.slice_type != I_SLICE)
            lc-&gt;cu.pred_mode = ff_hevc_pred_mode_decode(s);

        //不是帧内预测模式的时候
        //或者已经是最小CB的时候
        if (lc-&gt;cu.pred_mode != MODE_INTRA ||
            log2_cb_size == s-&gt;sps-&gt;log2_min_cb_size) {
        	//读取CU分割模式
            lc-&gt;cu.part_mode        = ff_hevc_part_mode_decode(s, log2_cb_size);
            lc-&gt;cu.intra_split_flag = lc-&gt;cu.part_mode == PART_NxN &amp;&amp;
                                      lc-&gt;cu.pred_mode == MODE_INTRA;
        }

        if (lc-&gt;cu.pred_mode == MODE_INTRA) {
        	//帧内预测模式

        	//PCM方式编码，不常见
            if (lc-&gt;cu.part_mode == PART_2Nx2N &amp;&amp; s-&gt;sps-&gt;pcm_enabled_flag &amp;&amp;
                log2_cb_size &gt;= s-&gt;sps-&gt;pcm.log2_min_pcm_cb_size &amp;&amp;
                log2_cb_size &lt;= s-&gt;sps-&gt;pcm.log2_max_pcm_cb_size) {
                pcm_flag = ff_hevc_pcm_flag_decode(s);
            }
            if (pcm_flag) {
                intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);
                ret = hls_pcm_sample(s, x0, y0, log2_cb_size);
                if (s-&gt;sps-&gt;pcm.loop_filter_disable_flag)
                    set_deblocking_bypass(s, x0, y0, log2_cb_size);

                if (ret &lt; 0)
                    return ret;
            } else {
            	//帧内预测
                intra_prediction_unit(s, x0, y0, log2_cb_size);
            }
        } else {
        	//帧间预测模式
            intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);

            //帧间模式一共有8种划分模式

            switch (lc-&gt;cu.part_mode) {
            case PART_2Nx2N:
            	/*
				 * PART_2Nx2N:
				 * +--------+--------+
				 * |                 |
				 * |                 |
				 * |                 |
				 * +        +        +
				 * |                 |
				 * |                 |
				 * |                 |
				 * +--------+--------+
            	 */
            	//处理PU单元-运动补偿
                hls_prediction_unit(s, x0, y0, cb_size, cb_size, log2_cb_size, 0, idx);
                break;
            case PART_2NxN:
                /*
    			 * PART_2NxN:
    			 * +--------+--------+
    			 * |                 |
    			 * |                 |
    			 * |                 |
    			 * +--------+--------+
    			 * |                 |
    			 * |                 |
    			 * |                 |
    			 * +--------+--------+
    			 *
                 */
            	/*
            	 * hls_prediction_unit()参数：
            	 * x0 : PU左上角x坐标
            	 * y0 : PU左上角y坐标
            	 * nPbW : PU宽度
            	 * nPbH : PU高度
            	 * log2_cb_size : CB大小取log2()的值
            	 * partIdx : PU的索引号-分成4个块的时候取0-3，分成两个块的时候取0和1
            	 */
            	//上
                hls_prediction_unit(s, x0, y0,               cb_size, cb_size / 2, log2_cb_size, 0, idx);
                //下
                hls_prediction_unit(s, x0, y0 + cb_size / 2, cb_size, cb_size / 2, log2_cb_size, 1, idx);
                break;
            case PART_Nx2N:
                /*
    			 * PART_Nx2N:
    			 * +--------+--------+
    			 * |        |        |
    			 * |        |        |
    			 * |        |        |
    			 * +        +        +
    			 * |        |        |
    			 * |        |        |
    			 * |        |        |
    			 * +--------+--------+
    			 *
                 */
            	//左
                hls_prediction_unit(s, x0,               y0, cb_size / 2, cb_size, log2_cb_size, 0, idx - 1);
                //右
                hls_prediction_unit(s, x0 + cb_size / 2, y0, cb_size / 2, cb_size, log2_cb_size, 1, idx - 1);
                break;
            case PART_2NxnU:
                /*
    			 * PART_2NxnU (Upper) :
    			 * +--------+--------+
    			 * |                 |
    			 * +--------+--------+
    			 * |                 |
    			 * +        +        +
    			 * |                 |
    			 * |                 |
    			 * |                 |
    			 * +--------+--------+
    			 *
                 */
            	//上
                hls_prediction_unit(s, x0, y0,               cb_size, cb_size     / 4, log2_cb_size, 0, idx);
                //下
                hls_prediction_unit(s, x0, y0 + cb_size / 4, cb_size, cb_size * 3 / 4, log2_cb_size, 1, idx);
                break;
            case PART_2NxnD:
                /*
    			 * PART_2NxnD (Down) :
    			 * +--------+--------+
    			 * |                 |
    			 * |                 |
    			 * |                 |
    			 * +        +        +
    			 * |                 |
    			 * +--------+--------+
    			 * |                 |
    			 * +--------+--------+
    			 *
                 */
            	//上
                hls_prediction_unit(s, x0, y0,                   cb_size, cb_size * 3 / 4, log2_cb_size, 0, idx);
                //下
                hls_prediction_unit(s, x0, y0 + cb_size * 3 / 4, cb_size, cb_size     / 4, log2_cb_size, 1, idx);
                break;
            case PART_nLx2N:
                /*
    			 * PART_nLx2N (Left):
    			 * +----+---+--------+
    			 * |    |            |
    			 * |    |            |
    			 * |    |            |
    			 * +    +   +        +
    			 * |    |            |
    			 * |    |            |
    			 * |    |            |
    			 * +----+---+--------+
    			 *
                 */
            	//左
                hls_prediction_unit(s, x0,               y0, cb_size     / 4, cb_size, log2_cb_size, 0, idx - 2);
                //右
                hls_prediction_unit(s, x0 + cb_size / 4, y0, cb_size * 3 / 4, cb_size, log2_cb_size, 1, idx - 2);
                break;
            case PART_nRx2N:
                /*
    			 * PART_nRx2N (Right):
    			 * +--------+---+----+
    			 * |            |    |
    			 * |            |    |
    			 * |            |    |
    			 * +        +   +    +
    			 * |            |    |
    			 * |            |    |
    			 * |            |    |
    			 * +--------+---+----+
    			 *
                 */
            	//左
                hls_prediction_unit(s, x0,                   y0, cb_size * 3 / 4, cb_size, log2_cb_size, 0, idx - 2);
                //右
                hls_prediction_unit(s, x0 + cb_size * 3 / 4, y0, cb_size     / 4, cb_size, log2_cb_size, 1, idx - 2);
                break;
            case PART_NxN:
                /*
    			 * PART_NxN:
    			 * +--------+--------+
    			 * |        |        |
    			 * |        |        |
    			 * |        |        |
    			 * +--------+--------+
    			 * |        |        |
    			 * |        |        |
    			 * |        |        |
    			 * +--------+--------+
    			 *
                 */
                hls_prediction_unit(s, x0,               y0,               cb_size / 2, cb_size / 2, log2_cb_size, 0, idx - 1);
                hls_prediction_unit(s, x0 + cb_size / 2, y0,               cb_size / 2, cb_size / 2, log2_cb_size, 1, idx - 1);
                hls_prediction_unit(s, x0,               y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 2, idx - 1);
                hls_prediction_unit(s, x0 + cb_size / 2, y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 3, idx - 1);
                break;
            }
        }

        if (!pcm_flag) {
            int rqt_root_cbf = 1;

            if (lc-&gt;cu.pred_mode != MODE_INTRA &amp;&amp;
                !(lc-&gt;cu.part_mode == PART_2Nx2N &amp;&amp; lc-&gt;pu.merge_flag)) {
                rqt_root_cbf = ff_hevc_no_residual_syntax_flag_decode(s);
            }
            if (rqt_root_cbf) {
                const static int cbf[2] = { 0 };
                lc-&gt;cu.max_trafo_depth = lc-&gt;cu.pred_mode == MODE_INTRA ?
                                         s-&gt;sps-&gt;max_transform_hierarchy_depth_intra + lc-&gt;cu.intra_split_flag :
                                         s-&gt;sps-&gt;max_transform_hierarchy_depth_inter;
                //处理TU四叉树
                ret = hls_transform_tree(s, x0, y0, x0, y0, x0, y0,
                                         log2_cb_size,
                                         log2_cb_size, 0, 0, cbf, cbf);
                if (ret &lt; 0)
                    return ret;
            } else {
                if (!s-&gt;sh.disable_deblocking_filter_flag)
                    ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size);
            }
        }
    }

    if (s-&gt;pps-&gt;cu_qp_delta_enabled_flag &amp;&amp; lc-&gt;tu.is_cu_qp_delta_coded == 0)
        ff_hevc_set_qPy(s, x0, y0, log2_cb_size);

    x = y_cb * min_cb_width + x_cb;
    for (y = 0; y &lt; length; y++) {
        memset(&amp;s-&gt;qp_y_tab[x], lc-&gt;qp_y, length);
        x += min_cb_width;
    }

    if(((x0 + (1&lt;&lt;log2_cb_size)) &amp; qp_block_mask) == 0 &amp;&amp;
       ((y0 + (1&lt;&lt;log2_cb_size)) &amp; qp_block_mask) == 0) {
        lc-&gt;qPy_pred = lc-&gt;qp_y;
    }

    set_ct_depth(s, x0, y0, log2_cb_size, lc-&gt;ct_depth);

    return 0;
}
</pre><br />从源代码可以看出，hls_coding_unit()主要进行了两个方面的处理：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用hls_prediction_unit()处理PU。<br />（2）调用hls_transform_tree()处理TU树。</blockquote>本文分析第二个函数hls_transform_tree()中相关的代码。<br /><br /><h2>hls_transform_tree()</h2>hls_transform_tree()用于解析TU四叉树句法。该函数的定义如下所示。<br /><pre name="code" class="cpp">//处理TU四叉树
static int hls_transform_tree(HEVCContext *s, int x0, int y0,
                              int xBase, int yBase, int cb_xBase, int cb_yBase,
                              int log2_cb_size, int log2_trafo_size,
                              int trafo_depth, int blk_idx,
                              const int *base_cbf_cb, const int *base_cbf_cr)
{
    HEVCLocalContext *lc = s-&gt;HEVClc;
    uint8_t split_transform_flag;
    int cbf_cb[2];
    int cbf_cr[2];
    int ret;

    cbf_cb[0] = base_cbf_cb[0];
    cbf_cb[1] = base_cbf_cb[1];
    cbf_cr[0] = base_cbf_cr[0];
    cbf_cr[1] = base_cbf_cr[1];

    if (lc-&gt;cu.intra_split_flag) {
        if (trafo_depth == 1) {
            lc-&gt;tu.intra_pred_mode   = lc-&gt;pu.intra_pred_mode[blk_idx];
            if (s-&gt;sps-&gt;chroma_format_idc == 3) {
                lc-&gt;tu.intra_pred_mode_c = lc-&gt;pu.intra_pred_mode_c[blk_idx];
                lc-&gt;tu.chroma_mode_c     = lc-&gt;pu.chroma_mode_c[blk_idx];
            } else {
                lc-&gt;tu.intra_pred_mode_c = lc-&gt;pu.intra_pred_mode_c[0];
                lc-&gt;tu.chroma_mode_c     = lc-&gt;pu.chroma_mode_c[0];
            }
        }
    } else {
        lc-&gt;tu.intra_pred_mode   = lc-&gt;pu.intra_pred_mode[0];
        lc-&gt;tu.intra_pred_mode_c = lc-&gt;pu.intra_pred_mode_c[0];
        lc-&gt;tu.chroma_mode_c     = lc-&gt;pu.chroma_mode_c[0];
    }

    if (log2_trafo_size &lt;= s-&gt;sps-&gt;log2_max_trafo_size &amp;&amp;
        log2_trafo_size &gt;  s-&gt;sps-&gt;log2_min_tb_size    &amp;&amp;
        trafo_depth     &lt; lc-&gt;cu.max_trafo_depth       &amp;&amp;
        !(lc-&gt;cu.intra_split_flag &amp;&amp; trafo_depth == 0)) {
        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);
    } else {
        int inter_split = s-&gt;sps-&gt;max_transform_hierarchy_depth_inter == 0 &amp;&amp;
                          lc-&gt;cu.pred_mode == MODE_INTER &amp;&amp;
                          lc-&gt;cu.part_mode != PART_2Nx2N &amp;&amp;
                          trafo_depth == 0;
    	//split_transform_flag标记当前TU是否要进行四叉树划分
    	//为1则需要划分为4个大小相等的，为0则不再划分
        split_transform_flag = log2_trafo_size &gt; s-&gt;sps-&gt;log2_max_trafo_size ||
                               (lc-&gt;cu.intra_split_flag &amp;&amp; trafo_depth == 0) ||
                               inter_split;
    }

    if (log2_trafo_size &gt; 2 || s-&gt;sps-&gt;chroma_format_idc == 3) {
        if (trafo_depth == 0 || cbf_cb[0]) {
            cbf_cb[0] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
            if (s-&gt;sps-&gt;chroma_format_idc == 2 &amp;&amp; (!split_transform_flag || log2_trafo_size == 3)) {
                cbf_cb[1] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
            }
        }

        if (trafo_depth == 0 || cbf_cr[0]) {
            cbf_cr[0] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
            if (s-&gt;sps-&gt;chroma_format_idc == 2 &amp;&amp; (!split_transform_flag || log2_trafo_size == 3)) {
                cbf_cr[1] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
            }
        }
    }

    //如果当前TU要进行四叉树划分
    if (split_transform_flag) {
        const int trafo_size_split = 1 &lt;&lt; (log2_trafo_size - 1);
        const int x1 = x0 + trafo_size_split;
        const int y1 = y0 + trafo_size_split;

#define SUBDIVIDE(x, y, idx)                                                    \
do {                                                                            \
    ret = hls_transform_tree(s, x, y, x0, y0, cb_xBase, cb_yBase, log2_cb_size, \
                             log2_trafo_size - 1, trafo_depth + 1, idx,         \
                             cbf_cb, cbf_cr);                                   \
    if (ret &lt; 0)                                                                \
        return ret;                                                             \
} while (0)
        //递归调用
        SUBDIVIDE(x0, y0, 0);
        SUBDIVIDE(x1, y0, 1);
        SUBDIVIDE(x0, y1, 2);
        SUBDIVIDE(x1, y1, 3);

#undef SUBDIVIDE
    } else {
        int min_tu_size      = 1 &lt;&lt; s-&gt;sps-&gt;log2_min_tb_size;
        int log2_min_tu_size = s-&gt;sps-&gt;log2_min_tb_size;
        int min_tu_width     = s-&gt;sps-&gt;min_tb_width;
        int cbf_luma         = 1;

        if (lc-&gt;cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||
            cbf_cb[0] || cbf_cr[0] ||
            (s-&gt;sps-&gt;chroma_format_idc == 2 &amp;&amp; (cbf_cb[1] || cbf_cr[1]))) {
            cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);
        }
        //处理TU-帧内预测、DCT反变换
        ret = hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,
                                 log2_cb_size, log2_trafo_size,
                                 blk_idx, cbf_luma, cbf_cb, cbf_cr);
        if (ret &lt; 0)
            return ret;
        // TODO: store cbf_luma somewhere else
        if (cbf_luma) {
            int i, j;
            for (i = 0; i &lt; (1 &lt;&lt; log2_trafo_size); i += min_tu_size)
                for (j = 0; j &lt; (1 &lt;&lt; log2_trafo_size); j += min_tu_size) {
                    int x_tu = (x0 + j) &gt;&gt; log2_min_tu_size;
                    int y_tu = (y0 + i) &gt;&gt; log2_min_tu_size;
                    s-&gt;cbf_luma[y_tu * min_tu_width + x_tu] = 1;
                }
        }
        if (!s-&gt;sh.disable_deblocking_filter_flag) {
            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size);
            if (s-&gt;pps-&gt;transquant_bypass_enable_flag &amp;&amp;
                lc-&gt;cu.cu_transquant_bypass_flag)
                set_deblocking_bypass(s, x0, y0, log2_trafo_size);
        }
    }
    return 0;
}
</pre><br />从源代码可以看出，hls_transform_tree()首先调用ff_hevc_split_transform_flag_decode()判断当前TU是否还需要划分。如果需要划分的话，就会递归调用4次hls_transform_tree()分别对4个子块继续进行四叉树解析；如果不需要划分，就会调用hls_transform_unit()对TU进行解码。总而言之，hls_transform_tree()会解析出来一个TU树中的所有TU，并且对每一个TU逐一调用hls_transform_unit()进行解码。<br /><br /><h2>hls_transform_unit()</h2>hls_transform_unit()用于解码一个TU，该函数的定义如下所示。<br /><pre name="code" class="cpp">//处理TU-帧内预测、DCT反变换
static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                              int xBase, int yBase, int cb_xBase, int cb_yBase,
                              int log2_cb_size, int log2_trafo_size,
                              int blk_idx, int cbf_luma, int *cbf_cb, int *cbf_cr)
{
    HEVCLocalContext *lc = s-&gt;HEVClc;
    const int log2_trafo_size_c = log2_trafo_size - s-&gt;sps-&gt;hshift[1];
    int i;

    if (lc-&gt;cu.pred_mode == MODE_INTRA) {
        int trafo_size = 1 &lt;&lt; log2_trafo_size;
        ff_hevc_set_neighbour_available(s, x0, y0, trafo_size, trafo_size);

        //注意：帧内预测也是在这里完成
        //帧内预测
        //log2_trafo_size为当前TU大小取log2()之后的值
        s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, x0, y0, 0);
    }

    if (cbf_luma || cbf_cb[0] || cbf_cr[0] ||
        (s-&gt;sps-&gt;chroma_format_idc == 2 &amp;&amp; (cbf_cb[1] || cbf_cr[1]))) {
        int scan_idx   = SCAN_DIAG;
        int scan_idx_c = SCAN_DIAG;
        int cbf_chroma = cbf_cb[0] || cbf_cr[0] ||
                         (s-&gt;sps-&gt;chroma_format_idc == 2 &amp;&amp;
                         (cbf_cb[1] || cbf_cr[1]));

        if (s-&gt;pps-&gt;cu_qp_delta_enabled_flag &amp;&amp; !lc-&gt;tu.is_cu_qp_delta_coded) {
            lc-&gt;tu.cu_qp_delta = ff_hevc_cu_qp_delta_abs(s);
            if (lc-&gt;tu.cu_qp_delta != 0)
                if (ff_hevc_cu_qp_delta_sign_flag(s) == 1)
                    lc-&gt;tu.cu_qp_delta = -lc-&gt;tu.cu_qp_delta;
            lc-&gt;tu.is_cu_qp_delta_coded = 1;

            if (lc-&gt;tu.cu_qp_delta &lt; -(26 + s-&gt;sps-&gt;qp_bd_offset / 2) ||
                lc-&gt;tu.cu_qp_delta &gt;  (25 + s-&gt;sps-&gt;qp_bd_offset / 2)) {
                av_log(s-&gt;avctx, AV_LOG_ERROR,
                       &quot;The cu_qp_delta %d is outside the valid range &quot;
                       &quot;[%d, %d].\n&quot;,
                       lc-&gt;tu.cu_qp_delta,
                       -(26 + s-&gt;sps-&gt;qp_bd_offset / 2),
                        (25 + s-&gt;sps-&gt;qp_bd_offset / 2));
                return AVERROR_INVALIDDATA;
            }

            ff_hevc_set_qPy(s, cb_xBase, cb_yBase, log2_cb_size);
        }

        if (s-&gt;sh.cu_chroma_qp_offset_enabled_flag &amp;&amp; cbf_chroma &amp;&amp;
            !lc-&gt;cu.cu_transquant_bypass_flag  &amp;&amp;  !lc-&gt;tu.is_cu_chroma_qp_offset_coded) {
            int cu_chroma_qp_offset_flag = ff_hevc_cu_chroma_qp_offset_flag(s);
            if (cu_chroma_qp_offset_flag) {
                int cu_chroma_qp_offset_idx  = 0;
                if (s-&gt;pps-&gt;chroma_qp_offset_list_len_minus1 &gt; 0) {
                    cu_chroma_qp_offset_idx = ff_hevc_cu_chroma_qp_offset_idx(s);
                    av_log(s-&gt;avctx, AV_LOG_ERROR,
                        &quot;cu_chroma_qp_offset_idx not yet tested.\n&quot;);
                }
                lc-&gt;tu.cu_qp_offset_cb = s-&gt;pps-&gt;cb_qp_offset_list[cu_chroma_qp_offset_idx];
                lc-&gt;tu.cu_qp_offset_cr = s-&gt;pps-&gt;cr_qp_offset_list[cu_chroma_qp_offset_idx];
            } else {
                lc-&gt;tu.cu_qp_offset_cb = 0;
                lc-&gt;tu.cu_qp_offset_cr = 0;
            }
            lc-&gt;tu.is_cu_chroma_qp_offset_coded = 1;
        }

        if (lc-&gt;cu.pred_mode == MODE_INTRA &amp;&amp; log2_trafo_size &lt; 4) {
            if (lc-&gt;tu.intra_pred_mode &gt;= 6 &amp;&amp;
                lc-&gt;tu.intra_pred_mode &lt;= 14) {
                scan_idx = SCAN_VERT;
            } else if (lc-&gt;tu.intra_pred_mode &gt;= 22 &amp;&amp;
                       lc-&gt;tu.intra_pred_mode &lt;= 30) {
                scan_idx = SCAN_HORIZ;
            }

            if (lc-&gt;tu.intra_pred_mode_c &gt;=  6 &amp;&amp;
                lc-&gt;tu.intra_pred_mode_c &lt;= 14) {
                scan_idx_c = SCAN_VERT;
            } else if (lc-&gt;tu.intra_pred_mode_c &gt;= 22 &amp;&amp;
                       lc-&gt;tu.intra_pred_mode_c &lt;= 30) {
                scan_idx_c = SCAN_HORIZ;
            }
        }

        lc-&gt;tu.cross_pf = 0;

        //读取残差数据，进行反量化，DCT反变换

        //亮度Y
        if (cbf_luma)
            ff_hevc_hls_residual_coding(s, x0, y0, log2_trafo_size, scan_idx, 0);//最后1个参数为颜色分量号

        if (log2_trafo_size &gt; 2 || s-&gt;sps-&gt;chroma_format_idc == 3) {
            int trafo_size_h = 1 &lt;&lt; (log2_trafo_size_c + s-&gt;sps-&gt;hshift[1]);
            int trafo_size_v = 1 &lt;&lt; (log2_trafo_size_c + s-&gt;sps-&gt;vshift[1]);
            lc-&gt;tu.cross_pf  = (s-&gt;pps-&gt;cross_component_prediction_enabled_flag &amp;&amp; cbf_luma &amp;&amp;
                                (lc-&gt;cu.pred_mode == MODE_INTER ||
                                 (lc-&gt;tu.chroma_mode_c ==  4)));

            if (lc-&gt;tu.cross_pf) {
                hls_cross_component_pred(s, 0);
            }
            //色度U
            for (i = 0; i &lt; (s-&gt;sps-&gt;chroma_format_idc == 2 ? 2 : 1); i++) {
                if (lc-&gt;cu.pred_mode == MODE_INTRA) {
                    ff_hevc_set_neighbour_available(s, x0, y0 + (i &lt;&lt; log2_trafo_size_c), trafo_size_h, trafo_size_v);
                    s-&gt;hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i &lt;&lt; log2_trafo_size_c), 1);
                }
                if (cbf_cb[i])
                    ff_hevc_hls_residual_coding(s, x0, y0 + (i &lt;&lt; log2_trafo_size_c),
                                                log2_trafo_size_c, scan_idx_c, 1);//最后1个参数为颜色分量号
                else
                    if (lc-&gt;tu.cross_pf) {
                        ptrdiff_t stride = s-&gt;frame-&gt;linesize[1];
                        int hshift = s-&gt;sps-&gt;hshift[1];
                        int vshift = s-&gt;sps-&gt;vshift[1];
                        int16_t *coeffs_y = (int16_t*)lc-&gt;edge_emu_buffer;
                        int16_t *coeffs   = (int16_t*)lc-&gt;edge_emu_buffer2;
                        int size = 1 &lt;&lt; log2_trafo_size_c;

                        uint8_t *dst = &amp;s-&gt;frame-&gt;data[1][(y0 &gt;&gt; vshift) * stride +
                                                              ((x0 &gt;&gt; hshift) &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
                        for (i = 0; i &lt; (size * size); i++) {
                            coeffs[i] = ((lc-&gt;tu.res_scale_val * coeffs_y[i]) &gt;&gt; 3);
                        }
                        //叠加残差数据
                        s-&gt;hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
                    }
            }

            if (lc-&gt;tu.cross_pf) {
                hls_cross_component_pred(s, 1);
            }
            //色度V
            for (i = 0; i &lt; (s-&gt;sps-&gt;chroma_format_idc == 2 ? 2 : 1); i++) {
                if (lc-&gt;cu.pred_mode == MODE_INTRA) {
                    ff_hevc_set_neighbour_available(s, x0, y0 + (i &lt;&lt; log2_trafo_size_c), trafo_size_h, trafo_size_v);
                    s-&gt;hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i &lt;&lt; log2_trafo_size_c), 2);
                }
                //色度Cr
                if (cbf_cr[i])
                    ff_hevc_hls_residual_coding(s, x0, y0 + (i &lt;&lt; log2_trafo_size_c),
                                                log2_trafo_size_c, scan_idx_c, 2);
                else
                    if (lc-&gt;tu.cross_pf) {
                        ptrdiff_t stride = s-&gt;frame-&gt;linesize[2];
                        int hshift = s-&gt;sps-&gt;hshift[2];
                        int vshift = s-&gt;sps-&gt;vshift[2];
                        int16_t *coeffs_y = (int16_t*)lc-&gt;edge_emu_buffer;
                        int16_t *coeffs   = (int16_t*)lc-&gt;edge_emu_buffer2;
                        int size = 1 &lt;&lt; log2_trafo_size_c;

                        uint8_t *dst = &amp;s-&gt;frame-&gt;data[2][(y0 &gt;&gt; vshift) * stride +
                                                          ((x0 &gt;&gt; hshift) &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
                        for (i = 0; i &lt; (size * size); i++) {
                            coeffs[i] = ((lc-&gt;tu.res_scale_val * coeffs_y[i]) &gt;&gt; 3);
                        }
                        s-&gt;hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
                    }
            }
        } else if (blk_idx == 3) {
            int trafo_size_h = 1 &lt;&lt; (log2_trafo_size + 1);
            int trafo_size_v = 1 &lt;&lt; (log2_trafo_size + s-&gt;sps-&gt;vshift[1]);
            for (i = 0; i &lt; (s-&gt;sps-&gt;chroma_format_idc == 2 ? 2 : 1); i++) {
                if (lc-&gt;cu.pred_mode == MODE_INTRA) {
                    ff_hevc_set_neighbour_available(s, xBase, yBase + (i &lt;&lt; log2_trafo_size),
                                                    trafo_size_h, trafo_size_v);
                    s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i &lt;&lt; log2_trafo_size), 1);
                }
                if (cbf_cb[i])
                    ff_hevc_hls_residual_coding(s, xBase, yBase + (i &lt;&lt; log2_trafo_size),
                                                log2_trafo_size, scan_idx_c, 1);
            }
            for (i = 0; i &lt; (s-&gt;sps-&gt;chroma_format_idc == 2 ? 2 : 1); i++) {
                if (lc-&gt;cu.pred_mode == MODE_INTRA) {
                    ff_hevc_set_neighbour_available(s, xBase, yBase + (i &lt;&lt; log2_trafo_size),
                                                trafo_size_h, trafo_size_v);
                    s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i &lt;&lt; log2_trafo_size), 2);
                }
                if (cbf_cr[i])
                    ff_hevc_hls_residual_coding(s, xBase, yBase + (i &lt;&lt; log2_trafo_size),
                                                log2_trafo_size, scan_idx_c, 2);
            }
        }
    } else if (lc-&gt;cu.pred_mode == MODE_INTRA) {
        if (log2_trafo_size &gt; 2 || s-&gt;sps-&gt;chroma_format_idc == 3) {
            int trafo_size_h = 1 &lt;&lt; (log2_trafo_size_c + s-&gt;sps-&gt;hshift[1]);
            int trafo_size_v = 1 &lt;&lt; (log2_trafo_size_c + s-&gt;sps-&gt;vshift[1]);
            ff_hevc_set_neighbour_available(s, x0, y0, trafo_size_h, trafo_size_v);
            s-&gt;hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 1);
            s-&gt;hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 2);
            if (s-&gt;sps-&gt;chroma_format_idc == 2) {
                ff_hevc_set_neighbour_available(s, x0, y0 + (1 &lt;&lt; log2_trafo_size_c),
                                                trafo_size_h, trafo_size_v);
                s-&gt;hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 &lt;&lt; log2_trafo_size_c), 1);
                s-&gt;hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 &lt;&lt; log2_trafo_size_c), 2);
            }
        } else if (blk_idx == 3) {
            int trafo_size_h = 1 &lt;&lt; (log2_trafo_size + 1);
            int trafo_size_v = 1 &lt;&lt; (log2_trafo_size + s-&gt;sps-&gt;vshift[1]);
            ff_hevc_set_neighbour_available(s, xBase, yBase,
                                            trafo_size_h, trafo_size_v);
            s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 1);
            s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 2);
            if (s-&gt;sps-&gt;chroma_format_idc == 2) {
                ff_hevc_set_neighbour_available(s, xBase, yBase + (1 &lt;&lt; (log2_trafo_size)),
                                                trafo_size_h, trafo_size_v);
                s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 &lt;&lt; (log2_trafo_size)), 1);
                s-&gt;hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 &lt;&lt; (log2_trafo_size)), 2);
            }
        }
    }

    return 0;
}
</pre><br />从源代码可以看出，如果是帧内CU的话，hls_transform_unit()会调用HEVCPredContext的intra_pred[]()汇编函数进行帧内预测；然后不论帧内预测还是帧间CU都会调用ff_hevc_hls_residual_coding()解码残差数据，并叠加在预测数据上。<br /><br /><h2>ff_hevc_hls_residual_coding()</h2>ff_hevc_hls_residual_coding()用于读取残差数据并进行DCT反变换。该函数的定义如下所示。<br /><pre name="code" class="cpp">//读取残差数据，DCT反变换
void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                                int log2_trafo_size, enum ScanType scan_idx,
                                int c_idx)
{
#define GET_COORD(offset, n)                                    \
    do {                                                        \
        x_c = (x_cg &lt;&lt; 2) + scan_x_off[n];                      \
        y_c = (y_cg &lt;&lt; 2) + scan_y_off[n];                      \
    } while (0)
    HEVCLocalContext *lc = s-&gt;HEVClc;
    int transform_skip_flag = 0;

    int last_significant_coeff_x, last_significant_coeff_y;
    int last_scan_pos;
    int n_end;
    int num_coeff = 0;
    int greater1_ctx = 1;

    int num_last_subset;
    int x_cg_last_sig, y_cg_last_sig;

    const uint8_t *scan_x_cg, *scan_y_cg, *scan_x_off, *scan_y_off;

    ptrdiff_t stride = s-&gt;frame-&gt;linesize[c_idx];
    int hshift = s-&gt;sps-&gt;hshift[c_idx];
    int vshift = s-&gt;sps-&gt;vshift[c_idx];
    uint8_t *dst = &amp;s-&gt;frame-&gt;data[c_idx][(y0 &gt;&gt; vshift) * stride +
                                          ((x0 &gt;&gt; hshift) &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
    int16_t *coeffs = (int16_t*)(c_idx ? lc-&gt;edge_emu_buffer2 : lc-&gt;edge_emu_buffer);
    uint8_t significant_coeff_group_flag[8][8] = {{0}};
    int explicit_rdpcm_flag = 0;
    int explicit_rdpcm_dir_flag;

    int trafo_size = 1 &lt;&lt; log2_trafo_size;
    int i;
    int qp,shift,add,scale,scale_m;
    const uint8_t level_scale[] = { 40, 45, 51, 57, 64, 72 };
    const uint8_t *scale_matrix = NULL;
    uint8_t dc_scale;
    int pred_mode_intra = (c_idx == 0) ? lc-&gt;tu.intra_pred_mode :
                                         lc-&gt;tu.intra_pred_mode_c;

    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));

    // Derive QP for dequant
    if (!lc-&gt;cu.cu_transquant_bypass_flag) {
        static const int qp_c[] = { 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37 };
        static const uint8_t rem6[51 + 4 * 6 + 1] = {
            0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
            3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
            0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,
            4, 5, 0, 1, 2, 3, 4, 5, 0, 1
        };

        static const uint8_t div6[51 + 4 * 6 + 1] = {
            0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,
            3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,
            7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10,
            10, 10, 11, 11, 11, 11, 11, 11, 12, 12
        };
        int qp_y = lc-&gt;qp_y;

        if (s-&gt;pps-&gt;transform_skip_enabled_flag &amp;&amp;
            log2_trafo_size &lt;= s-&gt;pps-&gt;log2_max_transform_skip_block_size) {
            transform_skip_flag = ff_hevc_transform_skip_flag_decode(s, c_idx);
        }

        if (c_idx == 0) {
            qp = qp_y + s-&gt;sps-&gt;qp_bd_offset;
        } else {
            int qp_i, offset;

            if (c_idx == 1)
                offset = s-&gt;pps-&gt;cb_qp_offset + s-&gt;sh.slice_cb_qp_offset +
                         lc-&gt;tu.cu_qp_offset_cb;
            else
                offset = s-&gt;pps-&gt;cr_qp_offset + s-&gt;sh.slice_cr_qp_offset +
                         lc-&gt;tu.cu_qp_offset_cr;

            qp_i = av_clip(qp_y + offset, - s-&gt;sps-&gt;qp_bd_offset, 57);
            if (s-&gt;sps-&gt;chroma_format_idc == 1) {
                if (qp_i &lt; 30)
                    qp = qp_i;
                else if (qp_i &gt; 43)
                    qp = qp_i - 6;
                else
                    qp = qp_c[qp_i - 30];
            } else {
                if (qp_i &gt; 51)
                    qp = 51;
                else
                    qp = qp_i;
            }

            qp += s-&gt;sps-&gt;qp_bd_offset;
        }

        shift    = s-&gt;sps-&gt;bit_depth + log2_trafo_size - 5;
        add      = 1 &lt;&lt; (shift-1);
        scale    = level_scale[rem6[qp]] &lt;&lt; (div6[qp]);
        scale_m  = 16; // default when no custom scaling lists.
        dc_scale = 16;

        if (s-&gt;sps-&gt;scaling_list_enable_flag &amp;&amp; !(transform_skip_flag &amp;&amp; log2_trafo_size &gt; 2)) {
            const ScalingList *sl = s-&gt;pps-&gt;scaling_list_data_present_flag ?
            &amp;s-&gt;pps-&gt;scaling_list : &amp;s-&gt;sps-&gt;scaling_list;
            int matrix_id = lc-&gt;cu.pred_mode != MODE_INTRA;

            matrix_id = 3 * matrix_id + c_idx;

            scale_matrix = sl-&gt;sl[log2_trafo_size - 2][matrix_id];
            if (log2_trafo_size &gt;= 4)
                dc_scale = sl-&gt;sl_dc[log2_trafo_size - 4][matrix_id];
        }
    } else {
        shift        = 0;
        add          = 0;
        scale        = 0;
        dc_scale     = 0;
    }

    if (lc-&gt;cu.pred_mode == MODE_INTER &amp;&amp; s-&gt;sps-&gt;explicit_rdpcm_enabled_flag &amp;&amp;
        (transform_skip_flag || lc-&gt;cu.cu_transquant_bypass_flag)) {
        explicit_rdpcm_flag = explicit_rdpcm_flag_decode(s, c_idx);
        if (explicit_rdpcm_flag) {
            explicit_rdpcm_dir_flag = explicit_rdpcm_dir_flag_decode(s, c_idx);
        }
    }

    last_significant_coeff_xy_prefix_decode(s, c_idx, log2_trafo_size,
                                           &amp;last_significant_coeff_x, &amp;last_significant_coeff_y);

    if (last_significant_coeff_x &gt; 3) {
        int suffix = last_significant_coeff_suffix_decode(s, last_significant_coeff_x);
        last_significant_coeff_x = (1 &lt;&lt; ((last_significant_coeff_x &gt;&gt; 1) - 1)) *
        (2 + (last_significant_coeff_x &amp; 1)) +
        suffix;
    }

    if (last_significant_coeff_y &gt; 3) {
        int suffix = last_significant_coeff_suffix_decode(s, last_significant_coeff_y);
        last_significant_coeff_y = (1 &lt;&lt; ((last_significant_coeff_y &gt;&gt; 1) - 1)) *
        (2 + (last_significant_coeff_y &amp; 1)) +
        suffix;
    }

    if (scan_idx == SCAN_VERT)
        FFSWAP(int, last_significant_coeff_x, last_significant_coeff_y);

    x_cg_last_sig = last_significant_coeff_x &gt;&gt; 2;
    y_cg_last_sig = last_significant_coeff_y &gt;&gt; 2;

    switch (scan_idx) {
    case SCAN_DIAG: {
        int last_x_c = last_significant_coeff_x &amp; 3;
        int last_y_c = last_significant_coeff_y &amp; 3;

        scan_x_off = ff_hevc_diag_scan4x4_x;
        scan_y_off = ff_hevc_diag_scan4x4_y;
        num_coeff = diag_scan4x4_inv[last_y_c][last_x_c];
        if (trafo_size == 4) {
            scan_x_cg = scan_1x1;
            scan_y_cg = scan_1x1;
        } else if (trafo_size == 8) {
            num_coeff += diag_scan2x2_inv[y_cg_last_sig][x_cg_last_sig] &lt;&lt; 4;
            scan_x_cg = diag_scan2x2_x;
            scan_y_cg = diag_scan2x2_y;
        } else if (trafo_size == 16) {
            num_coeff += diag_scan4x4_inv[y_cg_last_sig][x_cg_last_sig] &lt;&lt; 4;
            scan_x_cg = ff_hevc_diag_scan4x4_x;
            scan_y_cg = ff_hevc_diag_scan4x4_y;
        } else { // trafo_size == 32
            num_coeff += diag_scan8x8_inv[y_cg_last_sig][x_cg_last_sig] &lt;&lt; 4;
            scan_x_cg = ff_hevc_diag_scan8x8_x;
            scan_y_cg = ff_hevc_diag_scan8x8_y;
        }
        break;
    }
    case SCAN_HORIZ:
        scan_x_cg = horiz_scan2x2_x;
        scan_y_cg = horiz_scan2x2_y;
        scan_x_off = horiz_scan4x4_x;
        scan_y_off = horiz_scan4x4_y;
        num_coeff = horiz_scan8x8_inv[last_significant_coeff_y][last_significant_coeff_x];
        break;
    default: //SCAN_VERT
        scan_x_cg = horiz_scan2x2_y;
        scan_y_cg = horiz_scan2x2_x;
        scan_x_off = horiz_scan4x4_y;
        scan_y_off = horiz_scan4x4_x;
        num_coeff = horiz_scan8x8_inv[last_significant_coeff_x][last_significant_coeff_y];
        break;
    }
    num_coeff++;
    num_last_subset = (num_coeff - 1) &gt;&gt; 4;

    for (i = num_last_subset; i &gt;= 0; i--) {
        int n, m;
        int x_cg, y_cg, x_c, y_c, pos;
        int implicit_non_zero_coeff = 0;
        int64_t trans_coeff_level;
        int prev_sig = 0;
        int offset = i &lt;&lt; 4;
        int rice_init = 0;

        uint8_t significant_coeff_flag_idx[16];
        uint8_t nb_significant_coeff_flag = 0;

        x_cg = scan_x_cg[i];
        y_cg = scan_y_cg[i];

        if ((i &lt; num_last_subset) &amp;&amp; (i &gt; 0)) {
            int ctx_cg = 0;
            if (x_cg &lt; (1 &lt;&lt; (log2_trafo_size - 2)) - 1)
                ctx_cg += significant_coeff_group_flag[x_cg + 1][y_cg];
            if (y_cg &lt; (1 &lt;&lt; (log2_trafo_size - 2)) - 1)
                ctx_cg += significant_coeff_group_flag[x_cg][y_cg + 1];

            significant_coeff_group_flag[x_cg][y_cg] =
                significant_coeff_group_flag_decode(s, c_idx, ctx_cg);
            implicit_non_zero_coeff = 1;
        } else {
            significant_coeff_group_flag[x_cg][y_cg] =
            ((x_cg == x_cg_last_sig &amp;&amp; y_cg == y_cg_last_sig) ||
             (x_cg == 0 &amp;&amp; y_cg == 0));
        }

        last_scan_pos = num_coeff - offset - 1;

        if (i == num_last_subset) {
            n_end = last_scan_pos - 1;
            significant_coeff_flag_idx[0] = last_scan_pos;
            nb_significant_coeff_flag = 1;
        } else {
            n_end = 15;
        }

        if (x_cg &lt; ((1 &lt;&lt; log2_trafo_size) - 1) &gt;&gt; 2)
            prev_sig = !!significant_coeff_group_flag[x_cg + 1][y_cg];
        if (y_cg &lt; ((1 &lt;&lt; log2_trafo_size) - 1) &gt;&gt; 2)
            prev_sig += (!!significant_coeff_group_flag[x_cg][y_cg + 1] &lt;&lt; 1);

        if (significant_coeff_group_flag[x_cg][y_cg] &amp;&amp; n_end &gt;= 0) {
            static const uint8_t ctx_idx_map[] = {
                0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8, 8, // log2_trafo_size == 2
                1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, // prev_sig == 0
                2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, // prev_sig == 1
                2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, // prev_sig == 2
                2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2  // default
            };
            const uint8_t *ctx_idx_map_p;
            int scf_offset = 0;
            if (s-&gt;sps-&gt;transform_skip_context_enabled_flag &amp;&amp;
                (transform_skip_flag || lc-&gt;cu.cu_transquant_bypass_flag)) {
                ctx_idx_map_p = (uint8_t*) &amp;ctx_idx_map[4 * 16];
                if (c_idx == 0) {
                    scf_offset = 40;
                } else {
                    scf_offset = 14 + 27;
                }
            } else {
                if (c_idx != 0)
                    scf_offset = 27;
                if (log2_trafo_size == 2) {
                    ctx_idx_map_p = (uint8_t*) &amp;ctx_idx_map[0];
                } else {
                    ctx_idx_map_p = (uint8_t*) &amp;ctx_idx_map[(prev_sig + 1) &lt;&lt; 4];
                    if (c_idx == 0) {
                        if ((x_cg &gt; 0 || y_cg &gt; 0))
                            scf_offset += 3;
                        if (log2_trafo_size == 3) {
                            scf_offset += (scan_idx == SCAN_DIAG) ? 9 : 15;
                        } else {
                            scf_offset += 21;
                        }
                    } else {
                        if (log2_trafo_size == 3)
                            scf_offset += 9;
                        else
                            scf_offset += 12;
                    }
                }
            }
            for (n = n_end; n &gt; 0; n--) {
                x_c = scan_x_off[n];
                y_c = scan_y_off[n];
                if (significant_coeff_flag_decode(s, x_c, y_c, scf_offset, ctx_idx_map_p)) {
                    significant_coeff_flag_idx[nb_significant_coeff_flag] = n;
                    nb_significant_coeff_flag++;
                    implicit_non_zero_coeff = 0;
                }
            }
            if (implicit_non_zero_coeff == 0) {
                if (s-&gt;sps-&gt;transform_skip_context_enabled_flag &amp;&amp;
                    (transform_skip_flag || lc-&gt;cu.cu_transquant_bypass_flag)) {
                    if (c_idx == 0) {
                        scf_offset = 42;
                    } else {
                        scf_offset = 16 + 27;
                    }
                } else {
                    if (i == 0) {
                        if (c_idx == 0)
                            scf_offset = 0;
                        else
                            scf_offset = 27;
                    } else {
                        scf_offset = 2 + scf_offset;
                    }
                }
                if (significant_coeff_flag_decode_0(s, c_idx, scf_offset) == 1) {
                    significant_coeff_flag_idx[nb_significant_coeff_flag] = 0;
                    nb_significant_coeff_flag++;
                }
            } else {
                significant_coeff_flag_idx[nb_significant_coeff_flag] = 0;
                nb_significant_coeff_flag++;
            }
        }

        n_end = nb_significant_coeff_flag;


        if (n_end) {
            int first_nz_pos_in_cg;
            int last_nz_pos_in_cg;
            int c_rice_param = 0;
            int first_greater1_coeff_idx = -1;
            uint8_t coeff_abs_level_greater1_flag[8];
            uint16_t coeff_sign_flag;
            int sum_abs = 0;
            int sign_hidden;
            int sb_type;


            // initialize first elem of coeff_bas_level_greater1_flag
            int ctx_set = (i &gt; 0 &amp;&amp; c_idx == 0) ? 2 : 0;

            if (s-&gt;sps-&gt;persistent_rice_adaptation_enabled_flag) {
                if (!transform_skip_flag &amp;&amp; !lc-&gt;cu.cu_transquant_bypass_flag)
                    sb_type = 2 * (c_idx == 0 ? 1 : 0);
                else
                    sb_type = 2 * (c_idx == 0 ? 1 : 0) + 1;
                c_rice_param = lc-&gt;stat_coeff[sb_type] / 4;
            }

            if (!(i == num_last_subset) &amp;&amp; greater1_ctx == 0)
                ctx_set++;
            greater1_ctx = 1;
            last_nz_pos_in_cg = significant_coeff_flag_idx[0];

            for (m = 0; m &lt; (n_end &gt; 8 ? 8 : n_end); m++) {
                int inc = (ctx_set &lt;&lt; 2) + greater1_ctx;
                coeff_abs_level_greater1_flag[m] =
                    coeff_abs_level_greater1_flag_decode(s, c_idx, inc);
                if (coeff_abs_level_greater1_flag[m]) {
                    greater1_ctx = 0;
                    if (first_greater1_coeff_idx == -1)
                        first_greater1_coeff_idx = m;
                } else if (greater1_ctx &gt; 0 &amp;&amp; greater1_ctx &lt; 3) {
                    greater1_ctx++;
                }
            }
            first_nz_pos_in_cg = significant_coeff_flag_idx[n_end - 1];

            if (lc-&gt;cu.cu_transquant_bypass_flag ||
                (lc-&gt;cu.pred_mode ==  MODE_INTRA  &amp;&amp;
                 s-&gt;sps-&gt;implicit_rdpcm_enabled_flag  &amp;&amp;  transform_skip_flag  &amp;&amp;
                 (pred_mode_intra == 10 || pred_mode_intra  ==  26 )) ||
                 explicit_rdpcm_flag)
                sign_hidden = 0;
            else
                sign_hidden = (last_nz_pos_in_cg - first_nz_pos_in_cg &gt;= 4);

            if (first_greater1_coeff_idx != -1) {
                coeff_abs_level_greater1_flag[first_greater1_coeff_idx] += coeff_abs_level_greater2_flag_decode(s, c_idx, ctx_set);
            }
            if (!s-&gt;pps-&gt;sign_data_hiding_flag || !sign_hidden ) {
                coeff_sign_flag = coeff_sign_flag_decode(s, nb_significant_coeff_flag) &lt;&lt; (16 - nb_significant_coeff_flag);
            } else {
                coeff_sign_flag = coeff_sign_flag_decode(s, nb_significant_coeff_flag - 1) &lt;&lt; (16 - (nb_significant_coeff_flag - 1));
            }

            for (m = 0; m &lt; n_end; m++) {
                n = significant_coeff_flag_idx[m];
                GET_COORD(offset, n);
                if (m &lt; 8) {
                    trans_coeff_level = 1 + coeff_abs_level_greater1_flag[m];
                    if (trans_coeff_level == ((m == first_greater1_coeff_idx) ? 3 : 2)) {
                        int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);

                        trans_coeff_level += last_coeff_abs_level_remaining;
                        if (trans_coeff_level &gt; (3 &lt;&lt; c_rice_param))
                            c_rice_param = s-&gt;sps-&gt;persistent_rice_adaptation_enabled_flag ? c_rice_param + 1 : FFMIN(c_rice_param + 1, 4);
                        if (s-&gt;sps-&gt;persistent_rice_adaptation_enabled_flag &amp;&amp; !rice_init) {
                            int c_rice_p_init = lc-&gt;stat_coeff[sb_type] / 4;
                            if (last_coeff_abs_level_remaining &gt;= (3 &lt;&lt; c_rice_p_init))
                                lc-&gt;stat_coeff[sb_type]++;
                            else if (2 * last_coeff_abs_level_remaining &lt; (1 &lt;&lt; c_rice_p_init))
                                if (lc-&gt;stat_coeff[sb_type] &gt; 0)
                                    lc-&gt;stat_coeff[sb_type]--;
                            rice_init = 1;
                        }
                    }
                } else {
                    int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);

                    trans_coeff_level = 1 + last_coeff_abs_level_remaining;
                    if (trans_coeff_level &gt; (3 &lt;&lt; c_rice_param))
                        c_rice_param = s-&gt;sps-&gt;persistent_rice_adaptation_enabled_flag ? c_rice_param + 1 : FFMIN(c_rice_param + 1, 4);
                    if (s-&gt;sps-&gt;persistent_rice_adaptation_enabled_flag &amp;&amp; !rice_init) {
                        int c_rice_p_init = lc-&gt;stat_coeff[sb_type] / 4;
                        if (last_coeff_abs_level_remaining &gt;= (3 &lt;&lt; c_rice_p_init))
                            lc-&gt;stat_coeff[sb_type]++;
                        else if (2 * last_coeff_abs_level_remaining &lt; (1 &lt;&lt; c_rice_p_init))
                            if (lc-&gt;stat_coeff[sb_type] &gt; 0)
                                lc-&gt;stat_coeff[sb_type]--;
                        rice_init = 1;
                    }
                }
                if (s-&gt;pps-&gt;sign_data_hiding_flag &amp;&amp; sign_hidden) {
                    sum_abs += trans_coeff_level;
                    if (n == first_nz_pos_in_cg &amp;&amp; (sum_abs&amp;1))
                        trans_coeff_level = -trans_coeff_level;
                }
                if (coeff_sign_flag &gt;&gt; 15)
                    trans_coeff_level = -trans_coeff_level;
                coeff_sign_flag &lt;&lt;= 1;
                if(!lc-&gt;cu.cu_transquant_bypass_flag) {
                    if (s-&gt;sps-&gt;scaling_list_enable_flag &amp;&amp; !(transform_skip_flag &amp;&amp; log2_trafo_size &gt; 2)) {
                        if(y_c || x_c || log2_trafo_size &lt; 4) {
                            switch(log2_trafo_size) {
                                case 3: pos = (y_c &lt;&lt; 3) + x_c; break;
                                case 4: pos = ((y_c &gt;&gt; 1) &lt;&lt; 3) + (x_c &gt;&gt; 1); break;
                                case 5: pos = ((y_c &gt;&gt; 2) &lt;&lt; 3) + (x_c &gt;&gt; 2); break;
                                default: pos = (y_c &lt;&lt; 2) + x_c; break;
                            }
                            scale_m = scale_matrix[pos];
                        } else {
                            scale_m = dc_scale;
                        }
                    }
                    trans_coeff_level = (trans_coeff_level * (int64_t)scale * (int64_t)scale_m + add) &gt;&gt; shift;
                    if(trans_coeff_level &lt; 0) {
                        if((~trans_coeff_level) &amp; 0xFffffffffff8000)
                            trans_coeff_level = -32768;
                    } else {
                        if(trans_coeff_level &amp; 0xffffffffffff8000)
                            trans_coeff_level = 32767;
                    }
                }
                coeffs[y_c * trafo_size + x_c] = trans_coeff_level;
            }
        }
    }

    if (lc-&gt;cu.cu_transquant_bypass_flag) {
        if (explicit_rdpcm_flag || (s-&gt;sps-&gt;implicit_rdpcm_enabled_flag &amp;&amp;
                                    (pred_mode_intra == 10 || pred_mode_intra == 26))) {
            int mode = s-&gt;sps-&gt;implicit_rdpcm_enabled_flag ? (pred_mode_intra == 26) : explicit_rdpcm_dir_flag;

            s-&gt;hevcdsp.transform_rdpcm(coeffs, log2_trafo_size, mode);
        }
    } else {
        if (transform_skip_flag) {
            int rot = s-&gt;sps-&gt;transform_skip_rotation_enabled_flag &amp;&amp;
                      log2_trafo_size == 2 &amp;&amp;
                      lc-&gt;cu.pred_mode == MODE_INTRA;
            if (rot) {
                for (i = 0; i &lt; 8; i++)
                    FFSWAP(int16_t, coeffs[i], coeffs[16 - i - 1]);
            }

            s-&gt;hevcdsp.transform_skip(coeffs, log2_trafo_size);

            if (explicit_rdpcm_flag || (s-&gt;sps-&gt;implicit_rdpcm_enabled_flag &amp;&amp;
                                        lc-&gt;cu.pred_mode == MODE_INTRA &amp;&amp;
                                        (pred_mode_intra == 10 || pred_mode_intra == 26))) {
                int mode = explicit_rdpcm_flag ? explicit_rdpcm_dir_flag : (pred_mode_intra == 26);

                s-&gt;hevcdsp.transform_rdpcm(coeffs, log2_trafo_size, mode);
            }
        } else if (lc-&gt;cu.pred_mode == MODE_INTRA &amp;&amp; c_idx == 0 &amp;&amp; log2_trafo_size == 2) {
        	//这里是4x4DST
            s-&gt;hevcdsp.idct_4x4_luma(coeffs);
        } else {
            int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
            if (max_xy == 0)
                s-&gt;hevcdsp.idct_dc[log2_trafo_size-2](coeffs);//只对DC系数做IDCT的比较快的算法
            else {
                int col_limit = last_significant_coeff_x + last_significant_coeff_y + 4;
                if (max_xy &lt; 4)
                    col_limit = FFMIN(4, col_limit);
                else if (max_xy &lt; 8)
                    col_limit = FFMIN(8, col_limit);
                else if (max_xy &lt; 12)
                    col_limit = FFMIN(24, col_limit);
                s-&gt;hevcdsp.idct[log2_trafo_size-2](coeffs, col_limit);//普通的IDCT
            }
        }
    }
    if (lc-&gt;tu.cross_pf) {
        int16_t *coeffs_y = (int16_t*)lc-&gt;edge_emu_buffer;

        for (i = 0; i &lt; (trafo_size * trafo_size); i++) {
            coeffs[i] = coeffs[i] + ((lc-&gt;tu.res_scale_val * coeffs_y[i]) &gt;&gt; 3);
        }
    }
    //将IDCT的结果叠加到预测数据上
    s-&gt;hevcdsp.transform_add[log2_trafo_size-2](dst, coeffs, stride);
}
</pre><br />ff_hevc_hls_residual_coding()前半部分的一大段代码应该是用于解析残差数据的（目前还没有细看），后半部分的代码则用于对残差数据进行DCT变换。在DCT反变换的时候，调用了如下几种功能的汇编函数：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">HEVCDSPContext-&gt; idct_4x4_luma()：4x4DST反变换<br />HEVCDSPContext-&gt; idct_dc[X]()：特殊的只包含DC系数的DCT反变换<br />HEVCDSPContext-&gt; idct[X]()：普通的DCT反变换<br />HEVCDSPContext-&gt; transform_add [X]()：残差像素数据叠加</blockquote>其中不同的[X]取值代表了不同尺寸的系数块：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">[0]代表4x4；<br />[1]代表8x8；<br />[2]代表16x16；<br />[3]代表32x32；</blockquote>后文将会对上述汇编函数进行详细分析。<br /><br /><h2>帧内预测和DCT反变换知识</h2>HEVC标准中的帧内预测和DCT反变换都是以TU为单位进行的，因此将这两部分知识放到一起记录。<br /><br /><h3>帧内预测知识</h3>HEVC的帧内预测共有35中预测模式，如下表所示：<br /><table border="1" cellspacing="0" cellpadding="0" width="500" align="center"> <tbody><tr>  <td valign="top"><p>模式编号</p></td>  <td valign="top"><p>模式名称</p></td> </tr> <tr>  <td valign="top"><p>0</p></td>  <td valign="top"><p>Planar</p></td> </tr> <tr>  <td valign="top"><p>1</p></td>  <td valign="top"><p>DC</p></td> </tr> <tr>  <td valign="top"><p>2-34</p></td>  <td valign="top"><p>33种角度预测模式</p></td> </tr></tbody></table>其中第2-34种预测方式的角度如下所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611023818040" alt="" /></div>HEVC的角度预测方向相对于H.264增加到了33种。这样做的好处是能够更有效低表示图像的纹理特征，提高预测精度。其中编号2到17的角度预测模式为水平类模式，编号为18到34的角度预测模式为垂直类模式。编号为10的为水平预测，编号为26的位垂直预测模式。<br />Planar模式的计算方式如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611023851354" alt="" /></div>从图中可以看出，Planar模式首先将左边一列像素最下面一个像素值水平复制一行，将上边一行像素最右边一个像素值垂直复制一列；然后使用类似于双线性插值的方式，获得预测数据。这一预测方式综合了水平和垂直预测的特点。<br />DC模式的计算方法如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611023904642" alt="" /></div>从图中可以看出，DC模式计算方式原理很简单：直接将当前块上方一行以及左边一列像素求得平均值后，赋值给当前块中的每一个像素。<br /><br /><h3>DCT变换</h3>H.264中采用了4x4整数DCT变换，在HEVC中沿用了这种整数变换方法，但是其主要有以下几点不同：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）变换尺寸不再限于4x4，而是包括了4x4，8x8，16x16，32x32几种方式。<br />（2）变换系数值变大了很多，这样使得整数DCT的结果更接近浮点DCT的结果。注意在变换完成后会乘以修正矩阵（对于4x4变换来说，统一乘以1/128；对于尺寸N，修正系数值为1/(64*sqrt(N))）将放大后的结果修正回来。<br />（3）在Intra4x4亮度残差变换的时候使用了一种比较特殊的4x4DST（离散正弦变换，中间的“S”代表“sin()”），在后文会记录该种变换。</blockquote>HEVC支持最大为32x32的DCT变换。该变换矩阵的系数值如下图所示。其中第一张图为左边的16列数值，第二张图为右边的16列数值。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024045218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><div style="text-align: center;"><img src="http://img.blog.csdn.net/20150611024138926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></div>4x4DCT变换的系数来自于为32x32系数矩阵中第0，8，16，24行元素中的前4个元素，在图中以红色方框表示出来。由此可知4x4DCT系数矩阵为：<br /><div style="text-align: center;"><strong><span style="color:#663300;">64 &nbsp;64 &nbsp;64 &nbsp;64</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">83 &nbsp;36 -36 -83</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">64 -64 -64 &nbsp;64</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">36 -83 &nbsp;83 -36</span></strong></div><p><br /></p><p>8x8DCT变换的系数来自于32x32系数矩阵中第0，4，8，12，16，20，24，28行元素中的前8个元素，在图中以黄色方框表示出来。由此可知8x8DCT系数矩阵为：</p><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;64 &nbsp;64 &nbsp;64 &nbsp;64 &nbsp;64 &nbsp;64 &nbsp;64 &nbsp;64</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;89 &nbsp;75 &nbsp;50 &nbsp;18 -18 -50 -75 -89</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;83 &nbsp;36 -36 -83 -83 -36 &nbsp;36 &nbsp;83</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;75 -18 -89 -50 &nbsp;50 &nbsp;89 &nbsp;18 -75</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;64 -64 -64 &nbsp;64 &nbsp;64 -64 -64 &nbsp;64</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;50 -89 &nbsp;18 &nbsp;75 -75 -18 &nbsp;89 -50</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;36 -83 &nbsp;83 -36 -36 &nbsp;83 -83 &nbsp;36</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;18 -50 &nbsp;75 -89 &nbsp;89 -75 &nbsp;50 -18</span></strong></div><p><br /></p><p>16x16 DCT变换的系数来自于32x32系数矩阵中第0，2，4…，28，30行元素中的前16个元素，在图中以绿色方框表示出来。由于系数数量较大，就不再列出了。</p>在编码Intra4x4的残差数据的时候，使用了一种比较特殊的4x4DST。该种变换的系数矩阵如下所示。相关的实验表明，在编码Intra4x4的时候使用4x4DST可以提升约0.8%的编码效率。<br /><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;29 &nbsp;55 &nbsp;74 &nbsp;84</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;74 &nbsp;74 &nbsp; 0 -74</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;84 -29 -74 &nbsp;55</span></strong></div><div style="text-align: center;"><strong><span style="color:#663300;">&nbsp;55 -84 &nbsp;74 -29</span></strong></div><br /><h3>帧内预测实例</h3>本节以一小段视频的码流为例，看一下HEVC码流中的帧内预测相关的信息。<br />【示例1】<br />下图为一个I帧解码后的图像。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024436512" alt="" /></div>下图为该帧CTU的划分方式。可以看出画面复杂的地方CTU划分比较细。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024454163" alt="" /></div>下图的蓝色线条显示了帧内预测的方向。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024508627" alt="" /></div>下图显示了帧内预测方向与图像内容之间的关系。可以看出帧内预测方向基本上和图像纹理方向是一致的。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024521763" alt="" /></div>下图为经过帧内预测，没有经过残差叠加处理的视频内容。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024537102" alt="" /></div>下图为该帧的残差信息。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024549996" alt="" /></div><br />【示例2】<br />下图为一个I帧解码后的图像。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024612159" alt="" /></div>下图为该帧CTU的划分方式。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024623322" alt="" /></div>下图的蓝色线条显示了帧内预测的方向。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024636145" alt="" /></div>下图显示了帧内预测方向与图像内容之间的关系。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024656516" alt="" /></div>下图为经过帧内预测，没有经过残差叠加处理的视频内容。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024711662" alt="" /></div>下图为该帧的残差信息。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611024728801" alt="" /></div><div style="text-align: center;"><br /></div><div style="text-align: left;">【示例3-帧内滤波信息】<br />本节以一段《Sintel》动画的码流为例，看一下HEVC码流中的帧内滤波具体的信息。下图为I帧解码后的图像。<br /><div style="text-align: center;"><img src="http://img.blog.csdn.net/20150613174124652" alt="" /></div>下图为没有叠加残差数据的帧内预测的结果。在这里我们选择一个8x8 CU（图中以紫色方框标出）看一下其中具体的信息。该CU采用了19号帧内预测模式（属于角度Angular预测模式）。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613174140884" alt="" /></div>该8x8 CU的帧内预测信息如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613174209278" alt="" /></div><br /><br />【示例4-DCT反变换示例】<br />本节还是以《Sintel》动画的码流为例，看一下HEVC码流中的DCT反变换具体的信息。下图为一帧解码后的图像。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613174336094" alt="" /></div>下图为该帧图像的残差数据。在这里我们选择一个8x8 CU（图中以紫色方框标出）看一下其中具体的信息。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613174350995" alt="" /></div>该8x8 CU的DCT反变换信息如下图所示。图中显示了反量化，反变换的具体过程。<br /></div><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150613174410942" alt="" /><br /></p><p><br /></p><h2>帧内预测汇编函数源代码</h2><p>帧内预测相关的汇编函数位于HEVCPredContext中。HEVCPredContext的初始化函数是ff_hevc_pred_init()。该函数对HEVCPredContext结构体中的函数指针进行了赋值。FFmpeg HEVC解码器运行的过程中只要调用HEVCPredContext的函数指针就可以完成相应的功能。</p><p><br /></p><h3>ff_hevc_pred_init()</h3>ff_hevc_pred_init()用于初始化HEVCPredContext结构体中的汇编函数指针。该函数的定义如下所示。<br /><pre name="code" class="cpp">//帧内预测函数初始化
void ff_hevc_pred_init(HEVCPredContext *hpc, int bit_depth)
{
#undef FUNC
#define FUNC(a, depth) a ## _ ## depth

#define HEVC_PRED(depth)                                \
    hpc-&gt;intra_pred[0]   = FUNC(intra_pred_2, depth);   \
    hpc-&gt;intra_pred[1]   = FUNC(intra_pred_3, depth);   \
    hpc-&gt;intra_pred[2]   = FUNC(intra_pred_4, depth);   \
    hpc-&gt;intra_pred[3]   = FUNC(intra_pred_5, depth);   \
    hpc-&gt;pred_planar[0]  = FUNC(pred_planar_0, depth);  \
    hpc-&gt;pred_planar[1]  = FUNC(pred_planar_1, depth);  \
    hpc-&gt;pred_planar[2]  = FUNC(pred_planar_2, depth);  \
    hpc-&gt;pred_planar[3]  = FUNC(pred_planar_3, depth);  \
    hpc-&gt;pred_dc         = FUNC(pred_dc, depth);        \
    hpc-&gt;pred_angular[0] = FUNC(pred_angular_0, depth); \
    hpc-&gt;pred_angular[1] = FUNC(pred_angular_1, depth); \
    hpc-&gt;pred_angular[2] = FUNC(pred_angular_2, depth); \
    hpc-&gt;pred_angular[3] = FUNC(pred_angular_3, depth);

    switch (bit_depth) {
    case 9:
        HEVC_PRED(9);
        break;
    case 10:
        HEVC_PRED(10);
        break;
    case 12:
        HEVC_PRED(12);
        break;
    default:
        HEVC_PRED(8);
        break;
    }
}
</pre><br />从源代码可以看出，ff_hevc_pred_init()函数中包含一个名为“HEVC_PRED(depth)”的很长的宏定义。该宏定义中包含了C语言版本的帧内预测函数的初始化代码。ff_hevc_dsp_init()会根据系统的颜色位深bit_depth初始化相应的C语言版本的帧内预测函数。下面以8bit颜色位深为例，看一下“HEVC_ PRED(8)”的展开结果。<br /><pre name="code" class="cpp">hpc-&gt;intra_pred[0]   = intra_pred_2_8;   
hpc-&gt;intra_pred[1]   = intra_pred_3_8;   
hpc-&gt;intra_pred[2]   = intra_pred_4_8;   
hpc-&gt;intra_pred[3]   = intra_pred_5_8;   
hpc-&gt;pred_planar[0]  = pred_planar_0_8;  
hpc-&gt;pred_planar[1]  = pred_planar_1_8;  
hpc-&gt;pred_planar[2]  = pred_planar_2_8;  
hpc-&gt;pred_planar[3]  = pred_planar_3_8;  
hpc-&gt;pred_dc         = pred_dc_8;        
hpc-&gt;pred_angular[0] = pred_angular_0_8; 
hpc-&gt;pred_angular[1] = pred_angular_1_8; 
hpc-&gt;pred_angular[2] = pred_angular_2_8; 
hpc-&gt;pred_angular[3] = pred_angular_3_8;</pre>可以看出“HEVC_ PRED(8)”初始化了帧内预测模块的C语言版本函数。HEVCPredContext的定义如下。<br /><pre name="code" class="cpp">typedef struct HEVCPredContext {
    void (*intra_pred[4])(struct HEVCContext *s, int x0, int y0, int c_idx);

    void (*pred_planar[4])(uint8_t *src, const uint8_t *top,
                           const uint8_t *left, ptrdiff_t stride);
    void (*pred_dc)(uint8_t *src, const uint8_t *top, const uint8_t *left,
                    ptrdiff_t stride, int log2_size, int c_idx);
    void (*pred_angular[4])(uint8_t *src, const uint8_t *top,
                            const uint8_t *left, ptrdiff_t stride,
                            int c_idx, int mode);
} HEVCPredContext;</pre>从源代码中可以看出，HEVCPredContext中存储了4个汇编函数指针（数组）：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">intra_pred[4]()：帧内预测的入口函数，该函数执行过程中调用了后面3个函数指针。数组中4个函数分别处理4x4，8x8，16x16，32x32几种块。<br />pred_planar[4]()：Planar预测模式函数。数组中4个函数分别处理4x4，8x8，16x16，32x32几种块。<br />pred_dc()：DC预测模式函数。<br />pred_angular[4]()：角度预测模式。数组中4个函数分别处理4x4，8x8，16x16，32x32几种块。</blockquote>下文按照顺序分别介绍这几种函数。<br /><br /><h3>HEVCPredContext -&gt;intra_pred[4]()</h3>intra_pred[4]()是帧内预测的入口函数，该函数执行过程中调用了Planar、DC或者角度预测函数。数组中4个元素分别处理4x4，8x8，16x16，32x32几种块。这几种块的具体的处理函数为：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">intra_pred_2_8()——4x4块<br />intra_pred_3_8()——8x8块<br />intra_pred_4_8()——16x16块<br />intra_pred_5_8()——32x32块<br /><span style="font-family: FangSong_GB2312;">PS：函数命名时候中间的数字是块的边长取log2()之后的数值。</span></blockquote>上面这几个函数的定义如下所示。<br /><pre name="code" class="cpp">#define INTRA_PRED(size)                                                            \
static void FUNC(intra_pred_ ## size)(HEVCContext *s, int x0, int y0, int c_idx)    \
{                                                                                   \
    FUNC(intra_pred)(s, x0, y0, size, c_idx);                                       \
}

/* 几种不同大小的方块对应的帧内预测函数
 * 参数是方块像素数取对数之后的值
 * 例如“INTRA_PRED(2)”即为4x4块的帧内预测函数
 *
 * “INTRA_PRED(2)”展开后的函数是
 * static void intra_pred_2_8(HEVCContext *s, int x0, int y0, int c_idx)
 * {
 * 	intra_pred_8(s, x0, y0, 2, c_idx);
 * }
 */
INTRA_PRED(2)
INTRA_PRED(3)
INTRA_PRED(4)
INTRA_PRED(5)</pre>从源代码中可以看出，intra_pred_2_8()、intra_pred_3_8()等函数都是通过“INTRA_PRED()”宏进行定义的。intra_pred_2_8()、intra_pred_3_8()的函数的内部都调用了同一个函数intra_pred_8()。这几个函数唯一的不同在于，调用intra_pred_8()时候第4个参数size的值不一样。<br /><br /><strong>intra_pred_8()</strong><br />intra_pred_8()完成了帧内预测前的滤波等准备工作，并根据帧内预测类型的不同（Planar、DC、角度）调用不同的帧内预测函数。该函数的定义如下所示。<br /><pre name="code" class="cpp">static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,
                                              int log2_size, int c_idx)
{
#define PU(x) \
    ((x) &gt;&gt; s-&gt;sps-&gt;log2_min_pu_size)
#define MVF(x, y) \
    (s-&gt;ref-&gt;tab_mvf[(x) + (y) * min_pu_width])
#define MVF_PU(x, y) \
    MVF(PU(x0 + ((x) &lt;&lt; hshift)), PU(y0 + ((y) &lt;&lt; vshift)))
#define IS_INTRA(x, y) \
    (MVF_PU(x, y).pred_flag == PF_INTRA)
#define MIN_TB_ADDR_ZS(x, y) \
    s-&gt;pps-&gt;min_tb_addr_zs[(y) * (s-&gt;sps-&gt;tb_mask+2) + (x)]
#define EXTEND(ptr, val, len)         \
do {                                  \
    pixel4 pix = PIXEL_SPLAT_X4(val); \
    for (i = 0; i &lt; (len); i += 4)    \
        AV_WN4P(ptr + i, pix);        \
} while (0)

#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \
        for (i = start; i &lt; (start) + (length); i += 4)                        \
            if (!IS_INTRA(i, -1))                                              \
                AV_WN4P(&amp;ptr[i], a);                                           \
            else                                                               \
                a = PIXEL_SPLAT_X4(ptr[i+3])
#define EXTEND_LEFT_CIP(ptr, start, length) \
        for (i = start; i &gt; (start) - (length); i--) \
            if (!IS_INTRA(i - 1, -1)) \
                ptr[i - 1] = ptr[i]
#define EXTEND_UP_CIP(ptr, start, length)                                      \
        for (i = (start); i &gt; (start) - (length); i -= 4)                      \
            if (!IS_INTRA(-1, i - 3))                                          \
                AV_WN4P(&amp;ptr[i - 3], a);                                       \
            else                                                               \
                a = PIXEL_SPLAT_X4(ptr[i - 3])
#define EXTEND_DOWN_CIP(ptr, start, length)                                    \
        for (i = start; i &lt; (start) + (length); i += 4)                        \
            if (!IS_INTRA(-1, i))                                              \
                AV_WN4P(&amp;ptr[i], a);                                           \
            else                                                               \
                a = PIXEL_SPLAT_X4(ptr[i + 3])

    HEVCLocalContext *lc = s-&gt;HEVClc;
    int i;
    int hshift = s-&gt;sps-&gt;hshift[c_idx];
    int vshift = s-&gt;sps-&gt;vshift[c_idx];
    int size = (1 &lt;&lt; log2_size);
    int size_in_luma_h = size &lt;&lt; hshift;
    int size_in_tbs_h  = size_in_luma_h &gt;&gt; s-&gt;sps-&gt;log2_min_tb_size;
    int size_in_luma_v = size &lt;&lt; vshift;
    int size_in_tbs_v  = size_in_luma_v &gt;&gt; s-&gt;sps-&gt;log2_min_tb_size;
    int x = x0 &gt;&gt; hshift;
    int y = y0 &gt;&gt; vshift;
    int x_tb = (x0 &gt;&gt; s-&gt;sps-&gt;log2_min_tb_size) &amp; s-&gt;sps-&gt;tb_mask;
    int y_tb = (y0 &gt;&gt; s-&gt;sps-&gt;log2_min_tb_size) &amp; s-&gt;sps-&gt;tb_mask;

    int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb);
    //注意c_idx标志了颜色分量
    ptrdiff_t stride = s-&gt;frame-&gt;linesize[c_idx] / sizeof(pixel);
    pixel *src = (pixel*)s-&gt;frame-&gt;data[c_idx] + x + y * stride;

    int min_pu_width = s-&gt;sps-&gt;min_pu_width;

    enum IntraPredMode mode = c_idx ? lc-&gt;tu.intra_pred_mode_c :
                              lc-&gt;tu.intra_pred_mode;
    pixel4 a;
    pixel  left_array[2 * MAX_TB_SIZE + 1];
    pixel  filtered_left_array[2 * MAX_TB_SIZE + 1];
    pixel  top_array[2 * MAX_TB_SIZE + 1];
    pixel  filtered_top_array[2 * MAX_TB_SIZE + 1];

    pixel  *left          = left_array + 1;
    pixel  *top           = top_array  + 1;
    pixel  *filtered_left = filtered_left_array + 1;
    pixel  *filtered_top  = filtered_top_array  + 1;
    int cand_bottom_left = lc-&gt;na.cand_bottom_left &amp;&amp; cur_tb_addr &gt; MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) &amp; s-&gt;sps-&gt;tb_mask);
    int cand_left        = lc-&gt;na.cand_left;
    int cand_up_left     = lc-&gt;na.cand_up_left;
    int cand_up          = lc-&gt;na.cand_up;
    int cand_up_right    = lc-&gt;na.cand_up_right    &amp;&amp; cur_tb_addr &gt; MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) &amp; s-&gt;sps-&gt;tb_mask, y_tb - 1);

    int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s-&gt;sps-&gt;height) -
                           (y0 + size_in_luma_v)) &gt;&gt; vshift;
    int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s-&gt;sps-&gt;width) -
                           (x0 + size_in_luma_h)) &gt;&gt; hshift;

    if (s-&gt;pps-&gt;constrained_intra_pred_flag == 1) {
        int size_in_luma_pu_v = PU(size_in_luma_v);
        int size_in_luma_pu_h = PU(size_in_luma_h);
        int on_pu_edge_x    = !(x0 &amp; ((1 &lt;&lt; s-&gt;sps-&gt;log2_min_pu_size) - 1));
        int on_pu_edge_y    = !(y0 &amp; ((1 &lt;&lt; s-&gt;sps-&gt;log2_min_pu_size) - 1));
        if (!size_in_luma_pu_h)
            size_in_luma_pu_h++;
        if (cand_bottom_left == 1 &amp;&amp; on_pu_edge_x) {
            int x_left_pu   = PU(x0 - 1);
            int y_bottom_pu = PU(y0 + size_in_luma_v);
            int max = FFMIN(size_in_luma_pu_v, s-&gt;sps-&gt;min_pu_height - y_bottom_pu);
            cand_bottom_left = 0;
            for (i = 0; i &lt; max; i += 2)
                cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA);
        }
        if (cand_left == 1 &amp;&amp; on_pu_edge_x) {
            int x_left_pu   = PU(x0 - 1);
            int y_left_pu   = PU(y0);
            int max = FFMIN(size_in_luma_pu_v, s-&gt;sps-&gt;min_pu_height - y_left_pu);
            cand_left = 0;
            for (i = 0; i &lt; max; i += 2)
                cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA);
        }
        if (cand_up_left == 1) {
            int x_left_pu   = PU(x0 - 1);
            int y_top_pu    = PU(y0 - 1);
            cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA;
        }
        if (cand_up == 1 &amp;&amp; on_pu_edge_y) {
            int x_top_pu    = PU(x0);
            int y_top_pu    = PU(y0 - 1);
            int max = FFMIN(size_in_luma_pu_h, s-&gt;sps-&gt;min_pu_width - x_top_pu);
            cand_up = 0;
            for (i = 0; i &lt; max; i += 2)
                cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA);
        }
        if (cand_up_right == 1 &amp;&amp; on_pu_edge_y) {
            int y_top_pu    = PU(y0 - 1);
            int x_right_pu  = PU(x0 + size_in_luma_h);
            int max = FFMIN(size_in_luma_pu_h, s-&gt;sps-&gt;min_pu_width - x_right_pu);
            cand_up_right = 0;
            for (i = 0; i &lt; max; i += 2)
                cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA);
        }
        memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel));
        memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel));
        top[-1] = 128;
    }
    if (cand_up_left) {
        left[-1] = POS(-1, -1);
        top[-1]  = left[-1];
    }
    if (cand_up)
        memcpy(top, src - stride, size * sizeof(pixel));
    if (cand_up_right) {
        memcpy(top + size, src - stride + size, size * sizeof(pixel));
        EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1),
               size - top_right_size);
    }
    if (cand_left)
        for (i = 0; i &lt; size; i++)
            left[i] = POS(-1, i);
    if (cand_bottom_left) {
        for (i = size; i &lt; size + bottom_left_size; i++)
            left[i] = POS(-1, i);
        EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1),
               size - bottom_left_size);
    }

    if (s-&gt;pps-&gt;constrained_intra_pred_flag == 1) {
        if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) {
            int size_max_x = x0 + ((2 * size) &lt;&lt; hshift) &lt; s-&gt;sps-&gt;width ?
                                    2 * size : (s-&gt;sps-&gt;width - x0) &gt;&gt; hshift;
            int size_max_y = y0 + ((2 * size) &lt;&lt; vshift) &lt; s-&gt;sps-&gt;height ?
                                    2 * size : (s-&gt;sps-&gt;height - y0) &gt;&gt; vshift;
            int j = size + (cand_bottom_left? bottom_left_size: 0) -1;
            if (!cand_up_right) {
                size_max_x = x0 + ((size) &lt;&lt; hshift) &lt; s-&gt;sps-&gt;width ?
                                                    size : (s-&gt;sps-&gt;width - x0) &gt;&gt; hshift;
            }
            if (!cand_bottom_left) {
                size_max_y = y0 + (( size) &lt;&lt; vshift) &lt; s-&gt;sps-&gt;height ?
                                                     size : (s-&gt;sps-&gt;height - y0) &gt;&gt; vshift;
            }
            if (cand_bottom_left || cand_left || cand_up_left) {
                while (j &gt; -1 &amp;&amp; !IS_INTRA(-1, j))
                    j--;
                if (!IS_INTRA(-1, j)) {
                    j = 0;
                    while (j &lt; size_max_x &amp;&amp; !IS_INTRA(j, -1))
                        j++;
                    EXTEND_LEFT_CIP(top, j, j + 1);
                    left[-1] = top[-1];
                }
            } else {
                j = 0;
                while (j &lt; size_max_x &amp;&amp; !IS_INTRA(j, -1))
                    j++;
                if (j &gt; 0)
                    if (x0 &gt; 0) {
                        EXTEND_LEFT_CIP(top, j, j + 1);
                    } else {
                        EXTEND_LEFT_CIP(top, j, j);
                        top[-1] = top[0];
                    }
                left[-1] = top[-1];
            }
            left[-1] = top[-1];
            if (cand_bottom_left || cand_left) {
                a = PIXEL_SPLAT_X4(left[-1]);
                EXTEND_DOWN_CIP(left, 0, size_max_y);
            }
            if (!cand_left)
                EXTEND(left, left[-1], size);
            if (!cand_bottom_left)
                EXTEND(left + size, left[size - 1], size);
            if (x0 != 0 &amp;&amp; y0 != 0) {
                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);
                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);
                if (!IS_INTRA(-1, - 1))
                    left[-1] = left[0];
            } else if (x0 == 0) {
                EXTEND(left, 0, size_max_y);
            } else {
                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);
                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);
            }
            top[-1] = left[-1];
            if (y0 != 0) {
                a = PIXEL_SPLAT_X4(left[-1]);
                EXTEND_RIGHT_CIP(top, 0, size_max_x);
            }
        }
    }
    // Infer the unavailable samples
    if (!cand_bottom_left) {
        if (cand_left) {
            EXTEND(left + size, left[size - 1], size);
        } else if (cand_up_left) {
            EXTEND(left, left[-1], 2 * size);
            cand_left = 1;
        } else if (cand_up) {
            left[-1] = top[0];
            EXTEND(left, left[-1], 2 * size);
            cand_up_left = 1;
            cand_left    = 1;
        } else if (cand_up_right) {
            EXTEND(top, top[size], size);
            left[-1] = top[size];
            EXTEND(left, left[-1], 2 * size);
            cand_up      = 1;
            cand_up_left = 1;
            cand_left    = 1;
        } else { // No samples available
            left[-1] = (1 &lt;&lt; (BIT_DEPTH - 1));
            EXTEND(top,  left[-1], 2 * size);
            EXTEND(left, left[-1], 2 * size);
        }
    }

    if (!cand_left)
        EXTEND(left, left[size], size);
    if (!cand_up_left) {
        left[-1] = left[0];
    }
    if (!cand_up)
        EXTEND(top, left[-1], size);
    if (!cand_up_right)
        EXTEND(top + size, top[size - 1], size);

    top[-1] = left[-1];

    // Filtering process
    // 滤波
    if (!s-&gt;sps-&gt;intra_smoothing_disabled_flag &amp;&amp; (c_idx == 0  || s-&gt;sps-&gt;chroma_format_idc == 3)) {
        if (mode != INTRA_DC &amp;&amp; size != 4){
            int intra_hor_ver_dist_thresh[] = { 7, 1, 0 };
            int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)),
                                          FFABS((int)(mode - 10U)));
            if (min_dist_vert_hor &gt; intra_hor_ver_dist_thresh[log2_size - 3]) {
                int threshold = 1 &lt;&lt; (BIT_DEPTH - 5);
                if (s-&gt;sps-&gt;sps_strong_intra_smoothing_enable_flag &amp;&amp; c_idx == 0 &amp;&amp;
                    log2_size == 5 &amp;&amp;
                    FFABS(top[-1]  + top[63]  - 2 * top[31])  &lt; threshold &amp;&amp;
                    FFABS(left[-1] + left[63] - 2 * left[31]) &lt; threshold) {
                    // We can't just overwrite values in top because it could be
                    // a pointer into src
                    filtered_top[-1] = top[-1];
                    filtered_top[63] = top[63];
                    for (i = 0; i &lt; 63; i++)
                        filtered_top[i] = ((64 - (i + 1)) * top[-1] +
                                           (i + 1)  * top[63] + 32) &gt;&gt; 6;
                    for (i = 0; i &lt; 63; i++)
                        left[i] = ((64 - (i + 1)) * left[-1] +
                                   (i + 1)  * left[63] + 32) &gt;&gt; 6;
                    top = filtered_top;
                } else {
                    filtered_left[2 * size - 1] = left[2 * size - 1];
                    filtered_top[2 * size - 1]  = top[2 * size - 1];
                    for (i = 2 * size - 2; i &gt;= 0; i--)
                        filtered_left[i] = (left[i + 1] + 2 * left[i] +
                                            left[i - 1] + 2) &gt;&gt; 2;
                    filtered_top[-1]  =
                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) &gt;&gt; 2;
                    for (i = 2 * size - 2; i &gt;= 0; i--)
                        filtered_top[i] = (top[i + 1] + 2 * top[i] +
                                           top[i - 1] + 2) &gt;&gt; 2;
                    left = filtered_left;
                    top  = filtered_top;
                }
            }
        }
    }
    /*
     * 根据不同的帧内预测模式，调用不同的处理函数
     * pred_planar[4],pred_angular[4]中的“[4]”代表了几种不同大小的方块
     *   [0]:4x4块
     *   [1]:8x8块
     *   [2]:16x16块
     *   [3]:32x32块
     *
     * log2size为方块边长取对数。
     * 4x4块，log2size=log2(4)=2
     * 8x8块，log2size=log2(8)=3
     * 16x16块，log2size=log2(16)=4
     * 32x32块，log2size=log2(32)=5
     *
     */
    switch (mode) {
    case INTRA_PLANAR:
        s-&gt;hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,
                                          (uint8_t *)left, stride);
        break;
    case INTRA_DC:
        s-&gt;hpc.pred_dc((uint8_t *)src, (uint8_t *)top,
                       (uint8_t *)left, stride, log2_size, c_idx);
        break;
    default:
        s-&gt;hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,
                                           (uint8_t *)left, stride, c_idx,
                                           mode);
        break;
    }
}
</pre><br />intra_pred_8()前面部分的代码还没有细看，大致做了一些帧内预测的准备工作；它的后面有一个switch()语句，根据帧内预测模式的不同作不同的处理：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）Planar模式，调用HEVCContext-&gt; pred_planar()<br />（2）DC模式，调用HEVCContext-&gt; pred_dc()<br />（3）其他模式（剩余都是角度模式），调用HEVCContext-&gt; pred_angular()</blockquote>HEVC解码器中帧内预测模式的定义于IntraPredMode变量，如下所示。<br /><pre name="code" class="cpp">enum IntraPredMode {
    INTRA_PLANAR = 0,
    INTRA_DC,
    INTRA_ANGULAR_2,
    INTRA_ANGULAR_3,
    INTRA_ANGULAR_4,
    INTRA_ANGULAR_5,
    INTRA_ANGULAR_6,
    INTRA_ANGULAR_7,
    INTRA_ANGULAR_8,
    INTRA_ANGULAR_9,
    INTRA_ANGULAR_10,
    INTRA_ANGULAR_11,
    INTRA_ANGULAR_12,
    INTRA_ANGULAR_13,
    INTRA_ANGULAR_14,
    INTRA_ANGULAR_15,
    INTRA_ANGULAR_16,
    INTRA_ANGULAR_17,
    INTRA_ANGULAR_18,
    INTRA_ANGULAR_19,
    INTRA_ANGULAR_20,
    INTRA_ANGULAR_21,
    INTRA_ANGULAR_22,
    INTRA_ANGULAR_23,
    INTRA_ANGULAR_24,
    INTRA_ANGULAR_25,
    INTRA_ANGULAR_26,
    INTRA_ANGULAR_27,
    INTRA_ANGULAR_28,
    INTRA_ANGULAR_29,
    INTRA_ANGULAR_30,
    INTRA_ANGULAR_31,
    INTRA_ANGULAR_32,
    INTRA_ANGULAR_33,
    INTRA_ANGULAR_34,
};
</pre><br />下面分别看一下3种帧内预测函数。<br /><br /><h4>HEVCPredContext -&gt; pred_planar[4]()</h4>HEVCPredContext -&gt; pred_planar[4]()指向了帧内预测Planar模式的汇编函数。数组中4个元素分别处理4x4，8x8，16x16，32x32几种块。这几种块的具体C语言版本处理函数为：&nbsp;<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">pred_planar_0_8()——4x4块；<br />pred_planar_1_8()——8x8块；<br />pred_planar_2_8()——16x16块；<br />pred_planar_3_8()——32x32块；</blockquote>这四个函数的定义如下所示。<br /><pre name="code" class="cpp">#define PRED_PLANAR(size)\
static void FUNC(pred_planar_ ## size)(uint8_t *src, const uint8_t *top,        \
                                       const uint8_t *left, ptrdiff_t stride)   \
{                                                                               \
    FUNC(pred_planar)(src, top, left, stride, size + 2);                        \
}
/* 几种不同大小的方块对应的Planar预测函数
 * 参数取值越大，代表的方块越大：
 * [0]:4x4块
 * [1]:8x8块
 * [2]:16x16块
 * [3]:32x32块
 *
 * “PRED_PLANAR(0)”展开后的函数是
 * static void pred_planar_0_8(uint8_t *src, const uint8_t *top,
 *                                        const uint8_t *left, ptrdiff_t stride)
 * {
 *     pred_planar_8(src, top, left, stride, 0 + 2);
 * }
 */
PRED_PLANAR(0)
PRED_PLANAR(1)
PRED_PLANAR(2)
PRED_PLANAR(3)
</pre><br />从源代码中可以看出，pred_planar_0_8()、pred_planar_1_8()等函数都是通过“PRED_PLANAR ()”宏进行定义的。pred_planar_0_8()、pred_planar_1_8()等函数的内部都调用了同一个函数pred_planar_8()。这几个函数唯一的不同在于，调用intra_pred_8()时候第5个参数trafo_size的值不一样。<br /><br /><p><strong>pred_planar_8()</strong></p>pred_planar_8()实现了Planar帧内预测模式，该函数的定义如下所示。<br /><pre name="code" class="cpp">#define POS(x, y) src[(x) + stride * (y)]

//Planar预测模式
static av_always_inline void FUNC(pred_planar)(uint8_t *_src, const uint8_t *_top,
                                  const uint8_t *_left, ptrdiff_t stride,
                                  int trafo_size)
{
    int x, y;
    pixel *src        = (pixel *)_src;
    //上面1行像素
    const pixel *top  = (const pixel *)_top;
    //左边1列像素
    const pixel *left = (const pixel *)_left;
    int size = 1 &lt;&lt; trafo_size;
    //双线性插值
    //注意[size]为最后一个元素
    for (y = 0; y &lt; size; y++)
        for (x = 0; x &lt; size; x++)
            POS(x, y) = ((size - 1 - x) * left[y] + (x + 1) * top[size]  +
                         (size - 1 - y) * top[x]  + (y + 1) * left[size] + size) &gt;&gt; (trafo_size + 1);
}
</pre><br />从源代码可以看出，pred_planar_8()以一种类似双线性插值的方式完成了预测数据的填充。其中src指向方块的像素区域，left指向方块左边一列像素，top指向方块上边一行像素。Planar模式的计算方式如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150611025313392" alt="" /></div>从图中可以看出，Planar模式首先将左边一列像素最下面一个像素值水平复制一行，将上边一行像素最右边一个像素值垂直复制一列；然后使用类似于双线性插值的方式，获得预测数据。<br /><br /><h4>HEVCPredContext -&gt; pred_dc ()</h4>HEVCPredContext -&gt; pred_dc()指向了帧内预测DC模式的汇编函数。具体的C语言版本的处理函数是pred_dc_8()。pred_dc_8()的定义如下。<br /><pre name="code" class="cpp">#define POS(x, y) src[(x) + stride * (y)]

//DC预测模式
static void FUNC(pred_dc)(uint8_t *_src, const uint8_t *_top,
                          const uint8_t *_left,
                          ptrdiff_t stride, int log2_size, int c_idx)
{
    int i, j, x, y;
    int size          = (1 &lt;&lt; log2_size);
    pixel *src        = (pixel *)_src;
    const pixel *top  = (const pixel *)_top;
    const pixel *left = (const pixel *)_left;
    int dc            = size;
    //pixel4为unit32_t，即存储了4个像素
    pixel4 a;
    //累加左边1列，和上边1行
    for (i = 0; i &lt; size; i++)
        dc += left[i] + top[i];
    //求平均
    dc &gt;&gt;= log2_size + 1;
    //取出来值
    a = PIXEL_SPLAT_X4(dc);
    //赋值到像素块中的每个点
    for (i = 0; i &lt; size; i++)
        for (j = 0; j &lt; size; j+=4)
            AV_WN4P(&amp;POS(j, i), a);

    if (c_idx == 0 &amp;&amp; size &lt; 32) {
        POS(0, 0) = (left[0] + 2 * dc + top[0] + 2) &gt;&gt; 2;
        for (x = 1; x &lt; size; x++)
            POS(x, 0) = (top[x] + 3 * dc + 2) &gt;&gt; 2;
        for (y = 1; y &lt; size; y++)
            POS(0, y) = (left[y] + 3 * dc + 2) &gt;&gt; 2;
    }
}
</pre><br />从源代码可以看出，pred_dc_8()首先求得了左边一行像素和上边一行像素的平均值，然后将该值作为预测数据赋值给了整个方块。<br /><br /><h4>HEVCPredContext -&gt; pred_angular ()</h4>HEVCPredContext -&gt; pred_angular[4]()指向了帧内预测角度（Angular）模式的汇编函数。数组中4个元素分别处理4x4，8x8，16x16，32x32几种块。这几种块的具体C语言版本处理函数为：&nbsp;<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">pred_angular_0_8()——4x4块；<br />pred_angular_1_8()——8x8块；<br />pred_angular_2_8()——16x16块；<br />pred_angular_3_8()——32x32块；</blockquote>这四个函数的定义如下所示。<br /><pre name="code" class="cpp">/* 几种不同大小的方块对应的Angular预测函数
 * 数字取值越大，代表的方块越大：
 * [0]:4x4块
 * [1]:8x8块
 * [2]:16x16块
 * [3]:32x32块
 *
 */
static void FUNC(pred_angular_0)(uint8_t *src, const uint8_t *top,
                                 const uint8_t *left,
                                 ptrdiff_t stride, int c_idx, int mode)
{
    FUNC(pred_angular)(src, top, left, stride, c_idx, mode, 1 &lt;&lt; 2);
}

static void FUNC(pred_angular_1)(uint8_t *src, const uint8_t *top,
                                 const uint8_t *left,
                                 ptrdiff_t stride, int c_idx, int mode)
{
    FUNC(pred_angular)(src, top, left, stride, c_idx, mode, 1 &lt;&lt; 3);
}

static void FUNC(pred_angular_2)(uint8_t *src, const uint8_t *top,
                                 const uint8_t *left,
                                 ptrdiff_t stride, int c_idx, int mode)
{
    FUNC(pred_angular)(src, top, left, stride, c_idx, mode, 1 &lt;&lt; 4);
}

static void FUNC(pred_angular_3)(uint8_t *src, const uint8_t *top,
                                 const uint8_t *left,
                                 ptrdiff_t stride, int c_idx, int mode)
{
    FUNC(pred_angular)(src, top, left, stride, c_idx, mode, 1 &lt;&lt; 5);
}
</pre><br />从源代码可以看出，pred_angular_0_8()、pred_angular_1_8()等函数的内部都调用了同样的一个函数pred_angular_8()。它们之间的不同在于传递给pred_angular_8()的最后一个参数size取值的不同。<br /><br /><strong>pred_angular_8()</strong><br />pred_planar_8()实现了角度（Angular）帧内预测模式，该函数的定义如下所示。<br /><pre name="code" class="cpp">#define POS(x, y) src[(x) + stride * (y)]

static av_always_inline void FUNC(pred_angular)(uint8_t *_src,
                                                const uint8_t *_top,
                                                const uint8_t *_left,
                                                ptrdiff_t stride, int c_idx,
                                                int mode, int size)
{
    int x, y;
    pixel *src        = (pixel *)_src;
    const pixel *top  = (const pixel *)_top;
    const pixel *left = (const pixel *)_left;
    //角度
    static const int intra_pred_angle[] = {
         32,  26,  21,  17, 13,  9,  5, 2, 0, -2, -5, -9, -13, -17, -21, -26, -32,
        -26, -21, -17, -13, -9, -5, -2, 0, 2,  5,  9, 13,  17,  21,  26,  32
    };
    static const int inv_angle[] = {
        -4096, -1638, -910, -630, -482, -390, -315, -256, -315, -390, -482,
        -630, -910, -1638, -4096
    };
    //mode的前两种是Planar和DC，不属于角度预测
    int angle = intra_pred_angle[mode - 2];
    pixel ref_array[3 * MAX_TB_SIZE + 4];
    pixel *ref_tmp = ref_array + size;
    const pixel *ref;
    int last = (size * angle) &gt;&gt; 5;

    if (mode &gt;= 18) {
    	//垂直类模式

        ref = top - 1;
        if (angle &lt; 0 &amp;&amp; last &lt; -1) {
            for (x = 0; x &lt;= size; x += 4)
                AV_WN4P(&amp;ref_tmp[x], AV_RN4P(&amp;top[x - 1]));
            for (x = last; x &lt;= -1; x++)
                ref_tmp[x] = left[-1 + ((x * inv_angle[mode - 11] + 128) &gt;&gt; 8)];
            ref = ref_tmp;
        }

        for (y = 0; y &lt; size; y++) {
            int idx  = ((y + 1) * angle) &gt;&gt; 5;
            int fact = ((y + 1) * angle) &amp; 31;
            if (fact) {
                for (x = 0; x &lt; size; x += 4) {
                    POS(x    , y) = ((32 - fact) * ref[x + idx + 1] +
                                           fact  * ref[x + idx + 2] + 16) &gt;&gt; 5;
                    POS(x + 1, y) = ((32 - fact) * ref[x + 1 + idx + 1] +
                                           fact  * ref[x + 1 + idx + 2] + 16) &gt;&gt; 5;
                    POS(x + 2, y) = ((32 - fact) * ref[x + 2 + idx + 1] +
                                           fact  * ref[x + 2 + idx + 2] + 16) &gt;&gt; 5;
                    POS(x + 3, y) = ((32 - fact) * ref[x + 3 + idx + 1] +
                                           fact  * ref[x + 3 + idx + 2] + 16) &gt;&gt; 5;
                }
            } else {
                for (x = 0; x &lt; size; x += 4)
                    AV_WN4P(&amp;POS(x, y), AV_RN4P(&amp;ref[x + idx + 1]));
            }
        }
        if (mode == 26 &amp;&amp; c_idx == 0 &amp;&amp; size &lt; 32) {
            for (y = 0; y &lt; size; y++)
                POS(0, y) = av_clip_pixel(top[0] + ((left[y] - left[-1]) &gt;&gt; 1));
        }
    } else {
    	//水平类模式

        ref = left - 1;
        if (angle &lt; 0 &amp;&amp; last &lt; -1) {
            for (x = 0; x &lt;= size; x += 4)
                AV_WN4P(&amp;ref_tmp[x], AV_RN4P(&amp;left[x - 1]));
            for (x = last; x &lt;= -1; x++)
                ref_tmp[x] = top[-1 + ((x * inv_angle[mode - 11] + 128) &gt;&gt; 8)];
            ref = ref_tmp;
        }

        for (x = 0; x &lt; size; x++) {
            int idx  = ((x + 1) * angle) &gt;&gt; 5;
            int fact = ((x + 1) * angle) &amp; 31;
            if (fact) {
                for (y = 0; y &lt; size; y++) {
                    POS(x, y) = ((32 - fact) * ref[y + idx + 1] +
                                       fact  * ref[y + idx + 2] + 16) &gt;&gt; 5;
                }
            } else {
                for (y = 0; y &lt; size; y++)
                    POS(x, y) = ref[y + idx + 1];
            }
        }
        if (mode == 10 &amp;&amp; c_idx == 0 &amp;&amp; size &lt; 32) {
            for (x = 0; x &lt; size; x += 4) {
                POS(x,     0) = av_clip_pixel(left[0] + ((top[x    ] - top[-1]) &gt;&gt; 1));
                POS(x + 1, 0) = av_clip_pixel(left[0] + ((top[x + 1] - top[-1]) &gt;&gt; 1));
                POS(x + 2, 0) = av_clip_pixel(left[0] + ((top[x + 2] - top[-1]) &gt;&gt; 1));
                POS(x + 3, 0) = av_clip_pixel(left[0] + ((top[x + 3] - top[-1]) &gt;&gt; 1));
            }
        }
    }
}
</pre><br />pred_planar_8()的代码还没有细看，以后有时间再做分析。<br />至此有关帧内预测方面的源代码就基本分析完了。后文继续分析DCT反变换相关的源代码。<br /><h3><br /></h3><h2>DCT反变换汇编函数源代码</h2>DCT反变换相关的汇编函数位于HEVCDSPContext中。HEVCDSPContext的初始化函数是ff_hevc_dsp_init()。该函数对HEVCDSPContext结构体中的函数指针进行了赋值。FFmpeg HEVC解码器运行的过程中只要调用HEVCDSPContext的函数指针就可以完成相应的功能。<br /><br /><h3>ff_hevc_dsp_init()</h3>ff_hevc_dsp_init()用于初始化HEVCDSPContext结构体中的汇编函数指针。该函数的定义如下所示。<br /><pre name="code" class="cpp">void ff_hevc_dsp_init(HEVCDSPContext *hevcdsp, int bit_depth)
{
#undef FUNC
#define FUNC(a, depth) a ## _ ## depth

#undef PEL_FUNC
#define PEL_FUNC(dst1, idx1, idx2, a, depth)                                   \
    for(i = 0 ; i &lt; 10 ; i++)                                                  \
{                                                                              \
    hevcdsp-&gt;dst1[i][idx1][idx2] = a ## _ ## depth;                            \
}

#undef EPEL_FUNCS
#define EPEL_FUNCS(depth)                                                     \
    PEL_FUNC(put_hevc_epel, 0, 0, put_hevc_pel_pixels, depth);                \
    PEL_FUNC(put_hevc_epel, 0, 1, put_hevc_epel_h, depth);                    \
    PEL_FUNC(put_hevc_epel, 1, 0, put_hevc_epel_v, depth);                    \
    PEL_FUNC(put_hevc_epel, 1, 1, put_hevc_epel_hv, depth)

#undef EPEL_UNI_FUNCS
#define EPEL_UNI_FUNCS(depth)                                                 \
    PEL_FUNC(put_hevc_epel_uni, 0, 0, put_hevc_pel_uni_pixels, depth);        \
    PEL_FUNC(put_hevc_epel_uni, 0, 1, put_hevc_epel_uni_h, depth);            \
    PEL_FUNC(put_hevc_epel_uni, 1, 0, put_hevc_epel_uni_v, depth);            \
    PEL_FUNC(put_hevc_epel_uni, 1, 1, put_hevc_epel_uni_hv, depth);           \
    PEL_FUNC(put_hevc_epel_uni_w, 0, 0, put_hevc_pel_uni_w_pixels, depth);    \
    PEL_FUNC(put_hevc_epel_uni_w, 0, 1, put_hevc_epel_uni_w_h, depth);        \
    PEL_FUNC(put_hevc_epel_uni_w, 1, 0, put_hevc_epel_uni_w_v, depth);        \
    PEL_FUNC(put_hevc_epel_uni_w, 1, 1, put_hevc_epel_uni_w_hv, depth)

#undef EPEL_BI_FUNCS
#define EPEL_BI_FUNCS(depth)                                                \
    PEL_FUNC(put_hevc_epel_bi, 0, 0, put_hevc_pel_bi_pixels, depth);        \
    PEL_FUNC(put_hevc_epel_bi, 0, 1, put_hevc_epel_bi_h, depth);            \
    PEL_FUNC(put_hevc_epel_bi, 1, 0, put_hevc_epel_bi_v, depth);            \
    PEL_FUNC(put_hevc_epel_bi, 1, 1, put_hevc_epel_bi_hv, depth);           \
    PEL_FUNC(put_hevc_epel_bi_w, 0, 0, put_hevc_pel_bi_w_pixels, depth);    \
    PEL_FUNC(put_hevc_epel_bi_w, 0, 1, put_hevc_epel_bi_w_h, depth);        \
    PEL_FUNC(put_hevc_epel_bi_w, 1, 0, put_hevc_epel_bi_w_v, depth);        \
    PEL_FUNC(put_hevc_epel_bi_w, 1, 1, put_hevc_epel_bi_w_hv, depth)

#undef QPEL_FUNCS
#define QPEL_FUNCS(depth)                                                     \
    PEL_FUNC(put_hevc_qpel, 0, 0, put_hevc_pel_pixels, depth);                \
    PEL_FUNC(put_hevc_qpel, 0, 1, put_hevc_qpel_h, depth);                    \
    PEL_FUNC(put_hevc_qpel, 1, 0, put_hevc_qpel_v, depth);                    \
    PEL_FUNC(put_hevc_qpel, 1, 1, put_hevc_qpel_hv, depth)

#undef QPEL_UNI_FUNCS
#define QPEL_UNI_FUNCS(depth)                                                 \
    PEL_FUNC(put_hevc_qpel_uni, 0, 0, put_hevc_pel_uni_pixels, depth);        \
    PEL_FUNC(put_hevc_qpel_uni, 0, 1, put_hevc_qpel_uni_h, depth);            \
    PEL_FUNC(put_hevc_qpel_uni, 1, 0, put_hevc_qpel_uni_v, depth);            \
    PEL_FUNC(put_hevc_qpel_uni, 1, 1, put_hevc_qpel_uni_hv, depth);           \
    PEL_FUNC(put_hevc_qpel_uni_w, 0, 0, put_hevc_pel_uni_w_pixels, depth);    \
    PEL_FUNC(put_hevc_qpel_uni_w, 0, 1, put_hevc_qpel_uni_w_h, depth);        \
    PEL_FUNC(put_hevc_qpel_uni_w, 1, 0, put_hevc_qpel_uni_w_v, depth);        \
    PEL_FUNC(put_hevc_qpel_uni_w, 1, 1, put_hevc_qpel_uni_w_hv, depth)

#undef QPEL_BI_FUNCS
#define QPEL_BI_FUNCS(depth)                                                  \
    PEL_FUNC(put_hevc_qpel_bi, 0, 0, put_hevc_pel_bi_pixels, depth);          \
    PEL_FUNC(put_hevc_qpel_bi, 0, 1, put_hevc_qpel_bi_h, depth);              \
    PEL_FUNC(put_hevc_qpel_bi, 1, 0, put_hevc_qpel_bi_v, depth);              \
    PEL_FUNC(put_hevc_qpel_bi, 1, 1, put_hevc_qpel_bi_hv, depth);             \
    PEL_FUNC(put_hevc_qpel_bi_w, 0, 0, put_hevc_pel_bi_w_pixels, depth);      \
    PEL_FUNC(put_hevc_qpel_bi_w, 0, 1, put_hevc_qpel_bi_w_h, depth);          \
    PEL_FUNC(put_hevc_qpel_bi_w, 1, 0, put_hevc_qpel_bi_w_v, depth);          \
    PEL_FUNC(put_hevc_qpel_bi_w, 1, 1, put_hevc_qpel_bi_w_hv, depth)

#define HEVC_DSP(depth)                                                     \
    hevcdsp-&gt;put_pcm                = FUNC(put_pcm, depth);                 \
    hevcdsp-&gt;transform_add[0]       = FUNC(transform_add4x4, depth);        \
    hevcdsp-&gt;transform_add[1]       = FUNC(transform_add8x8, depth);        \
    hevcdsp-&gt;transform_add[2]       = FUNC(transform_add16x16, depth);      \
    hevcdsp-&gt;transform_add[3]       = FUNC(transform_add32x32, depth);      \
    hevcdsp-&gt;transform_skip         = FUNC(transform_skip, depth);          \
    hevcdsp-&gt;transform_rdpcm        = FUNC(transform_rdpcm, depth);         \
    hevcdsp-&gt;idct_4x4_luma          = FUNC(transform_4x4_luma, depth);      \
    hevcdsp-&gt;idct[0]                = FUNC(idct_4x4, depth);                \
    hevcdsp-&gt;idct[1]                = FUNC(idct_8x8, depth);                \
    hevcdsp-&gt;idct[2]                = FUNC(idct_16x16, depth);              \
    hevcdsp-&gt;idct[3]                = FUNC(idct_32x32, depth);              \
                                                                            \
    hevcdsp-&gt;idct_dc[0]             = FUNC(idct_4x4_dc, depth);             \
    hevcdsp-&gt;idct_dc[1]             = FUNC(idct_8x8_dc, depth);             \
    hevcdsp-&gt;idct_dc[2]             = FUNC(idct_16x16_dc, depth);           \
    hevcdsp-&gt;idct_dc[3]             = FUNC(idct_32x32_dc, depth);           \
                                                                            \
    hevcdsp-&gt;sao_band_filter    = FUNC(sao_band_filter_0, depth);              \
    hevcdsp-&gt;sao_edge_filter[0] = FUNC(sao_edge_filter_0, depth);              \
    hevcdsp-&gt;sao_edge_filter[1] = FUNC(sao_edge_filter_1, depth);              \
                                                                               \
    QPEL_FUNCS(depth);                                                         \
    QPEL_UNI_FUNCS(depth);                                                     \
    QPEL_BI_FUNCS(depth);                                                      \
    EPEL_FUNCS(depth);                                                         \
    EPEL_UNI_FUNCS(depth);                                                     \
    EPEL_BI_FUNCS(depth);                                                      \
                                                                               \
    hevcdsp-&gt;hevc_h_loop_filter_luma     = FUNC(hevc_h_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_v_loop_filter_luma     = FUNC(hevc_v_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_h_loop_filter_chroma   = FUNC(hevc_h_loop_filter_chroma, depth); \
    hevcdsp-&gt;hevc_v_loop_filter_chroma   = FUNC(hevc_v_loop_filter_chroma, depth); \
    hevcdsp-&gt;hevc_h_loop_filter_luma_c   = FUNC(hevc_h_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_v_loop_filter_luma_c   = FUNC(hevc_v_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_h_loop_filter_chroma_c = FUNC(hevc_h_loop_filter_chroma, depth); \
    hevcdsp-&gt;hevc_v_loop_filter_chroma_c = FUNC(hevc_v_loop_filter_chroma, depth)
int i = 0;

    switch (bit_depth) {
    case 9:
        HEVC_DSP(9);
        break;
    case 10:
        HEVC_DSP(10);
        break;
    case 12:
        HEVC_DSP(12);
        break;
    default:
        HEVC_DSP(8);
        break;
    }

    if (ARCH_X86)
        ff_hevc_dsp_init_x86(hevcdsp, bit_depth);
}
</pre><br />从源代码可以看出，ff_hevc_dsp_init()函数中包含一个名为“HEVC_DSP(depth)”的很长的宏定义。该宏定义中包含了C语言版本的各种函数的初始化代码。ff_hevc_dsp_init()会根据系统的颜色位深bit_depth初始化相应的C语言版本的函数。在函数的末尾则包含了汇编函数的初始化函数：如果系统是X86架构的，则会调用ff_hevc_dsp_init_x86()初始化X86平台下经过汇编优化的函数。下面以8bit颜色位深为例，看一下“HEVC_DSP(8)”的展开结果中和DCT相关的函数。<br /><span style="white-space:pre"></span><pre name="code" class="cpp">hevcdsp-&gt;transform_add[0]       = transform_add4x4_8;        
hevcdsp-&gt;transform_add[1]       = transform_add8x8_8;        
hevcdsp-&gt;transform_add[2]       = transform_add16x16_8;      
hevcdsp-&gt;transform_add[3]       = transform_add32x32_8;      
hevcdsp-&gt;transform_skip         = transform_skip_8;          
hevcdsp-&gt;transform_rdpcm        = transform_rdpcm_8;         
hevcdsp-&gt;idct_4x4_luma          = transform_4x4_luma_8;      
hevcdsp-&gt;idct[0]                = idct_4x4_8;                
hevcdsp-&gt;idct[1]                = idct_8x8_8;                
hevcdsp-&gt;idct[2]                = idct_16x16_8;              
hevcdsp-&gt;idct[3]                = idct_32x32_8;              
																		
hevcdsp-&gt;idct_dc[0]             = idct_4x4_dc_8;             
hevcdsp-&gt;idct_dc[1]             = idct_8x8_dc_8;             
hevcdsp-&gt;idct_dc[2]             = idct_16x16_dc_8;           
hevcdsp-&gt;idct_dc[3]             = idct_32x32_dc_8;           
//略….						<span style="font-family: Arial, Helvetica, sans-serif;">																</span></pre>通过上述代码可以总结出下面几个IDCT函数（数组）：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">HEVCDSPContext -&gt; idct[4]()：DCT反变换函数。数组中4个函数分别处理4x4，8x8，16x16，32x32几种块。<br />HEVCDSPContext -&gt; idct_dc[4]() ：只有DC系数时候的DCT反变换函数（运算速度比普通DCT快一些）。数组中4个函数分别处理4x4，8x8，16x16，32x32几种块。<br />HEVCDSPContext -&gt; idct_4x4_luma()：特殊的4x4DST反变换函数。在处理Intra4x4块的时候，HEVC使用了一种比较特殊的DST（而不是DCT），可以微量的提高编码效率。<br />HEVCDSPContext -&gt; transform_add[4]()：残差叠加函数，用于将IDCT之后的残差像素数据叠加到预测像素数据之上。数组中4个函数分别处理4x4，8x8，16x16，32x32几种块。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><span style="font-family:FangSong_GB2312;">PS：还有几种IDCT函数目前还没有看，就不列出了。</span></blockquote>下面分别看一下上述的几种函数。<br /><br /><h3>HEVCDSPContext -&gt; idct[4]()</h3>HEVCPredContext -&gt; idct[4]()指向了DCT反变换的汇编函数。数组中4个元素分别处理4x4，8x8，16x16，32x32几种块。这几种块的具体C语言版本处理函数为：&nbsp;<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">idct_4x4_8()——4x4块；<br />idct_8x8_8()——8x8块；<br />idct_16x16_8()——16x16块；<br />idct_32x32_8()——32x32块；</blockquote>这四个函数的定义如下所示。<br /><pre name="code" class="cpp">#define SET(dst, x)   (dst) = (x)
#define SCALE(dst, x) (dst) = av_clip_int16(((x) + add) &gt;&gt; shift)
#define ADD_AND_SCALE(dst, x)                                           \
    (dst) = av_clip_pixel((dst) + av_clip_int16(((x) + add) &gt;&gt; shift))

#define IDCT_VAR4(H)                                                          \
    int      limit2   = FFMIN(col_limit + 4, H)
#define IDCT_VAR8(H)                                                          \
        int      limit   = FFMIN(col_limit, H);                               \
        int      limit2   = FFMIN(col_limit + 4, H)
#define IDCT_VAR16(H)   IDCT_VAR8(H)
#define IDCT_VAR32(H)   IDCT_VAR8(H)

//其中的“H”取4,8,16,32
//可以拼凑出不同的函数
#define IDCT(H)                                                              \
static void FUNC(idct_##H ##x ##H )(                                         \
                   int16_t *coeffs, int col_limit) {                         \
    int i;                                                                   \
    int      shift   = 7;                                                    \
    int      add     = 1 &lt;&lt; (shift - 1);                                     \
    int16_t *src     = coeffs;                                               \
    IDCT_VAR ##H(H);                                                         \
                                                                             \
    for (i = 0; i &lt; H; i++) {                                                \
        TR_ ## H(src, src, H, H, SCALE, limit2);                             \
        if (limit2 &lt; H &amp;&amp; i%4 == 0 &amp;&amp; !!i)                                   \
            limit2 -= 4;                                                     \
        src++;                                                               \
    }                                                                        \
                                                                             \
    shift   = 20 - BIT_DEPTH;                                                \
    add     = 1 &lt;&lt; (shift - 1);                                              \
    for (i = 0; i &lt; H; i++) {                                                \
        TR_ ## H(coeffs, coeffs, 1, 1, SCALE, limit);                        \
        coeffs += H;                                                         \
    }                                                                        \
}

//几种不同尺度的IDCT
IDCT( 4)
IDCT( 8)
IDCT(16)
IDCT(32)
</pre><br />从源代码可以看出，idct_4x4_8()、idct_8x8_8()等函数的定义是通过“IDCT()”宏实现的。而“IDCT(H)”宏中又调用了另外一个宏“TR_ ## H()”。“TR_ ## H()”根据“H”取值的不同，可以调用：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">TR_4()——用于4x4DCT<br />TR_8()——用于8x8DCT<br />TR_16()——用于16x16DCT<br />TR_32()——用于32x32DCT</blockquote>TR4()、TR8()、TR16()、TR32()的定义如下所示。<br /><pre name="code" class="cpp">/*
 * 4x4DCT
 *
 *     | 64  64  64  64 |
 * H = | 83  36 -36 -83 |
 *     | 64 -64 -64  64 |
 *     | 36 -83  83 -36 |
 *
 */
#define TR_4(dst, src, dstep, sstep, assign, end)                              \
    do {                                                                       \
        const int e0 = 64 * src[0 * sstep] + 64 * src[2 * sstep];              \
        const int e1 = 64 * src[0 * sstep] - 64 * src[2 * sstep];              \
        const int o0 = 83 * src[1 * sstep] + 36 * src[3 * sstep];              \
        const int o1 = 36 * src[1 * sstep] - 83 * src[3 * sstep];              \
                                                                               \
        assign(dst[0 * dstep], e0 + o0);                                       \
        assign(dst[1 * dstep], e1 + o1);                                       \
        assign(dst[2 * dstep], e1 - o1);                                       \
        assign(dst[3 * dstep], e0 - o0);                                       \
    } while (0)

/*
 * 8x8DCT
 *
 * transform[]存储了32x32DCT变换系数
 * 8x8DCT变换的系数来自于32x32系数矩阵中第0，4，8，12，16，20，24，28行元素中的前8个元素
 *
 */
#define TR_8(dst, src, dstep, sstep, assign, end)                              \
    do {                                                                       \
        int i, j;                                                              \
        int e_8[4];                                                            \
        int o_8[4] = { 0 };                                                    \
        for (i = 0; i &lt; 4; i++)                                                \
            for (j = 1; j &lt; end; j += 2)                                       \
                o_8[i] += transform[4 * j][i] * src[j * sstep];                \
        TR_4(e_8, src, 1, 2 * sstep, SET, 4);                                  \
                                                                               \
        for (i = 0; i &lt; 4; i++) {                                              \
            assign(dst[i * dstep], e_8[i] + o_8[i]);                           \
            assign(dst[(7 - i) * dstep], e_8[i] - o_8[i]);                     \
        }                                                                      \
    } while (0)

/*
 * 16x16DCT
 * 16x16 DCT变换的系数来自于32x32系数矩阵中第0，2，4…，28，30行元素中的前16个元素
 *
 */
#define TR_16(dst, src, dstep, sstep, assign, end)                             \
    do {                                                                       \
        int i, j;                                                              \
        int e_16[8];                                                           \
        int o_16[8] = { 0 };                                                   \
        for (i = 0; i &lt; 8; i++)                                                \
            for (j = 1; j &lt; end; j += 2)                                       \
                o_16[i] += transform[2 * j][i] * src[j * sstep];               \
        TR_8(e_16, src, 1, 2 * sstep, SET, 8);                                 \
                                                                               \
        for (i = 0; i &lt; 8; i++) {                                              \
            assign(dst[i * dstep], e_16[i] + o_16[i]);                         \
            assign(dst[(15 - i) * dstep], e_16[i] - o_16[i]);                  \
        }                                                                      \
    } while (0)

/*
 * 32x32DCT
 *
 */
#define TR_32(dst, src, dstep, sstep, assign, end)                             \
    do {                                                                       \
        int i, j;                                                              \
        int e_32[16];                                                          \
        int o_32[16] = { 0 };                                                  \
        for (i = 0; i &lt; 16; i++)                                               \
            for (j = 1; j &lt; end; j += 2)                                       \
                o_32[i] += transform[j][i] * src[j * sstep];                   \
        TR_16(e_32, src, 1, 2 * sstep, SET, end/2);                            \
                                                                               \
        for (i = 0; i &lt; 16; i++) {                                             \
            assign(dst[i * dstep], e_32[i] + o_32[i]);                         \
            assign(dst[(31 - i) * dstep], e_32[i] - o_32[i]);                  \
        }                                                                      \
    } while (0)
</pre><br />有关这一部分的源代码目前还没有细看，以后有时间再进行补充。从TR8()、TR16()等的定义中可以看出，它们的DCT系数来自于一个transform[32][32]数组。<br /><br /><strong>transform[32][32]</strong><br />transform[32][32] 的定义如下所示，其中存储了32x32DCT的系数。使用该系数矩阵，也可以推导获得16x16DCT、8x8DCT、4x4DCT的系数。<br /><pre name="code" class="cpp">//32x32DCT变换系数
static const int8_t transform[32][32] = {
    { 64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,
      64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64 },
    { 90,  90,  88,  85,  82,  78,  73,  67,  61,  54,  46,  38,  31,  22,  13,   4,
      -4, -13, -22, -31, -38, -46, -54, -61, -67, -73, -78, -82, -85, -88, -90, -90 },
    { 90,  87,  80,  70,  57,  43,  25,   9,  -9, -25, -43, -57, -70, -80, -87, -90,
     -90, -87, -80, -70, -57, -43, -25,  -9,   9,  25,  43,  57,  70,  80,  87,  90 },
    { 90,  82,  67,  46,  22,  -4, -31, -54, -73, -85, -90, -88, -78, -61, -38, -13,
      13,  38,  61,  78,  88,  90,  85,  73,  54,  31,   4, -22, -46, -67, -82, -90 },
    { 89,  75,  50,  18, -18, -50, -75, -89, -89, -75, -50, -18,  18,  50,  75,  89,
      89,  75,  50,  18, -18, -50, -75, -89, -89, -75, -50, -18,  18,  50,  75,  89 },
    { 88,  67,  31, -13, -54, -82, -90, -78, -46, -4,   38,  73,  90,  85,  61,  22,
     -22, -61, -85, -90, -73, -38,   4,  46,  78,  90,  82,  54,  13, -31, -67, -88 },
    { 87,  57,   9, -43, -80, -90, -70, -25,  25,  70,  90,  80,  43,  -9, -57, -87,
     -87, -57,  -9,  43,  80,  90,  70,  25, -25, -70, -90, -80, -43,   9,  57,  87 },
    { 85,  46, -13, -67, -90, -73, -22,  38,  82,  88,  54,  -4, -61, -90, -78, -31,
      31,  78,  90,  61,   4, -54, -88, -82, -38,  22,  73,  90,  67,  13, -46, -85 },
    { 83,  36, -36, -83, -83, -36,  36,  83,  83,  36, -36, -83, -83, -36,  36,  83,
      83,  36, -36, -83, -83, -36,  36,  83,  83,  36, -36, -83, -83, -36,  36,  83 },
    { 82,  22, -54, -90, -61,  13,  78,  85,  31, -46, -90, -67,   4,  73,  88,  38,
     -38, -88, -73,  -4,  67,  90,  46, -31, -85, -78, -13,  61,  90,  54, -22, -82 },
    { 80,   9, -70, -87, -25,  57,  90,  43, -43, -90, -57,  25,  87,  70,  -9, -80,
     -80,  -9,  70,  87,  25, -57, -90, -43,  43,  90,  57, -25, -87, -70,   9,  80 },
    { 78,  -4, -82, -73,  13,  85,  67, -22, -88, -61,  31,  90,  54, -38, -90, -46,
      46,  90,  38, -54, -90, -31,  61,  88,  22, -67, -85, -13,  73,  82,   4, -78 },
    { 75, -18, -89, -50,  50,  89,  18, -75, -75,  18,  89,  50, -50, -89, -18,  75,
      75, -18, -89, -50,  50,  89,  18, -75, -75,  18,  89,  50, -50, -89, -18,  75 },
    { 73, -31, -90, -22,  78,  67, -38, -90, -13,  82,  61, -46, -88,  -4,  85,  54,
     -54, -85,   4,  88,  46, -61, -82,  13,  90,  38, -67, -78,  22,  90,  31, -73 },
    { 70, -43, -87,   9,  90,  25, -80, -57,  57,  80, -25, -90,  -9,  87,  43, -70,
     -70,  43,  87,  -9, -90, -25,  80,  57, -57, -80,  25,  90,   9, -87, -43,  70 },
    { 67, -54, -78,  38,  85, -22, -90,   4,  90,  13, -88, -31,  82,  46, -73, -61,
      61,  73, -46, -82,  31,  88, -13, -90,  -4,  90,  22, -85, -38,  78,  54, -67 },
    { 64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64,
      64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64 },
    { 61, -73, -46,  82,  31, -88, -13,  90,  -4, -90,  22,  85, -38, -78,  54,  67,
     -67, -54,  78,  38, -85, -22,  90,   4, -90,  13,  88, -31, -82,  46,  73, -61 },
    { 57, -80, -25,  90,  -9, -87,  43,  70, -70, -43,  87,   9, -90,  25,  80, -57,
     -57,  80,  25, -90,   9,  87, -43, -70,  70,  43, -87,  -9,  90, -25, -80,  57 },
    { 54, -85,  -4,  88, -46, -61,  82,  13, -90,  38,  67, -78, -22,  90, -31, -73,
      73,  31, -90,  22,  78, -67, -38,  90, -13, -82,  61,  46, -88,   4,  85, -54 },
    { 50, -89,  18,  75, -75, -18,  89, -50, -50,  89, -18, -75,  75,  18, -89,  50,
      50, -89,  18,  75, -75, -18,  89, -50, -50,  89, -18, -75,  75,  18, -89,  50 },
    { 46, -90,  38,  54, -90,  31,  61, -88,  22,  67, -85,  13,  73, -82,   4,  78,
     -78,  -4,  82, -73, -13,  85, -67, -22,  88, -61, -31,  90, -54, -38,  90, -46 },
    { 43, -90,  57,  25, -87,  70,   9, -80,  80,  -9, -70,  87, -25, -57,  90, -43,
     -43,  90, -57, -25,  87, -70,  -9,  80, -80,   9,  70, -87,  25,  57, -90,  43 },
    { 38, -88,  73,  -4, -67,  90, -46, -31,  85, -78,  13,  61, -90,  54,  22, -82,
      82, -22, -54,  90, -61, -13,  78, -85,  31,  46, -90,  67,   4, -73,  88, -38 },
    { 36, -83,  83, -36, -36,  83, -83,  36,  36, -83,  83, -36, -36,  83, -83,  36,
      36, -83,  83, -36, -36,  83, -83,  36,  36, -83,  83, -36, -36,  83, -83,  36 },
    { 31, -78,  90, -61,   4,  54, -88,  82, -38, -22,  73, -90,  67, -13, -46,  85,
     -85,  46,  13, -67,  90, -73,  22,  38, -82,  88, -54,  -4,  61, -90,  78, -31 },
    { 25, -70,  90, -80,  43,   9, -57,  87, -87,  57,  -9, -43,  80, -90,  70, -25,
     -25,  70, -90,  80, -43,  -9,  57, -87,  87, -57,   9,  43, -80,  90, -70,  25 },
    { 22, -61,  85, -90,  73, -38,  -4,  46, -78,  90, -82,  54, -13, -31,  67, -88,
      88, -67,  31,  13, -54,  82, -90,  78, -46,   4,  38, -73,  90, -85,  61, -22 },
    { 18, -50,  75, -89,  89, -75,  50, -18, -18,  50, -75,  89, -89,  75, -50,  18,
      18, -50,  75, -89,  89, -75,  50, -18, -18,  50, -75,  89, -89,  75, -50,  18 },
    { 13, -38,  61, -78,  88, -90,  85, -73,  54, -31,   4,  22, -46,  67, -82,  90,
     -90,  82, -67,  46, -22,  -4,  31, -54,  73, -85,  90, -88,  78, -61,  38, -13 },
    {  9, -25,  43, -57,  70, -80,  87, -90,  90, -87,  80, -70,  57, -43,  25, -9,
      -9,  25, -43,  57, -70,  80, -87,  90, -90,  87, -80,  70, -57,  43, -25,   9 },
    {  4, -13,  22, -31,  38, -46,  54, -61,  67, -73,  78, -82,  85, -88,  90, -90,
      90, -90,  88, -85,  82, -78,  73, -67,  61, -54,  46, -38,  31, -22,  13,  -4 },
};</pre><br /><h3>HEVCDSPContext -&gt; idct_dc[4]()</h3>HEVCPredContext -&gt; idct_dc[4]()指向了只有DC系数时候的DCT反变换的汇编函数。只有DC系数的DCT反变换属于一种比较特殊的情况，在这种情况下使用idct_dc[4]()的速度会比idct[4]()要快一些。数组中4个元素分别处理4x4，8x8，16x16，32x32几种块。这几种块的具体C语言版本处理函数为：&nbsp;<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">idct_4x4_dc_8()——4x4块；<br />idct_8x8_dc_8()——8x8块；<br />idct_16x16_dc_8()——16x16块；<br />idct_32x32_dc_8()——32x32块；</blockquote>这四个函数的定义如下所示。<br /><pre name="code" class="cpp">#define IDCT_DC(H)                                                           \
static void FUNC(idct_##H ##x ##H ##_dc)(                                    \
                   int16_t *coeffs) {                                        \
    int i, j;                                                                \
    int      shift   = 14 - BIT_DEPTH;                                       \
    int      add     = 1 &lt;&lt; (shift - 1);                                     \
    int      coeff   = (((coeffs[0] + 1) &gt;&gt; 1) + add) &gt;&gt; shift;              \
                                                                             \
    for (j = 0; j &lt; H; j++) {                                                \
        for (i = 0; i &lt; H; i++) {                                            \
            coeffs[i+j*H] = coeff;                                           \
        }                                                                    \
    }                                                                        \
}


//只包含DC系数时候的比较快速的IDCT
IDCT_DC( 4)
IDCT_DC( 8)
IDCT_DC(16)
IDCT_DC(32)
</pre><br />可以看出idct_4x4_dc_8()、idct_8x8_dc_8()等函数的初始化是通过“IDCT_DC()”宏完成的。可以看出“IDCT_DC()”首先通过DC系数coeffs[0]换算得到值coeff，然后将coeff赋值给系数矩阵中的每个系数。<br /><br /><h3>HEVCDSPContext -&gt; idct_4x4_luma()</h3>HEVCDSPContext -&gt; idct_4x4_luma()指向处理Intra4x4的CU的DST反变换。相比于视频编码中常见的DCT反变换，DST反变换算是一种比较特殊的变换。4x4DST反变换的C语言版本函数是transform_4x4_luma_8()，它的定义如下所示。<br /><pre name="code" class="cpp">#define SCALE(dst, x) (dst) = av_clip_int16(((x) + add) &gt;&gt; shift)

/*
 * 4x4DST
 *
 *     | 29  55  74  84 |
 * H = | 74  74   0 -74 |
 *     | 84 -29 -74  55 |
 *     | 55 -84  74 -29 |
 *
 */
#define TR_4x4_LUMA(dst, src, step, assign)                             \
    do {                                                                \
        int c0 = src[0 * step] + src[2 * step];                         \
        int c1 = src[2 * step] + src[3 * step];                         \
        int c2 = src[0 * step] - src[3 * step];                         \
        int c3 = 74 * src[1 * step];                                    \
                                                                        \
        assign(dst[2 * step], 74 * (src[0 * step] -                     \
                                    src[2 * step] +                     \
                                    src[3 * step]));                    \
        assign(dst[0 * step], 29 * c0 + 55 * c1 + c3);                  \
        assign(dst[1 * step], 55 * c2 - 29 * c1 + c3);                  \
        assign(dst[3 * step], 55 * c0 + 29 * c2 - c3);                  \
    } while (0)

//4x4DST
static void FUNC(transform_4x4_luma)(int16_t *coeffs)
{
    int i;
    int shift    = 7;
    int add      = 1 &lt;&lt; (shift - 1);
    int16_t *src = coeffs;

    for (i = 0; i &lt; 4; i++) {
        TR_4x4_LUMA(src, src, 4, SCALE);
        src++;
    }

    shift = 20 - BIT_DEPTH;
    add   = 1 &lt;&lt; (shift - 1);
    for (i = 0; i &lt; 4; i++) {
        TR_4x4_LUMA(coeffs, coeffs, 1, SCALE);
        coeffs += 4;
    }
}

#undef TR_4x4_LUMA
</pre><br />从源代码可以看出，transform_4x4_luma_8()调用TR_4x4_LUMA()完成了4x4DST的工作。<br /><br /><h3>HEVCDSPContext -&gt; transform_add[4]()</h3>HEVCDSPContext -&gt; transform_add[4]()指向了叠加残差数据的汇编函数。这些函数用于将残差像素数据叠加到预测像素数据上，形成最后的解码图像数据。数组中4个元素分别处理4x4，8x8，16x16，32x32几种块。这几种块的具体C语言版本处理函数为：&nbsp;<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">transform_add4x4_8()——4x4块；<br />transform_add8x8_8()——8x8块；<br />transform_add16x16_8()——16x16块；<br />transform_add32x32_8()——32x32块；</blockquote>这四个函数的定义如下所示。<br /><pre name="code" class="cpp">//叠加4x4方块的残差数据
static void FUNC(transform_add4x4)(uint8_t *_dst, int16_t *coeffs,
                                       ptrdiff_t stride)
{
	//最后一个参数为4
    FUNC(transquant_bypass)(_dst, coeffs, stride, 4);
}
//叠加8x8方块的残差数据
static void FUNC(transform_add8x8)(uint8_t *_dst, int16_t *coeffs,
                                       ptrdiff_t stride)
{
	//最后一个参数为8
    FUNC(transquant_bypass)(_dst, coeffs, stride, 8);
}
//叠加16x16方块的残差数据
static void FUNC(transform_add16x16)(uint8_t *_dst, int16_t *coeffs,
                                         ptrdiff_t stride)
{
	//最后一个参数为16
    FUNC(transquant_bypass)(_dst, coeffs, stride, 16);
}
//叠加32x32方块的残差数据
static void FUNC(transform_add32x32)(uint8_t *_dst, int16_t *coeffs,
                                         ptrdiff_t stride)
{
	//最后一个参数为32
    FUNC(transquant_bypass)(_dst, coeffs, stride, 32);
}
</pre><br />从源代码可以看出，transform_add4x4_8()、transform_add8x8_8()等函数内部都调用了同样一个函数transquant_bypass_8()，它们的不同在于传递给transquant_bypass_8()的最后一个参数size的值不同。<br /><br /><strong>transquant_bypass_8()</strong><br />transquant_bypass_8()完成了残差像素数据叠加的工作。该函数的定义如下所示。<br /><pre name="code" class="cpp">//叠加残差数据，transquant_bypass_8()
static av_always_inline void FUNC(transquant_bypass)(uint8_t *_dst, int16_t *coeffs,
                                                     ptrdiff_t stride, int size)
{
    int x, y;
    pixel *dst = (pixel *)_dst;

    stride /= sizeof(pixel);
    //逐个叠加每个点
    for (y = 0; y &lt; size; y++) {
        for (x = 0; x &lt; size; x++) {
            dst[x] = av_clip_pixel(dst[x] + *coeffs);//叠加，av_clip_pixel()用于限幅。处理的数据一直存储于dst
            coeffs++;
        }
        dst += stride;
    }
}
</pre><br />从源代码中可以看出，transquant_bypass_8()将残差数据coeff依次叠加到了预测数据dst之上。<br /><br />至此有关IDCT方面的源代码就基本分析完毕了。<br /><br /><br /><br /><br /><br /><strong><span style="color:#660000;">雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</span></strong><br /><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/46451119		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&t=blog" target="_blank">FFmpeg						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=libavcodec&t=blog" target="_blank">libavcodec						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=HEVC&t=blog" target="_blank">HEVC						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=解码器&t=blog" target="_blank">解码器						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=TU&t=blog" target="_blank">TU						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795"  target="_blank">FFMPEG						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">FFmpeg</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div data-track-view='{"mod":"popu_625","con": ",https://blog.csdn.net/leixiaohua1020/article/details/46451119,from_360"}' style="margin-top: 8px;padding: 20px;background-color: #fff;overflow: hidden;" id="adt0"></div>
                            <script>
                                var adWidth = $("div.blog-content-box").outerWidth() - 40;
                                NEWS_FEED({
                                    w: adWidth,
                                    h : 130,
                                    showid : "s02a31",
                                    placeholderId: "adt0",
                                    inject : "define",
                                    define : {
                                    imagePosition : "right",
                                    imageBorderRadius : 0,
                                    imageWidth: 231,
                                    imageHeight: 130,
                                    imageFill : "clip",
                                    displayImage : true,
                                    displayTitle : true,
                                    titleFontSize: 20,
                                    titleFontColor: "#333",
                                    titleFontFamily : "Microsoft Yahei",
                                    titleFontWeight: "bold",
                                    titlePaddingTop : 0,
                                    titlePaddingRight : 0,
                                    titlePaddingBottom : 10,
                                    titlePaddingLeft : 0,
                                    displayDesc : true,
                                    descFontSize: 14,
                                    descFontColor: "#6b6b6b",
                                    descFontFamily : "Microsoft Yahei",
                                    paddingTop : 0,
                                    paddingRight : 0,
                                    paddingBottom : 0,
                                    paddingLeft : 0,
                                    backgroundColor: "#fff",
                                    hoverColor: "#ca0c16"
                                    }
                                })
                            </script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46451119#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/Runningzyx/article/details/52525110" target="_blank" strategy="BlogCommendFromBaidu_0">
				AAC 文件解析及<em>解码</em>流程			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/Runningzyx/article/details/52525110" target="_blank" >
				OUTLINE：
         ＊ AAC概述
         ＊ AAC规格简述
         ＊ AAC特点    
         ＊ AAC音频文件解析
            —...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/Runningzyx" title="Runningzyx" target="_blank">
					<img src="https://avatar.csdn.net/1/2/9/3_runningzyx.jpg" alt="Runningzyx" class="avatar-pic">
					<span class="name">Runningzyx</span>
				</a>
			</p>
			<p>
				<span class="date">2016-09-13 13:34:38</span>
			</p>
			<p>
				<span class="read-num">阅读数：1912</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/yue_huang/article/details/72868840" target="_blank" strategy="BlogCommendFromBaidu_1">
				<em>FFmpeg</em> <em>HEVC</em> 多线程<em>解码</em>解析			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/yue_huang/article/details/72868840" target="_blank" >
				5 ff_thread_ini
6 ff_frame_thread_init
avcodec_open2
-ff_thread_init
--ff_slice_thread_init active_t...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/yue_huang" title="yue_huang" target="_blank">
					<img src="https://avatar.csdn.net/5/6/A/3_yue_huang.jpg" alt="yue_huang" class="avatar-pic">
					<span class="name">yue_huang</span>
				</a>
			</p>
			<p>
				<span class="date">2017-06-05 16:58:11</span>
			</p>
			<p>
				<span class="read-num">阅读数：1515</span>
			</p>
		</div>
	</div>
								<div class="recommend-item-box recommend-ad-box" id="ad1"></div>
				<script>
				  var width = $("div.recommend-box").outerWidth() - 48;
					NEWS_FEED({
						w: width,
						h : 90,
						showid : 'GNKXx7',
						placeholderId: "ad1",
						inject : 'define',
						define : {
							imagePosition : 'right',
							imageBorderRadius : 0,
							imageWidth: 120,
							imageHeight: 90,
							imageFill : 'clip',
							displayImage : true,
							displayTitle : true,
							titleFontSize: 20,
							titleFontColor: '#333',
							titleFontFamily : 'Microsoft Yahei',
							titleFontWeight: 'bold',
							titlePaddingTop : 0,
							titlePaddingRight : 0,
							titlePaddingBottom : 10,
							titlePaddingLeft : 0,
							displayDesc : true,
							descFontSize: 14,
							descFontColor: '#6b6b6b',
							descFontFamily : 'Microsoft Yahei',
							paddingTop : 0,
							paddingRight : 0,
							paddingBottom : 0,
							paddingLeft : 0,
							backgroundColor: '#fff',
							hoverColor: '#ca0c16'
						}
					})
				</script>

			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/shaqoneal/article/details/16807881" target="_blank" strategy="BlogCommendFromBaidu_2">
				<em>ffmpeg</em>2.1对<em>HEVC</em>/H.265视频进行<em>解码</em>的例子			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/shaqoneal/article/details/16807881" target="_blank" >
				新版的<em>ffmpeg</em> 2.1已经加入了对最新视频编<em>解码</em>标准H.265/<em>HEVC</em>的支持，因此可以<em>解码</em>该格式的视频了。这对视频产业来说将起到一种巨大的推动作用。本文所示的demo是一个<em>简单</em>的H.265格式视...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/shaqoneal" title="shaqoneal" target="_blank">
					<img src="https://avatar.csdn.net/C/5/8/3_shaqoneal.jpg" alt="shaqoneal" class="avatar-pic">
					<span class="name">shaqoneal</span>
				</a>
			</p>
			<p>
				<span class="date">2013-11-18 17:51:41</span>
			</p>
			<p>
				<span class="read-num">阅读数：5525</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/qq_32430349/article/details/50144125" target="_blank" strategy="BlogCommendFromBaidu_3">
				<em>ffmpeg</em>的<em>HEVC</em><em>解码</em><em>源代码</em><em>分析</em>（一）整体框架			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/qq_32430349/article/details/50144125" target="_blank" >
				通过调试<em>ffmpeg</em>对<em>HEVC</em>码流（格式为es流，就是rawvideo）的<em>解码</em>过程，<em>分析</em><em>ffmpeg</em>的<em>HEVC</em><em>解码</em>过程和实现方法。
首先要说的是调试所用的工程的config为：./configure ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/qq_32430349" title="qq_32430349" target="_blank">
					<img src="https://avatar.csdn.net/C/B/0/3_qq_32430349.jpg" alt="qq_32430349" class="avatar-pic">
					<span class="name">qq_32430349</span>
				</a>
			</p>
			<p>
				<span class="date">2015-12-02 09:53:19</span>
			</p>
			<p>
				<span class="read-num">阅读数：1557</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/46412897" target="_blank" strategy="BlogCommendFromBaidu_4">
				<em>FFmpeg</em>的<em>HEVC</em><em>解码器</em><em>源代码</em><em>简单</em><em>分析</em>：<em>解码器</em>主干<em>部分</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/46412897" target="_blank" >
				本文<em>分析</em><em>FFmpeg</em>的<em>HEVC</em><em>解码器</em>的主干<em>部分</em>。“主干<em>部分</em>”是相对于“<em>CTU</em><em>解码</em>”、 “环路滤波”这些细节<em>部分</em>而言的。它包含了<em>HEVC</em><em>解码器</em>直到hls_<em>decode</em>_entry()前面的函数调用关系（...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-06-10 16:23:08</span>
			</p>
			<p>
				<span class="read-num">阅读数：10684</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/ljh081231/article/details/51774332" target="_blank" strategy="BlogCommendFromBaidu_5">
				<em>ffmpeg</em>支持的硬<em>解码</em>接口			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/ljh081231/article/details/51774332" target="_blank" >
				GPU可以支持视频<em>解码</em>，而且在<em>ffmpeg</em>中也提供了<em>解码</em>的接口，一个是NVIDIA的VDPAU，一个是intel的VAAPI。


1、首先安装最新的Nvidia显卡驱动
安装后一般会在/usr/li...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/ljh081231" title="ljh081231" target="_blank">
					<img src="https://avatar.csdn.net/1/2/F/3_ljh081231.jpg" alt="ljh081231" class="avatar-pic">
					<span class="name">ljh081231</span>
				</a>
			</p>
			<p>
				<span class="date">2016-06-28 11:04:02</span>
			</p>
			<p>
				<span class="read-num">阅读数：16013</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/A813469617/article/details/77187946" target="_blank" strategy="BlogCommendFromBaidu_6">
				<em>HEVC</em>语法元素的编<em>解码</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/A813469617/article/details/77187946" target="_blank" >
				编<em>解码</em>模式的描述符：
比特串：
b(8):任意形式的8比特字节（就是为了说明语法元素是为8个比特，没有语法上的含义）
f(n):n位固定模式比特串（其值固定，如forbidden_zero_bit的值...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/A813469617" title="A813469617" target="_blank">
					<img src="https://avatar.csdn.net/C/7/F/3_a813469617.jpg" alt="A813469617" class="avatar-pic">
					<span class="name">A813469617</span>
				</a>
			</p>
			<p>
				<span class="date">2017-08-15 14:13:25</span>
			</p>
			<p>
				<span class="read-num">阅读数：252</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/luofl1992/article/details/8654317" target="_blank" strategy="BlogCommendFromBaidu_7">
				用MFC构建<em>HEVC</em>码流播放器			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/luofl1992/article/details/8654317" target="_blank" >
				<em>HEVC</em>的测试代码HM中给出了一个<em>解码器</em>示例，但是该<em>解码器</em>只能输出结果到yuv文件，不能跟放电影一样阅览。所以离实际应用总有一定距离，我现在刚开始学习<em>HEVC</em>，也想深入了解<em>HEVC</em>的编<em>解码</em>原理和具体过...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/luofl1992" title="luofl1992" target="_blank">
					<img src="https://avatar.csdn.net/5/1/A/3_luofl1992.jpg" alt="luofl1992" class="avatar-pic">
					<span class="name">luofl1992</span>
				</a>
			</p>
			<p>
				<span class="date">2013-03-09 18:32:33</span>
			</p>
			<p>
				<span class="read-num">阅读数：3805</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/shaqoneal/article/details/16967789" target="_blank" strategy="BlogCommendFromBaidu_8">
				<em>FFMPeg</em>代码<em>分析</em>：avcodec_<em>decode</em>_video2函数			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/shaqoneal/article/details/16967789" target="_blank" >
				该函数的作用是实现压缩视频的<em>解码</em>。在avcodec.h中的声明方式如下：
int avcodec_<em>decode</em>_video2(AVCodecContext *avctx, AVFrame *pict...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/shaqoneal" title="shaqoneal" target="_blank">
					<img src="https://avatar.csdn.net/C/5/8/3_shaqoneal.jpg" alt="shaqoneal" class="avatar-pic">
					<span class="name">shaqoneal</span>
				</a>
			</p>
			<p>
				<span class="date">2013-11-26 18:00:10</span>
			</p>
			<p>
				<span class="read-num">阅读数：4195</span>
			</p>
		</div>
	</div>
						<div class="recommend-item-box recommend-download-box csdn-tracking-statistics clearfix" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
			<div class="content float-left">
				<h4 class="text-truncate">
					<a href="https://download.csdn.net/download/wangad1982/8878247" target="_blank" strategy="BlogCommendFromBaidu_9">
						<em>ffmpeg</em><em>解码</em>播放h265视频码流					</a>
				</h4>
				<p>
					<span class="data">2015年07月07日 </span>
					<span class="size">43.39MB</span>
					<span class="type">下载</span>
				</p>
			</div>
			<div class="img-box float-right">
				<a href="https://download.csdn.net/download/wangad1982/8878247" target="_blank" strategy="BlogCommendFromBaidu_9">
					<img src="http://csdnimg.cn/release/download/old_static/images/minetype/rar.svg" alt="">
				</a>
			</div>
		</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46451119" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421157">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>4</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU";
    var ChannelId = 16;
    var articleId = "46451119";
    var commentscount = 3;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/46451119";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "hevc+ffdshow";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=hevc+ffdshow"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>