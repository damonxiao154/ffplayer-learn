<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/46483721"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文分析FFmpeg的libavcodec中的HEVC解码器的环路滤波（Loop Filter）部分的源代码。FFmpeg的HEVC解码器调用hls_decode_entry()函数完成了Slice解码工作。hls_decode_entry()则调用了ff_hevc_hls_filters()完成了滤波工作。本文记录该函数实现的功能。函数调用关系图FFmpeg HEVC解码器的环路滤波（Loop" />
    <meta name="keywords" content="ffmpeg,libavcodec" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>FFmpeg的HEVC解码器源代码简单分析：环路滤波（Loop Filter） - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46483721"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">FFmpeg的HEVC解码器源代码简单分析：环路滤波（Loop Filter）</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年06月21日 00:07:03</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：8474</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p></p><p>=====================================================</p><p>HEVC源代码分析文章列表：</p><p>【解码 -libavcodec HEVC 解码器】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46412023">FFmpeg的HEVC解码器源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46412607">FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46412897">FFmpeg的HEVC解码器源代码简单分析：解码器主干部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46414483">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-PU</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46451119">FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/46483721">FFmpeg的HEVC解码器源代码简单分析：环路滤波（LoopFilter）</a></p><p>=====================================================</p><br /><p><span style="white-space:pre">	</span>本文分析FFmpeg的libavcodec中的HEVC解码器的环路滤波（Loop Filter）部分的源代码。FFmpeg的HEVC解码器调用hls_decode_entry()函数完成了Slice解码工作。hls_decode_entry()则调用了ff_hevc_hls_filters()完成了滤波工作。本文记录该函数实现的功能。</p><br /><h2>函数调用关系图</h2>FFmpeg HEVC解码器的环路滤波（Loop Filter）部分在整个HEVC解码器中的位置如下图所示。<br /><div style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201506/08/1433745138_2962.png"><img src="http://img.blog.csdn.net/20150613164941410" alt="" />&nbsp;</a></div><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1809621">单击查看更清晰的大图</a></div><div style="text-align: left;"><br /></div>环路滤波（Loop Filter）部分的函数调用关系如下图所示。<br /><div style="text-align: center;">&nbsp;<a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201506/13/1434185437_5338.png"><img src="http://img.blog.csdn.net/20150613164950668" alt="" /></a></div><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1809971">单击查看更清晰的大图</a></div><br />从源代码可以看出，滤波模块对应的函数是ff_hevc_hls_filters()，该函数调用了函数ff_hevc_hls_filter()（注意函数名称少了一个“s”）。ff_hevc_hls_filter()调用了两个函数完成了两种滤波工作：deblocking_filter_CTB()用于完成去块效应滤波，而sao_filter_CTB()用于完成SAO滤波。<br /><br /><h2>hls_decode_entry()</h2>hls_decode_entry()是FFmpeg HEVC解码器中Slice解码的入口函数。该函数的定义如下所示。<br /><pre name="code" class="cpp">/*
 * 解码入口函数
 *
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 */
static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
{
    HEVCContext *s  = avctxt-&gt;priv_data;
    //CTB尺寸
    int ctb_size    = 1 &lt;&lt; s-&gt;sps-&gt;log2_ctb_size;
    int more_data   = 1;
    int x_ctb       = 0;
    int y_ctb       = 0;
    int ctb_addr_ts = s-&gt;pps-&gt;ctb_addr_rs_to_ts[s-&gt;sh.slice_ctb_addr_rs];

    if (!ctb_addr_ts &amp;&amp; s-&gt;sh.dependent_slice_segment_flag) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Impossible initial tile.\n&quot;);
        return AVERROR_INVALIDDATA;
    }

    if (s-&gt;sh.dependent_slice_segment_flag) {
        int prev_rs = s-&gt;pps-&gt;ctb_addr_ts_to_rs[ctb_addr_ts - 1];
        if (s-&gt;tab_slice_address[prev_rs] != s-&gt;sh.slice_addr) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Previous slice segment missing\n&quot;);
            return AVERROR_INVALIDDATA;
        }
    }

    while (more_data &amp;&amp; ctb_addr_ts &lt; s-&gt;sps-&gt;ctb_size) {
        int ctb_addr_rs = s-&gt;pps-&gt;ctb_addr_ts_to_rs[ctb_addr_ts];
        //CTB的位置x和y
        x_ctb = (ctb_addr_rs % ((s-&gt;sps-&gt;width + ctb_size - 1) &gt;&gt; s-&gt;sps-&gt;log2_ctb_size)) &lt;&lt; s-&gt;sps-&gt;log2_ctb_size;
        y_ctb = (ctb_addr_rs / ((s-&gt;sps-&gt;width + ctb_size - 1) &gt;&gt; s-&gt;sps-&gt;log2_ctb_size)) &lt;&lt; s-&gt;sps-&gt;log2_ctb_size;
        //初始化周围的参数
        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);
        //初始化CABAC
        ff_hevc_cabac_init(s, ctb_addr_ts);
        //样点自适应补偿参数
        hls_sao_param(s, x_ctb &gt;&gt; s-&gt;sps-&gt;log2_ctb_size, y_ctb &gt;&gt; s-&gt;sps-&gt;log2_ctb_size);

        s-&gt;deblock[ctb_addr_rs].beta_offset = s-&gt;sh.beta_offset;
        s-&gt;deblock[ctb_addr_rs].tc_offset   = s-&gt;sh.tc_offset;
        s-&gt;filter_slice_edges[ctb_addr_rs]  = s-&gt;sh.slice_loop_filter_across_slices_enabled_flag;
        /*
         * CU示意图
         *
		 * 64x64块
		 *
		 * 深度d=0
		 * split_flag=1时候划分为4个32x32
		 *
		 * +--------+--------+--------+--------+--------+--------+--------+--------+
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * +                                   |                                   +
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * +                                   |                                   +
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * +                                   |                                   +
		 * |                                                                       |
		 * |                                   |                                   |
		 * |                                                                       |
		 * + --  --  --  --  --  --  --  --  --+ --  --  --  --  --  --  --  --  --+
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +                                                                       +
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +                                                                       +
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +                                                                       +
		 * |                                   |                                   |
		 * |                                                                       |
		 * |                                   |                                   |
		 * +--------+--------+--------+--------+--------+--------+--------+--------+
         *
         *
		 * 32x32 块
		 * 深度d=1
		 * split_flag=1时候划分为4个16x16
		 *
		 * +--------+--------+--------+--------+
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * +                 |                 +
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * + --  --  --  --  + --  --  --  --  +
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * +                 |                 +
		 * |                                   |
		 * |                 |                 |
		 * |                                   |
		 * +--------+--------+--------+--------+
         *
         *
		 * 16x16 块
		 * 深度d=2
		 * split_flag=1时候划分为4个8x8
		 *
		 * +--------+--------+
		 * |                 |
		 * |        |        |
		 * |                 |
		 * +  --  --+ --  -- +
		 * |                 |
		 * |        |        |
		 * |                 |
		 * +--------+--------+
         *
         *
         * 8x8块
		 * 深度d=3
		 * split_flag=1时候划分为4个4x4
         *
		 * +----+----+
		 * |    |    |
		 * + -- + -- +
		 * |    |    |
		 * +----+----+
         *
         */
        /*
         * 解析四叉树结构，并且解码
         *
         * hls_coding_quadtree(HEVCContext *s, int x0, int y0, int log2_cb_size, int cb_depth)中：
         * s：HEVCContext上下文结构体
         * x_ctb：CB位置的x坐标
         * y_ctb：CB位置的y坐标
         * log2_cb_size：CB大小取log2之后的值
         * cb_depth：深度
         *
         */
        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s-&gt;sps-&gt;log2_ctb_size, 0);
        if (more_data &lt; 0) {
            s-&gt;tab_slice_address[ctb_addr_rs] = -1;
            return more_data;
        }


        ctb_addr_ts++;
        //保存解码信息以供下次使用
        ff_hevc_save_states(s, ctb_addr_ts);
        //去块效应滤波
        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
    }

    if (x_ctb + ctb_size &gt;= s-&gt;sps-&gt;width &amp;&amp;
        y_ctb + ctb_size &gt;= s-&gt;sps-&gt;height)
        ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size);

    return ctb_addr_ts;
}
</pre><br />从源代码可以看出，hls_decode_entry()主要调用了2个函数进行解码工作：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用hls_coding_quadtree()解码CTU。其中包含了PU和TU的解码。<br />（2）调用ff_hevc_hls_filters()进行滤波。其中包含了去块效应滤波和SAO滤波。</blockquote>本文分析第二步的滤波过程。<br /><br /><h2>ff_hevc_hls_filters()</h2>ff_hevc_hls_filters()用于完成滤波工作。该函数的定义如下所示。<br /><pre name="code" class="cpp">/*
 * 去块效应滤波
 *
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 */
void ff_hevc_hls_filters(HEVCContext *s, int x_ctb, int y_ctb, int ctb_size)
{
	//是否是水平边缘上的CTU
    int x_end = x_ctb &gt;= s-&gt;sps-&gt;width  - ctb_size;
    //是否是垂直边缘上的CTU
    int y_end = y_ctb &gt;= s-&gt;sps-&gt;height - ctb_size;

    /*
     * (x)代表解码序号为x的CTU的滤波的图像块
     *
     *                                      右边界
     *    |        |        |        |        ||
	 * ---+--------+--------+--------+--------++
	 *    |        |        |        |        ||
	 *    |   (a)  |  (b)   |  (c)1  |  (c)2  ||
	 *    |        |        |        |        ||
	 * ---+--------+--------+--------+--------++
	 *    |        |        |        |        ||
	 *    |        |   a    |   b    |   c    ||
	 *    |        |        |        |        ||
	 * ---+--------+--------+--------+--------++
	 *
	 * 。。。。。。
	 * ---+--------+--------+--------+--------++
	 *    |        |        |        |        ||
	 *    |  (d)1  |   (e)1 |   (f)1 |   (f)2 ||
	 *    |        |        |        |        ||
	 * ---+--------+--------+--------+--------++
	 *    |        |        |        |        ||
	 *    |  (d)2  | d (e)2 | e (f)3 |    f   ||
	 *    |        |        |        |        ||
	 * ---+--------+--------+--------+--------++ 下边界
	 * ---+--------+--------+--------+--------++
     */
    //对左上方CTU滤波
    if (y_ctb &amp;&amp; x_ctb)
        ff_hevc_hls_filter(s, x_ctb - ctb_size, y_ctb - ctb_size, ctb_size);
    //如果是右边界上的CTU，再对上方的CTU滤波
    if (y_ctb &amp;&amp; x_end)
        ff_hevc_hls_filter(s, x_ctb, y_ctb - ctb_size, ctb_size);
    //如果是下边界上的CTU，再对左边的CTU滤波
    if (x_ctb &amp;&amp; y_end)
        ff_hevc_hls_filter(s, x_ctb - ctb_size, y_ctb, ctb_size);
}
</pre><br />从源代码可以看出，ff_hevc_hls_filters()调用了ff_hevc_hls_filter()完成了滤波工作。ff_hevc_hls_filters()对于当前需要进行滤波的CTU的位置进行了判断：一般情况下对当前CTU左上方的CTU进行滤波处理；如果当前CTU位于右边边界处，则再对当前CTU上面的CTU进行滤波处理；若果当前CTU位于下边边界处，则再对当前CTU左边的CTU进行滤波处理。<br /><br /><h2>ff_hevc_hls_filter()</h2>ff_hevc_hls_filter()完成了一个CTU的滤波工作。该函数的定义如下所示。<br /><pre name="code" class="cpp">//滤波
void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
{
    int x_end = x &gt;= s-&gt;sps-&gt;width  - ctb_size;
    //去块效应滤波器
    deblocking_filter_CTB(s, x, y);
    if (s-&gt;sps-&gt;sao_enabled) {
    	//SAO（采样自适应偏移）滤波器
        int y_end = y &gt;= s-&gt;sps-&gt;height - ctb_size;
        if (y &amp;&amp; x)
            sao_filter_CTB(s, x - ctb_size, y - ctb_size);
        if (x &amp;&amp; y_end)
            sao_filter_CTB(s, x - ctb_size, y);
        if (y &amp;&amp; x_end) {
            sao_filter_CTB(s, x, y - ctb_size);
            if (s-&gt;threads_type &amp; FF_THREAD_FRAME )
                ff_thread_report_progress(&amp;s-&gt;ref-&gt;tf, y, 0);
        }
        if (x_end &amp;&amp; y_end) {
            sao_filter_CTB(s, x , y);
            if (s-&gt;threads_type &amp; FF_THREAD_FRAME )
                ff_thread_report_progress(&amp;s-&gt;ref-&gt;tf, y + ctb_size, 0);
        }
    } else if (s-&gt;threads_type &amp; FF_THREAD_FRAME &amp;&amp; x_end)
        ff_thread_report_progress(&amp;s-&gt;ref-&gt;tf, y + ctb_size - 4, 0);
}
</pre><br />从源代码可以看出，ff_hevc_hls_filter()调用了两种滤波函数：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用deblocking_filter_CTB()进行去块效应滤波<br />（2）调用sao_filter_CTB()进行SAO（采样自适应偏移）滤波</blockquote><p>下面分别看一下这两个函数。</p><p><br /></p><h2>deblocking_filter_CTB()</h2>deblocking_filter_CTB()完成了去块效应滤波。该函数的定义如下所示。<br /><pre name="code" class="cpp">//去块效应滤波器
static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
{
    uint8_t *src;
    int x, y;
    int chroma, beta;
    int32_t c_tc[2], tc[2];
    uint8_t no_p[2] = { 0 };
    uint8_t no_q[2] = { 0 };

    int log2_ctb_size = s-&gt;sps-&gt;log2_ctb_size;
    int x_end, x_end2, y_end;
    int ctb_size        = 1 &lt;&lt; log2_ctb_size;
    int ctb             = (x0 &gt;&gt; log2_ctb_size) +
                          (y0 &gt;&gt; log2_ctb_size) * s-&gt;sps-&gt;ctb_width;
    int cur_tc_offset   = s-&gt;deblock[ctb].tc_offset;
    int cur_beta_offset = s-&gt;deblock[ctb].beta_offset;
    int left_tc_offset, left_beta_offset;
    int tc_offset, beta_offset;
    int pcmf = (s-&gt;sps-&gt;pcm_enabled_flag &amp;&amp;
                s-&gt;sps-&gt;pcm.loop_filter_disable_flag) ||
               s-&gt;pps-&gt;transquant_bypass_enable_flag;

    if (x0) {
        left_tc_offset   = s-&gt;deblock[ctb - 1].tc_offset;
        left_beta_offset = s-&gt;deblock[ctb - 1].beta_offset;
    } else {
        left_tc_offset   = 0;
        left_beta_offset = 0;
    }

    x_end = x0 + ctb_size;
    if (x_end &gt; s-&gt;sps-&gt;width)
        x_end = s-&gt;sps-&gt;width;
    y_end = y0 + ctb_size;
    if (y_end &gt; s-&gt;sps-&gt;height)
        y_end = s-&gt;sps-&gt;height;

    tc_offset   = cur_tc_offset;
    beta_offset = cur_beta_offset;

    x_end2 = x_end;
    if (x_end2 != s-&gt;sps-&gt;width)
        x_end2 -= 8;
    for (y = y0; y &lt; y_end; y += 8) {
        // vertical filtering luma
    	// 滤波垂直边界的滤波器
    	//
    	//          |
    	// P2 P1 P0 | Q0 Q1 Q2
    	//          |
    	//
        for (x = x0 ? x0 : 8; x &lt; x_end; x += 8) {
        	/*
        	 * 以8x8块为单位
        	 *
        	 * |    |    |    |
        	 * |    |    |    |
        	 * |    |    |    |
        	 * |    |    |    |
        	 * |    |    |    |
        	 *
        	 */
            const int bs0 = s-&gt;vertical_bs[(x +  y      * s-&gt;bs_width) &gt;&gt; 2];
            const int bs1 = s-&gt;vertical_bs[(x + (y + 4) * s-&gt;bs_width) &gt;&gt; 2];
            if (bs0 || bs1) {
                const int qp = (get_qPy(s, x - 1, y)     + get_qPy(s, x, y)     + 1) &gt;&gt; 1;

                beta = betatable[av_clip(qp + beta_offset, 0, MAX_QP)];

                tc[0]   = bs0 ? TC_CALC(qp, bs0) : 0;
                tc[1]   = bs1 ? TC_CALC(qp, bs1) : 0;
                src     = &amp;s-&gt;frame-&gt;data[LUMA][y * s-&gt;frame-&gt;linesize[LUMA] + (x &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
                if (pcmf) {
                    no_p[0] = get_pcm(s, x - 1, y);
                    no_p[1] = get_pcm(s, x - 1, y + 4);
                    no_q[0] = get_pcm(s, x, y);
                    no_q[1] = get_pcm(s, x, y + 4);
                    s-&gt;hevcdsp.hevc_v_loop_filter_luma_c(src,
                                                         s-&gt;frame-&gt;linesize[LUMA],
                                                         beta, tc, no_p, no_q);
                } else
                    s-&gt;hevcdsp.hevc_v_loop_filter_luma(src,
                                                       s-&gt;frame-&gt;linesize[LUMA],
                                                       beta, tc, no_p, no_q);
            }
        }

        if(!y)
             continue;

        // horizontal filtering luma
        // 滤波水平边界的滤波器
        //      P2
        //      P1
        //      P0
        // -----------
        //      Q0
        //      Q1
        //      Q2
        for (x = x0 ? x0 - 8 : 0; x &lt; x_end2; x += 8) {
        	/*
        	 * 以8x8块为单位
        	 *
        	 * ---------------
        	 *
        	 * ---------------
        	 *
        	 * ---------------
        	 *
        	 * ---------------
        	 *
        	 */
            const int bs0 = s-&gt;horizontal_bs[( x      + y * s-&gt;bs_width) &gt;&gt; 2];
            const int bs1 = s-&gt;horizontal_bs[((x + 4) + y * s-&gt;bs_width) &gt;&gt; 2];
            if (bs0 || bs1) {
                const int qp = (get_qPy(s, x, y - 1)     + get_qPy(s, x, y)     + 1) &gt;&gt; 1;

                tc_offset   = x &gt;= x0 ? cur_tc_offset : left_tc_offset;
                beta_offset = x &gt;= x0 ? cur_beta_offset : left_beta_offset;

                beta = betatable[av_clip(qp + beta_offset, 0, MAX_QP)];
                tc[0]   = bs0 ? TC_CALC(qp, bs0) : 0;
                tc[1]   = bs1 ? TC_CALC(qp, bs1) : 0;
                src     = &amp;s-&gt;frame-&gt;data[LUMA][y * s-&gt;frame-&gt;linesize[LUMA] + (x &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
                if (pcmf) {
                    no_p[0] = get_pcm(s, x, y - 1);
                    no_p[1] = get_pcm(s, x + 4, y - 1);
                    no_q[0] = get_pcm(s, x, y);
                    no_q[1] = get_pcm(s, x + 4, y);
                    s-&gt;hevcdsp.hevc_h_loop_filter_luma_c(src,
                                                         s-&gt;frame-&gt;linesize[LUMA],
                                                         beta, tc, no_p, no_q);
                } else
                    s-&gt;hevcdsp.hevc_h_loop_filter_luma(src,
                                                       s-&gt;frame-&gt;linesize[LUMA],
                                                       beta, tc, no_p, no_q);
            }
        }
    }
    //色度滤波
    for (chroma = 1; chroma &lt;= 2; chroma++) {
        int h = 1 &lt;&lt; s-&gt;sps-&gt;hshift[chroma];
        int v = 1 &lt;&lt; s-&gt;sps-&gt;vshift[chroma];

        // vertical filtering chroma
        for (y = y0; y &lt; y_end; y += (8 * v)) {
            for (x = x0 ? x0 : 8 * h; x &lt; x_end; x += (8 * h)) {
                const int bs0 = s-&gt;vertical_bs[(x +  y            * s-&gt;bs_width) &gt;&gt; 2];
                const int bs1 = s-&gt;vertical_bs[(x + (y + (4 * v)) * s-&gt;bs_width) &gt;&gt; 2];

                if ((bs0 == 2) || (bs1 == 2)) {
                    const int qp0 = (get_qPy(s, x - 1, y)           + get_qPy(s, x, y)           + 1) &gt;&gt; 1;
                    const int qp1 = (get_qPy(s, x - 1, y + (4 * v)) + get_qPy(s, x, y + (4 * v)) + 1) &gt;&gt; 1;

                    c_tc[0] = (bs0 == 2) ? chroma_tc(s, qp0, chroma, tc_offset) : 0;
                    c_tc[1] = (bs1 == 2) ? chroma_tc(s, qp1, chroma, tc_offset) : 0;
                    src       = &amp;s-&gt;frame-&gt;data[chroma][(y &gt;&gt; s-&gt;sps-&gt;vshift[chroma]) * s-&gt;frame-&gt;linesize[chroma] + ((x &gt;&gt; s-&gt;sps-&gt;hshift[chroma]) &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
                    if (pcmf) {
                        no_p[0] = get_pcm(s, x - 1, y);
                        no_p[1] = get_pcm(s, x - 1, y + (4 * v));
                        no_q[0] = get_pcm(s, x, y);
                        no_q[1] = get_pcm(s, x, y + (4 * v));
                        s-&gt;hevcdsp.hevc_v_loop_filter_chroma_c(src,
                                                               s-&gt;frame-&gt;linesize[chroma],
                                                               c_tc, no_p, no_q);
                    } else
                        s-&gt;hevcdsp.hevc_v_loop_filter_chroma(src,
                                                             s-&gt;frame-&gt;linesize[chroma],
                                                             c_tc, no_p, no_q);
                }
            }

            if(!y)
                 continue;

            // horizontal filtering chroma
            tc_offset = x0 ? left_tc_offset : cur_tc_offset;
            x_end2 = x_end;
            if (x_end != s-&gt;sps-&gt;width)
                x_end2 = x_end - 8 * h;
            for (x = x0 ? x0 - 8 * h : 0; x &lt; x_end2; x += (8 * h)) {
                const int bs0 = s-&gt;horizontal_bs[( x          + y * s-&gt;bs_width) &gt;&gt; 2];
                const int bs1 = s-&gt;horizontal_bs[((x + 4 * h) + y * s-&gt;bs_width) &gt;&gt; 2];
                if ((bs0 == 2) || (bs1 == 2)) {
                    const int qp0 = bs0 == 2 ? (get_qPy(s, x,           y - 1) + get_qPy(s, x,           y) + 1) &gt;&gt; 1 : 0;
                    const int qp1 = bs1 == 2 ? (get_qPy(s, x + (4 * h), y - 1) + get_qPy(s, x + (4 * h), y) + 1) &gt;&gt; 1 : 0;

                    c_tc[0]   = bs0 == 2 ? chroma_tc(s, qp0, chroma, tc_offset)     : 0;
                    c_tc[1]   = bs1 == 2 ? chroma_tc(s, qp1, chroma, cur_tc_offset) : 0;
                    src       = &amp;s-&gt;frame-&gt;data[chroma][(y &gt;&gt; s-&gt;sps-&gt;vshift[1]) * s-&gt;frame-&gt;linesize[chroma] + ((x &gt;&gt; s-&gt;sps-&gt;hshift[1]) &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
                    if (pcmf) {
                        no_p[0] = get_pcm(s, x,           y - 1);
                        no_p[1] = get_pcm(s, x + (4 * h), y - 1);
                        no_q[0] = get_pcm(s, x,           y);
                        no_q[1] = get_pcm(s, x + (4 * h), y);
                        s-&gt;hevcdsp.hevc_h_loop_filter_chroma_c(src,
                                                               s-&gt;frame-&gt;linesize[chroma],
                                                               c_tc, no_p, no_q);
                    } else
                        s-&gt;hevcdsp.hevc_h_loop_filter_chroma(src,
                                                             s-&gt;frame-&gt;linesize[chroma],
                                                             c_tc, no_p, no_q);
                }
            }
        }
    }
}
</pre><br />从源代码可以看出，deblocking_filter_CTB()是以8x8块为单位进行滤波的。该函数首先调用HEVCDSPContext-&gt;hevc_v_loop_filter_luma()汇编函数对亮度垂直边界进行滤波，然后调用HEVCDSPContext-&gt; hevc_h_loop_filter_luma()汇编函数对亮度水平边界进行滤波，最后还会调用HEVCDSPContext-&gt; hevc_v_loop_filter_chroma ()和HEVCDSPContext-&gt; hevc_h_loop_filter_chroma()对色度垂直边界和水平边界进行滤波。<br /><br /><h2>sao_filter_CTB()</h2>sao_filter_CTB()完成了SAO（采样自适应偏移）滤波。该函数的定义如下所示。<br /><pre name="code" class="cpp">#define CTB(tab, x, y) ((tab)[(y) * s-&gt;sps-&gt;ctb_width + (x)])

//SAO（采样自适应偏移）滤波器
static void sao_filter_CTB(HEVCContext *s, int x, int y)
{
    int c_idx;
    int edges[4];  // 0 left 1 top 2 right 3 bottom
    int x_ctb                = x &gt;&gt; s-&gt;sps-&gt;log2_ctb_size;
    int y_ctb                = y &gt;&gt; s-&gt;sps-&gt;log2_ctb_size;
    int ctb_addr_rs          = y_ctb * s-&gt;sps-&gt;ctb_width + x_ctb;
    int ctb_addr_ts          = s-&gt;pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs];
    SAOParams *sao           = &amp;CTB(s-&gt;sao, x_ctb, y_ctb);
    // flags indicating unfilterable edges
    uint8_t vert_edge[]      = { 0, 0 };
    uint8_t horiz_edge[]     = { 0, 0 };
    uint8_t diag_edge[]      = { 0, 0, 0, 0 };
    uint8_t lfase            = CTB(s-&gt;filter_slice_edges, x_ctb, y_ctb);
    uint8_t no_tile_filter   = s-&gt;pps-&gt;tiles_enabled_flag &amp;&amp;
                               !s-&gt;pps-&gt;loop_filter_across_tiles_enabled_flag;
    uint8_t restore          = no_tile_filter || !lfase;
    uint8_t left_tile_edge   = 0;
    uint8_t right_tile_edge  = 0;
    uint8_t up_tile_edge     = 0;
    uint8_t bottom_tile_edge = 0;

    edges[0]   = x_ctb == 0;
    edges[1]   = y_ctb == 0;
    edges[2]   = x_ctb == s-&gt;sps-&gt;ctb_width  - 1;
    edges[3]   = y_ctb == s-&gt;sps-&gt;ctb_height - 1;
    //位于图像边界处的特殊处理？
    if (restore) {
        if (!edges[0]) {
            left_tile_edge  = no_tile_filter &amp;&amp; s-&gt;pps-&gt;tile_id[ctb_addr_ts] != s-&gt;pps-&gt;tile_id[s-&gt;pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs-1]];
            vert_edge[0]    = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb - 1, y_ctb)) || left_tile_edge;
        }
        if (!edges[2]) {
            right_tile_edge = no_tile_filter &amp;&amp; s-&gt;pps-&gt;tile_id[ctb_addr_ts] != s-&gt;pps-&gt;tile_id[s-&gt;pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs+1]];
            vert_edge[1]    = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb + 1, y_ctb)) || right_tile_edge;
        }
        if (!edges[1]) {
            up_tile_edge     = no_tile_filter &amp;&amp; s-&gt;pps-&gt;tile_id[ctb_addr_ts] != s-&gt;pps-&gt;tile_id[s-&gt;pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs - s-&gt;sps-&gt;ctb_width]];
            horiz_edge[0]    = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb, y_ctb - 1)) || up_tile_edge;
        }
        if (!edges[3]) {
            bottom_tile_edge = no_tile_filter &amp;&amp; s-&gt;pps-&gt;tile_id[ctb_addr_ts] != s-&gt;pps-&gt;tile_id[s-&gt;pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs + s-&gt;sps-&gt;ctb_width]];
            horiz_edge[1]    = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb, y_ctb + 1)) || bottom_tile_edge;
        }
        if (!edges[0] &amp;&amp; !edges[1]) {
            diag_edge[0] = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb - 1, y_ctb - 1)) || left_tile_edge || up_tile_edge;
        }
        if (!edges[1] &amp;&amp; !edges[2]) {
            diag_edge[1] = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb + 1, y_ctb - 1)) || right_tile_edge || up_tile_edge;
        }
        if (!edges[2] &amp;&amp; !edges[3]) {
            diag_edge[2] = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb + 1, y_ctb + 1)) || right_tile_edge || bottom_tile_edge;
        }
        if (!edges[0] &amp;&amp; !edges[3]) {
            diag_edge[3] = (!lfase &amp;&amp; CTB(s-&gt;tab_slice_address, x_ctb, y_ctb) != CTB(s-&gt;tab_slice_address, x_ctb - 1, y_ctb + 1)) || left_tile_edge || bottom_tile_edge;
        }
    }

    for (c_idx = 0; c_idx &lt; 3; c_idx++) {
        int x0       = x &gt;&gt; s-&gt;sps-&gt;hshift[c_idx];
        int y0       = y &gt;&gt; s-&gt;sps-&gt;vshift[c_idx];
        int stride_src = s-&gt;frame-&gt;linesize[c_idx];
        int stride_dst = s-&gt;sao_frame-&gt;linesize[c_idx];
        int ctb_size_h = (1 &lt;&lt; (s-&gt;sps-&gt;log2_ctb_size)) &gt;&gt; s-&gt;sps-&gt;hshift[c_idx];
        int ctb_size_v = (1 &lt;&lt; (s-&gt;sps-&gt;log2_ctb_size)) &gt;&gt; s-&gt;sps-&gt;vshift[c_idx];
        int width    = FFMIN(ctb_size_h, (s-&gt;sps-&gt;width  &gt;&gt; s-&gt;sps-&gt;hshift[c_idx]) - x0);
        int height   = FFMIN(ctb_size_v, (s-&gt;sps-&gt;height &gt;&gt; s-&gt;sps-&gt;vshift[c_idx]) - y0);
        uint8_t *src = &amp;s-&gt;frame-&gt;data[c_idx][y0 * stride_src + (x0 &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
        uint8_t *dst = &amp;s-&gt;sao_frame-&gt;data[c_idx][y0 * stride_dst + (x0 &lt;&lt; s-&gt;sps-&gt;pixel_shift)];
        //SAO滤波类型
        switch (sao-&gt;type_idx[c_idx]) {
        case SAO_BAND:   //边带补偿
            copy_CTB(dst, src, width &lt;&lt; s-&gt;sps-&gt;pixel_shift, height, stride_dst, stride_src);
            s-&gt;hevcdsp.sao_band_filter(src, dst,
                                       stride_src, stride_dst,
                                       sao,
                                       edges, width,
                                       height, c_idx);
            restore_tqb_pixels(s, x, y, width, height, c_idx);
            sao-&gt;type_idx[c_idx] = SAO_APPLIED;
            break;
        case SAO_EDGE:   //边界补偿
        {
            uint8_t left_pixels = !edges[0] &amp;&amp; (CTB(s-&gt;sao, x_ctb-1, y_ctb).type_idx[c_idx] != SAO_APPLIED);
            if (!edges[1]) {
                uint8_t top_left  = !edges[0] &amp;&amp; (CTB(s-&gt;sao, x_ctb-1, y_ctb-1).type_idx[c_idx] != SAO_APPLIED);
                uint8_t top_right = !edges[2] &amp;&amp; (CTB(s-&gt;sao, x_ctb+1, y_ctb-1).type_idx[c_idx] != SAO_APPLIED);
                if (CTB(s-&gt;sao, x_ctb  , y_ctb-1).type_idx[c_idx] == 0)
                    memcpy( dst - stride_dst - (top_left &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                            src - stride_src - (top_left &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                            (top_left + width + top_right) &lt;&lt; s-&gt;sps-&gt;pixel_shift);
                else {
                    if (top_left)
                        memcpy( dst - stride_dst - (1 &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                                src - stride_src - (1 &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                                1 &lt;&lt; s-&gt;sps-&gt;pixel_shift);
                    if(top_right)
                        memcpy( dst - stride_dst + (width &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                                src - stride_src + (width &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                                1 &lt;&lt; s-&gt;sps-&gt;pixel_shift);
                }
            }
            if (!edges[3]) {                                                                // bottom and bottom right
                uint8_t bottom_left = !edges[0] &amp;&amp; (CTB(s-&gt;sao, x_ctb-1, y_ctb+1).type_idx[c_idx] != SAO_APPLIED);
                memcpy( dst + height * stride_dst - (bottom_left &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                        src + height * stride_src - (bottom_left &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                        (width + 1 + bottom_left) &lt;&lt; s-&gt;sps-&gt;pixel_shift);
            }
            copy_CTB(dst - (left_pixels &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                     src - (left_pixels &lt;&lt; s-&gt;sps-&gt;pixel_shift),
                     (width + 1 + left_pixels) &lt;&lt; s-&gt;sps-&gt;pixel_shift, height, stride_dst, stride_src);
            s-&gt;hevcdsp.sao_edge_filter[restore](src, dst,
                                                stride_src, stride_dst,
                                                sao,
                                                edges, width,
                                                height, c_idx,
                                                vert_edge,
                                                horiz_edge,
                                                diag_edge);
            restore_tqb_pixels(s, x, y, width, height, c_idx);
            sao-&gt;type_idx[c_idx] = SAO_APPLIED;
            break;
        }
        }
    }
}
</pre><br />从源代码可以看出，sao_filter_CTB()根据SAO滤波的类型不同作不同的处理：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）滤波类型为边带补偿SAO_BAND的时候，调用HEVCDSPContext-&gt; sao_band_filter()进行滤波。<br />（2）滤波类型为边界补偿SAO_EDGE的时候，调用HEVCDSPContext-&gt; sao_edge_filter()进行滤波。</blockquote><br /><h2>环路滤波知识</h2><p>本章记录HEVC中两种环路滤波技术：DeBlock（去块效应）滤波和SAO（样点自适应补偿）滤波。</p><p><br /></p><h3>DeBlock（去块效应）滤波</h3>去块效应滤波器用于去除视频中的块效应。HEVC的去块效应滤波器和H.264中的去块效应滤波器是类似的。下面四幅图显示了HEVC中去块效应滤波器的效果。左边的两幅图是没有使用去块效应滤波器的解码图像，而右边的两幅图是使用了去块效应滤波器的图像。在HEVC中，去块效应滤波是以8x8的块为单位的，注意在实际处理的时候是将8x8的块边界上的像素分成2个4x4块独立进行处理的。<br /><p style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613165623324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150613165642396?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p><p style="text-align: left;"><br /></p><strong>边界强度Bs判定</strong><br />其中边界强度Bs会影响滤波过程中的阈值。边界强度Bs可以取值为0、1、2，该值越大代表滤波的强度越大。边界强度的判断依据来自于边界两边P和Q两个4x4块的信息。其判定方式如下：<br /><table border="1" cellspacing="0" cellpadding="0" width="500" align="center"> <tbody><tr>  <td valign="top"><p align="center">条件（针对两边的图像块）</p></td>  <td valign="top"><p align="center">Bs</p></td> </tr> <tr>  <td valign="top"><p align="center">P或Q采用帧内预测</p></td>  <td valign="top"><p align="center">2</p></td> </tr> <tr>  <td valign="top"><p align="center">P或Q满足一项条件：有非0变换系数；</p><p align="center">使用不同的参考帧；MV个数不同；MV差值的绝对值大于4。</p></td>  <td valign="top"><p align="center">1</p></td> </tr> <tr>  <td valign="top"><p align="center">其它</p></td>  <td valign="top"><p align="center">0</p></td> </tr></tbody></table><br /><strong>滤波开关决策</strong><br />除了边界强度判断，滤波的过程中还包括了一个滤波开关决策。如果满足开关条件，才进行滤波。滤波开关决策判定的时候只取了P和Q最上面一行和最下面一行像素的值（P3、P2…等以及TP3、TP2…等）而没有使用中间两行像素的值，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613165934113" alt="" /></div>定义了dp0、dq0、dp3、dq3四个值分别代表了P、Q最上面1行和最下面1行像素的值的变化率（即变化的剧烈程度），如下式所示。<br /><div style="text-align: center;"><strong>dp0 = abs(P2 &nbsp;- 2 * P1 &nbsp;+ P0);</strong></div><div style="text-align: center;"><strong>dq0 = abs(Q2 &nbsp;- 2 * Q1 &nbsp;+ Q0);</strong></div><div style="text-align: center;"><strong>dp3 = abs(TP2 - 2 * TP1 + TP0);</strong></div><div style="text-align: center;"><strong>dq3 = abs(TQ2 - 2 * TQ1 + TQ0);</strong></div>边界区域的纹理度Cb定义为dp0、dq0、dp3、dq3四个值的和，如下所示。<br /><div style="text-align: center;"><strong>Cb= dp0+ dq0+ dp3+ dq3</strong></div>纹理度Cb越大代表区域越不平坦，当其值大于一个阈值beta之后，就不需要滤波了。由此可知滤波开关打开的条件如下所示。<br /><div style="text-align: center;"><strong>Cb&lt;beta</strong></div>其中beta的取值和两侧块的QP有关。在求得两侧块的平均QP之后可以通过查表得到，不再详细记录。<br /><br /><strong>滤波强弱的选择</strong><br />“滤波强弱”和“边界强弱”要区分开。“边界强弱”影响滤波公式的阈值，而“滤波强弱”决定了滤波公式。滤波强弱可以分成强滤波和普通滤波两种。强滤波需要满足下面公式，否则就是普通滤波：<br /><div style="text-align: center;"><strong>abs(P3 - P0) + abs(Q3 - Q0) &lt; (beta &gt;&gt; 3) &nbsp; &nbsp; &nbsp; (1)</strong></div><div style="text-align: center;"><strong>abs(TP3 - TP0) + abs(TQ3 - TQ0) &lt; (beta &gt;&gt; 3) &nbsp; &nbsp; &nbsp; &nbsp;(2)</strong></div><div style="text-align: center;"><strong>abs(P0 - Q0) &lt; ((tc*5 + 1) &gt;&gt; 1) &nbsp; &nbsp; &nbsp; &nbsp;(3)</strong></div><div style="text-align: center;"><strong>abs(TP0 - TQ0) &lt; ((tc*5 + 1) &gt;&gt; 1) &nbsp; &nbsp; &nbsp; (4)</strong></div><div style="text-align: center;"><strong>2*(dp0 + dq0) &lt; (beta &gt;&gt; 2) &nbsp; &nbsp; &nbsp; &nbsp;(5)</strong></div><div style="text-align: center;"><strong>2*(dp3 + dq3) &lt; (beta &gt;&gt; 2) &nbsp; &nbsp; &nbsp; &nbsp;(6)</strong></div><p>其中（1）（2）用于判断两边像素值变化率；（3）（4）用于判断两侧像素是否平坦；（5）（6）用于判断边界处像素跨度是否太大。beta的取值在前文已经叙述，tc的取值和beta类似，也是与两侧块的QP有关，可以通过查表得到，不再详细记录。</p><p><strong>[强滤波]</strong></p>强滤波会改变边界两边6个点的值，这些点的计算公式如下所示。<br /><div style="text-align: center;"><strong>p0 = p0 + clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) &gt;&gt; 3) - p0, -tc2, tc2)</strong></div><div style="text-align: center;"><strong>p1 = p1 + clip(((p2 + p1 + p0 + q0 + 2) &gt;&gt; 2) - p1, -tc2, tc2)</strong></div><div style="text-align: center;"><strong>p2 = p2 + clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) &gt;&gt; 3) - p2, -tc2, tc2)</strong></div><div style="text-align: center;"><strong>q0 = q0 + clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) &gt;&gt; 3) - q0, -tc2, tc2)</strong></div><div style="text-align: center;"><strong>q1 = q1 + clip(((p0 + q0 + q1 + q2 + 2) &gt;&gt; 2) - q1, -tc2, tc2)</strong></div><div style="text-align: center;"><strong>q2 = q2 + clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) &gt;&gt; 3) - q2, -tc2, tc2);</strong></div><p><span style="font-family:SimSun;">可以看出P0、Q0的系数为(1,2,2,2,1)&gt;&gt;3；P1、Q1的系数为(1,1,1,1)&gt;&gt;2；P2、Q2的系数为(2,3,1,1,1)&gt;&gt;3。其中tc2=tc*2。</span></p><p><strong>[普通滤波]</strong></p><p>普通滤波会改变边界两边至多4个点的值。再滤波之前首先计算边界处像素的变化程度delta0来确定P0、Q0是否需要滤波：</p><div style="text-align: center;"><strong>delta0 = clip( (9 * (q0 - p0) - 3 * (q1 - p1) + 8) &gt;&gt; 4, -tc, tc)</strong></div>如果delta0满足下式就对P0、Q0进行滤波：<br /><div style="text-align: center;"><strong>delta0&lt;10*tc</strong></div>P0、Q0的计算公式如下所示。<br /><div style="text-align: center;"><strong>p0 = clip (p0 + delta0)</strong></div><div style="text-align: center;"><strong>q0 = clip (q0 - delta0)</strong></div>接着根据边界像素变化率判断P1、Q1是否需要滤波：<br /><div style="text-align: center;"><strong>dp0 + dp3 &lt; ((beta + (beta &gt;&gt; 1)) &gt;&gt; 3)</strong></div><div style="text-align: center;"><strong>dq0 + dq3 &lt; ((beta + (beta &gt;&gt; 1)) &gt;&gt; 3)</strong></div>如果上式成立，就利用下面两个式子计算P1、Q1：<br /><div style="text-align: center;"><strong>p1 =p1 + clip((((p2 + p0 + 1) &gt;&gt; 1) - p1 + delta0) &gt;&gt; 1, -tc_2, tc_2)</strong></div><div style="text-align: center;"><strong>q1 =q1 + clip((((q2 + q0 + 1) &gt;&gt; 1) - q1 - delta0) &gt;&gt; 1, -tc_2, tc_2)</strong></div><br /><h3>SAO（样点自适应补偿）滤波</h3>HEVC中允许使用较大的块进行DCT变换，这一方面能够提供更好的能量集中效果，但是另一方面在量化后却会带来更多的振铃效应。典型的振铃效应如下图所示。SAO（样点自适应补偿）滤波就是为消除这种振铃效应而设计的。它通过对重建图像的分类，对每一类图像像素值加减一个偏移，达到减少失真的目的。在HEVC中包含了两种像素值补偿方法：边界补偿（Edge Offset，EO）以及边带补偿（Band Offset，BO）。在HEVC中SAO是以CTU为基本单位的。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170315076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><strong>边界补偿（EO）</strong><br />边界补偿通过比较和当前像素相邻的2个像素点的值，对像素点进行归类。然后将同类像素补偿同样的值。根据相邻像素的位置不同，边界补偿分成了4种模板：水平方向（EO_0）、垂直方向（EO_1）、135度方向（EO_2）、45度方向（EO_3）。这4种模板相邻像素的位置如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170341662" alt="" /></div>在任意一种模板下，可以根据以下条件将所有像素划分为5类：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）种类1：c&lt;a且c&lt;b<br />（2）种类2：c&lt;a且c==b，或者c==a且c&lt;b<br />（3）种类3：c&gt;a且c==b，或者c==a且c&gt;b<br />（4）种类4：c&gt;a且c&lt;b<br />（5）种类5：其它</blockquote><p>上述五种类型中的前4种的像素取值关系如下图所示。从图中可以看出：种类1的像素值为“凸”型，种类2的像素值为“半凸”型，种类3的像素值为“半凹”型，种类4的像素值为“凹”型。</p><p style="text-align: center;"><img src="http://img.blog.csdn.net/20150613170532639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p>边界补偿的过程中，对于种类1和种类2的补偿值大于等于0，对于种类3和种类4的补偿值小于等于0，对于种类5则不进行补偿。<br />下图显示了解码时候的SAO滤波过程。图中选用了边界补偿（EO）方法的45度方向（EO_3）模板逐个比较每个像素，得到它们的分类，并将不同的分类叠加上不同的值。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170616963" alt="" /></div><br /><strong>边带补偿（BO）</strong><br />边带补偿根据像素值对像素进行归类。它将像素范围等分为32个边带。例如对于8bit图像来说，像素取值0-255，这样每个边带包含8个像素值，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170650317" alt="" /></div>对于每个边带中的像素，使用相同的补偿值。HEVC中规定，CTB只能选择4条连续的边带并对其像素进行补偿。这样在编码的时候只需要传递最小边带号和4个补偿值就可以了。<br /><br /><h3>环路滤波实例</h3><p>本节以一段《Sintel》动画的码流为例，看一下HEVC码流中的环路滤波相关的信息。</p><strong>【去块效应滤波】</strong><br />下图为一个解码后的图像。<br /><div style="text-align: center;"><img src="http://img.blog.csdn.net/20150613170718519" alt="" /></div>图中的网格标记了去块效应滤波的位置。其中红色的边界代表了无需去块效应滤波的边界。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170731817" alt="" /></div>下图选择了一个具体的8x8的CU，看一下其中的具体信息。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170743803" alt="" /></div>下图显示了选择的8x8 CU的具体信息。图中黄色的像素值代表了经过去块效应滤波修正之后的像素值。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170758535" alt="" /></div>下图中灰色方框中的数值是相应位置上没有经过去块效应滤波修正的像素值。可以看出垂直边界最下面位置两边原来的数值是“222”和“220”，而经过去块效应滤波之后，这两个数值变成了“221”和“221”。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170811993" alt="" /></div><br /><strong>【SAO滤波】</strong><br />下图为一个解码后的图像。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613170957427" alt="" /></div>图中记录了每个CTU的SAO滤波相关的参数。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613171009335" alt="" /></div>上图看的不太清晰，去掉图像内容后的信息如下图所示。图中记录了每个CTU使用的边界补偿的模板，以及4类像素的补偿值。在这里需要注意SAO滤波和去块效应滤波的基本单位是不一样的。SAO滤波是以CTU为基本单位的。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613171021200" alt="" /></div>下面选择图像中一个具体的CU，看一下详细的信息。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613171034617" alt="" /></div>CU的像素信息如下所示。该CU采用了水平方向（EO_0）模板，4类像素的补偿值依次为(1,0,-1,-1)。图中黄色的像素值代表了经过SAO补偿之后的像素值。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613171049624" alt="" /></div>下图灰色框中的内容为SAO补偿之前的像素值。可以看出3个像素值的取值依次为“221”、“221”、“220”，这三个值属于“半凸”型的种类（种类3），应该补偿“-1”。对比上图可知补偿后中间像素的值为“220”。<br /><div style="text-align: center;">&nbsp;<img src="http://img.blog.csdn.net/20150613171105446" alt="" /></div><br /><h2>环路滤波相关的汇编函数</h2>环路滤波相关的汇编函数位于HEVCDSPContext中。HEVCDSPContext的初始化函数是ff_hevc_dsp_init()。该函数对HEVCDSPContext结构体中的函数指针进行了赋值。FFmpeg HEVC解码器运行的过程中只要调用HEVCDSPContext的函数指针就可以完成相应的功能。<br /><br /><h3>ff_hevc_dsp_init()</h3>ff_hevc_dsp_init()用于初始化HEVCDSPContext结构体中的汇编函数指针。该函数的定义如下所示。<br /><pre name="code" class="cpp">void ff_hevc_dsp_init(HEVCDSPContext *hevcdsp, int bit_depth)
{
#undef FUNC
#define FUNC(a, depth) a ## _ ## depth

#undef PEL_FUNC
#define PEL_FUNC(dst1, idx1, idx2, a, depth)                                   \
    for(i = 0 ; i &lt; 10 ; i++)                                                  \
{                                                                              \
    hevcdsp-&gt;dst1[i][idx1][idx2] = a ## _ ## depth;                            \
}

#undef EPEL_FUNCS
#define EPEL_FUNCS(depth)                                                     \
    PEL_FUNC(put_hevc_epel, 0, 0, put_hevc_pel_pixels, depth);                \
    PEL_FUNC(put_hevc_epel, 0, 1, put_hevc_epel_h, depth);                    \
    PEL_FUNC(put_hevc_epel, 1, 0, put_hevc_epel_v, depth);                    \
    PEL_FUNC(put_hevc_epel, 1, 1, put_hevc_epel_hv, depth)

#undef EPEL_UNI_FUNCS
#define EPEL_UNI_FUNCS(depth)                                                 \
    PEL_FUNC(put_hevc_epel_uni, 0, 0, put_hevc_pel_uni_pixels, depth);        \
    PEL_FUNC(put_hevc_epel_uni, 0, 1, put_hevc_epel_uni_h, depth);            \
    PEL_FUNC(put_hevc_epel_uni, 1, 0, put_hevc_epel_uni_v, depth);            \
    PEL_FUNC(put_hevc_epel_uni, 1, 1, put_hevc_epel_uni_hv, depth);           \
    PEL_FUNC(put_hevc_epel_uni_w, 0, 0, put_hevc_pel_uni_w_pixels, depth);    \
    PEL_FUNC(put_hevc_epel_uni_w, 0, 1, put_hevc_epel_uni_w_h, depth);        \
    PEL_FUNC(put_hevc_epel_uni_w, 1, 0, put_hevc_epel_uni_w_v, depth);        \
    PEL_FUNC(put_hevc_epel_uni_w, 1, 1, put_hevc_epel_uni_w_hv, depth)

#undef EPEL_BI_FUNCS
#define EPEL_BI_FUNCS(depth)                                                \
    PEL_FUNC(put_hevc_epel_bi, 0, 0, put_hevc_pel_bi_pixels, depth);        \
    PEL_FUNC(put_hevc_epel_bi, 0, 1, put_hevc_epel_bi_h, depth);            \
    PEL_FUNC(put_hevc_epel_bi, 1, 0, put_hevc_epel_bi_v, depth);            \
    PEL_FUNC(put_hevc_epel_bi, 1, 1, put_hevc_epel_bi_hv, depth);           \
    PEL_FUNC(put_hevc_epel_bi_w, 0, 0, put_hevc_pel_bi_w_pixels, depth);    \
    PEL_FUNC(put_hevc_epel_bi_w, 0, 1, put_hevc_epel_bi_w_h, depth);        \
    PEL_FUNC(put_hevc_epel_bi_w, 1, 0, put_hevc_epel_bi_w_v, depth);        \
    PEL_FUNC(put_hevc_epel_bi_w, 1, 1, put_hevc_epel_bi_w_hv, depth)

#undef QPEL_FUNCS
#define QPEL_FUNCS(depth)                                                     \
    PEL_FUNC(put_hevc_qpel, 0, 0, put_hevc_pel_pixels, depth);                \
    PEL_FUNC(put_hevc_qpel, 0, 1, put_hevc_qpel_h, depth);                    \
    PEL_FUNC(put_hevc_qpel, 1, 0, put_hevc_qpel_v, depth);                    \
    PEL_FUNC(put_hevc_qpel, 1, 1, put_hevc_qpel_hv, depth)

#undef QPEL_UNI_FUNCS
#define QPEL_UNI_FUNCS(depth)                                                 \
    PEL_FUNC(put_hevc_qpel_uni, 0, 0, put_hevc_pel_uni_pixels, depth);        \
    PEL_FUNC(put_hevc_qpel_uni, 0, 1, put_hevc_qpel_uni_h, depth);            \
    PEL_FUNC(put_hevc_qpel_uni, 1, 0, put_hevc_qpel_uni_v, depth);            \
    PEL_FUNC(put_hevc_qpel_uni, 1, 1, put_hevc_qpel_uni_hv, depth);           \
    PEL_FUNC(put_hevc_qpel_uni_w, 0, 0, put_hevc_pel_uni_w_pixels, depth);    \
    PEL_FUNC(put_hevc_qpel_uni_w, 0, 1, put_hevc_qpel_uni_w_h, depth);        \
    PEL_FUNC(put_hevc_qpel_uni_w, 1, 0, put_hevc_qpel_uni_w_v, depth);        \
    PEL_FUNC(put_hevc_qpel_uni_w, 1, 1, put_hevc_qpel_uni_w_hv, depth)

#undef QPEL_BI_FUNCS
#define QPEL_BI_FUNCS(depth)                                                  \
    PEL_FUNC(put_hevc_qpel_bi, 0, 0, put_hevc_pel_bi_pixels, depth);          \
    PEL_FUNC(put_hevc_qpel_bi, 0, 1, put_hevc_qpel_bi_h, depth);              \
    PEL_FUNC(put_hevc_qpel_bi, 1, 0, put_hevc_qpel_bi_v, depth);              \
    PEL_FUNC(put_hevc_qpel_bi, 1, 1, put_hevc_qpel_bi_hv, depth);             \
    PEL_FUNC(put_hevc_qpel_bi_w, 0, 0, put_hevc_pel_bi_w_pixels, depth);      \
    PEL_FUNC(put_hevc_qpel_bi_w, 0, 1, put_hevc_qpel_bi_w_h, depth);          \
    PEL_FUNC(put_hevc_qpel_bi_w, 1, 0, put_hevc_qpel_bi_w_v, depth);          \
    PEL_FUNC(put_hevc_qpel_bi_w, 1, 1, put_hevc_qpel_bi_w_hv, depth)

#define HEVC_DSP(depth)                                                     \
    hevcdsp-&gt;put_pcm                = FUNC(put_pcm, depth);                 \
    hevcdsp-&gt;transform_add[0]       = FUNC(transform_add4x4, depth);        \
    hevcdsp-&gt;transform_add[1]       = FUNC(transform_add8x8, depth);        \
    hevcdsp-&gt;transform_add[2]       = FUNC(transform_add16x16, depth);      \
    hevcdsp-&gt;transform_add[3]       = FUNC(transform_add32x32, depth);      \
    hevcdsp-&gt;transform_skip         = FUNC(transform_skip, depth);          \
    hevcdsp-&gt;transform_rdpcm        = FUNC(transform_rdpcm, depth);         \
    hevcdsp-&gt;idct_4x4_luma          = FUNC(transform_4x4_luma, depth);      \
    hevcdsp-&gt;idct[0]                = FUNC(idct_4x4, depth);                \
    hevcdsp-&gt;idct[1]                = FUNC(idct_8x8, depth);                \
    hevcdsp-&gt;idct[2]                = FUNC(idct_16x16, depth);              \
    hevcdsp-&gt;idct[3]                = FUNC(idct_32x32, depth);              \
                                                                            \
    hevcdsp-&gt;idct_dc[0]             = FUNC(idct_4x4_dc, depth);             \
    hevcdsp-&gt;idct_dc[1]             = FUNC(idct_8x8_dc, depth);             \
    hevcdsp-&gt;idct_dc[2]             = FUNC(idct_16x16_dc, depth);           \
    hevcdsp-&gt;idct_dc[3]             = FUNC(idct_32x32_dc, depth);           \
                                                                            \
    hevcdsp-&gt;sao_band_filter    = FUNC(sao_band_filter_0, depth);              \
    hevcdsp-&gt;sao_edge_filter[0] = FUNC(sao_edge_filter_0, depth);              \
    hevcdsp-&gt;sao_edge_filter[1] = FUNC(sao_edge_filter_1, depth);              \
                                                                               \
    QPEL_FUNCS(depth);                                                         \
    QPEL_UNI_FUNCS(depth);                                                     \
    QPEL_BI_FUNCS(depth);                                                      \
    EPEL_FUNCS(depth);                                                         \
    EPEL_UNI_FUNCS(depth);                                                     \
    EPEL_BI_FUNCS(depth);                                                      \
                                                                               \
    hevcdsp-&gt;hevc_h_loop_filter_luma     = FUNC(hevc_h_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_v_loop_filter_luma     = FUNC(hevc_v_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_h_loop_filter_chroma   = FUNC(hevc_h_loop_filter_chroma, depth); \
    hevcdsp-&gt;hevc_v_loop_filter_chroma   = FUNC(hevc_v_loop_filter_chroma, depth); \
    hevcdsp-&gt;hevc_h_loop_filter_luma_c   = FUNC(hevc_h_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_v_loop_filter_luma_c   = FUNC(hevc_v_loop_filter_luma, depth);   \
    hevcdsp-&gt;hevc_h_loop_filter_chroma_c = FUNC(hevc_h_loop_filter_chroma, depth); \
    hevcdsp-&gt;hevc_v_loop_filter_chroma_c = FUNC(hevc_v_loop_filter_chroma, depth)
int i = 0;

    switch (bit_depth) {
    case 9:
        HEVC_DSP(9);
        break;
    case 10:
        HEVC_DSP(10);
        break;
    case 12:
        HEVC_DSP(12);
        break;
    default:
        HEVC_DSP(8);
        break;
    }

    if (ARCH_X86)
        ff_hevc_dsp_init_x86(hevcdsp, bit_depth);
}
</pre><br />从源代码可以看出，ff_hevc_dsp_init()函数中包含一个名为“HEVC_DSP(depth)”的很长的宏定义。该宏定义中包含了C语言版本的各种函数的初始化代码。ff_hevc_dsp_init()会根据系统的颜色位深bit_depth初始化相应的C语言版本的函数。在函数的末尾则包含了汇编函数的初始化函数：如果系统是X86架构的，则会调用ff_hevc_dsp_init_x86()初始化X86平台下经过汇编优化的函数。下面以8bit颜色位深为例，看一下“HEVC_DSP(8)”的展开结果中和环路滤波相关的函数。<br /><pre name="code" class="cpp">hevcdsp-&gt;sao_band_filter    = sao_band_filter_0_8;              
hevcdsp-&gt;sao_edge_filter[0] = sao_edge_filter_0_8;              
hevcdsp-&gt;sao_edge_filter[1] = sao_edge_filter_1_8;              
                                                                               
hevcdsp-&gt;hevc_h_loop_filter_luma     = hevc_h_loop_filter_luma_8;   
hevcdsp-&gt;hevc_v_loop_filter_luma     = hevc_v_loop_filter_luma_8;   
hevcdsp-&gt;hevc_h_loop_filter_chroma   = hevc_h_loop_filter_chroma_8; 
hevcdsp-&gt;hevc_v_loop_filter_chroma   = hevc_v_loop_filter_chroma_8; 
hevcdsp-&gt;hevc_h_loop_filter_luma_c   = hevc_h_loop_filter_luma_8;   
hevcdsp-&gt;hevc_v_loop_filter_luma_c   = hevc_v_loop_filter_luma_8;   
hevcdsp-&gt;hevc_h_loop_filter_chroma_c = hevc_h_loop_filter_chroma_8; 
hevcdsp-&gt;hevc_v_loop_filter_chroma_c = hevc_v_loop_filter_chroma_8</pre>通过上述代码可以总结出下面几个用于环路滤波的函数：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">HEVCDSPContext-&gt;sao_band_filter()：SAO滤波边带补偿函数。C语言版本函数为sao_band_filter_0_8()<br />HEVCDSPContext-&gt;sao_edge_filter[]()：SAO滤波边界补偿函数。C语言版本函数为sao_edge_filter_0_8()等<br />HEVCDSPContext-&gt; hevc_h_loop_filter_luma()：去块效应滤波水平边界亮度处理函数。C语言版本函数为hevc_h_loop_filter_luma_8()<br />HEVCDSPContext-&gt; hevc_v_loop_filter_luma()：去块效应滤波垂直边界亮度处理函数。C语言版本函数为hevc_v_loop_filter_luma_8()<br />HEVCDSPContext-&gt; hevc_h_loop_filter_chroma()：去块效应滤波水平边界色度处理函数。C语言版本函数为hevc_h_loop_filter_chroma_8()<br />HEVCDSPContext-&gt; hevc_v_loop_filter_chroma()：去块效应滤波水平边界色度处理函数。C语言版本函数为hevc_v_loop_filter_chroma_8()</blockquote>下文例举其中的几个函数进行分析。<br /><br /><h3>去块效应滤波器汇编函数</h3><p>下面记录一下C语言版本去块效应滤波器亮度处理函数hevc_v_loop_filter_luma_8()和hevc_h_loop_filter_luma_8()。</p><p><br /></p><h4>hevc_v_loop_filter_luma_8()</h4>hevc_v_loop_filter_luma_8()是处理垂直边界亮度数据的去块效应滤波器。该函数的定义如下所示。<br /><pre name="code" class="cpp">//滤波垂直边界的滤波器
//
//          |
// P2 P1 P0 | Q0 Q1 Q2
//          |
//
static void FUNC(hevc_v_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
                                          int beta, int32_t *tc, uint8_t *no_p,
                                          uint8_t *no_q)
{
	//xstrice=1
	//ystride=stride
    FUNC(hevc_loop_filter_luma)(pix, sizeof(pixel), stride,
                                beta, tc, no_p, no_q);
}
</pre><br />从源代码可以看出，hevc_v_loop_filter_luma_8()调用了另一个函数hevc_loop_filter_luma_8()。需要注意传递给hevc_loop_filter_luma_8()的第2个参数stride取值为1，而第3个参数ystride取值为stride。<br /><br /><h4>hevc_loop_filter_luma_8()</h4>hevc_loop_filter_luma_8()完成了具体的去块效应滤波工作。该函数的定义如下所示。<br /><pre name="code" class="cpp">/*
 * 滤波开关决策点
 *
 *          P(4x4)             Q(4x4)
 *     +----------------++-----------------+
 * (0) | P3  P2  P1  P0 ||  Q0  Q1  Q2  Q3 |
 * (1) |                ||                 |
 * (2) |                ||                 |
 * (3) |TP3 TP2 TP1 TP0 || TQ0 TQ1 TQ2 TQ3 |
 *     +----------------++-----------------+
 *
 */

// line zero
//第0行（边界两边4x4块的第1行）
#define P3 pix[-4 * xstride]
#define P2 pix[-3 * xstride]
#define P1 pix[-2 * xstride]
#define P0 pix[-1 * xstride]
#define Q0 pix[0 * xstride]
#define Q1 pix[1 * xstride]
#define Q2 pix[2 * xstride]
#define Q3 pix[3 * xstride]

// line three. used only for deblocking decision
//第3行（边界两边4x4块的最后1行）
#define TP3 pix[-4 * xstride + 3 * ystride]
#define TP2 pix[-3 * xstride + 3 * ystride]
#define TP1 pix[-2 * xstride + 3 * ystride]
#define TP0 pix[-1 * xstride + 3 * ystride]
#define TQ0 pix[0  * xstride + 3 * ystride]
#define TQ1 pix[1  * xstride + 3 * ystride]
#define TQ2 pix[2  * xstride + 3 * ystride]
#define TQ3 pix[3  * xstride + 3 * ystride]

//环路滤波器-亮度
static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix,
                                        ptrdiff_t _xstride, ptrdiff_t _ystride,
                                        int beta, int *_tc,
                                        uint8_t *_no_p, uint8_t *_no_q)
{
	/*
	 * 去块效应滤波是对8x8的块边界进行处理
	 * 边界强度是通过位于边界两边4x4的块P、Q来判断
	 *
	 * 【水平边界】
	 * ystride=1
	 * +----+----+
	 * |         |
	 * +----+    +
	 * | P  |    |
	 * +----+----+
	 * | Q  |    |
	 * +----+    +
	 * |         |
	 * +----+----+
	 *
	 * 【垂直边界】
	 * xstride=1
	 * +----+----+----+----+
	 * |    | P  | Q  |    |
	 * |    +----+----+    |
	 * |         |         |
	 * +----+----+----+----+
	 *
	 */


    int d, j;
    pixel *pix        = (pixel *)_pix;
    ptrdiff_t xstride = _xstride / sizeof(pixel);
    ptrdiff_t ystride = _ystride / sizeof(pixel);

    beta &lt;&lt;= BIT_DEPTH - 8;

    for (j = 0; j &lt; 2; j++) {
    	//都是用于滤波开关决策
    	//dp0,dq0,dp3,dq3都代表了像素值的变化率
    	//例如dp0=abs((P2-P1)-(P1-P0))=abs(P2  - 2 * P1  + P0)

    	//P块0行变化率
        const int dp0  = abs(P2  - 2 * P1  + P0);
        //Q块0行变化率
        const int dq0  = abs(Q2  - 2 * Q1  + Q0);
        //P块3行变化率
        const int dp3  = abs(TP2 - 2 * TP1 + TP0);
        //Q块3行变化率
        const int dq3  = abs(TQ2 - 2 * TQ1 + TQ0);
        const int d0   = dp0 + dq0;
        const int d3   = dp3 + dq3;
        const int tc   = _tc[j]   &lt;&lt; (BIT_DEPTH - 8);
        const int no_p = _no_p[j];
        const int no_q = _no_q[j];
        //纹理度Cb=d0+d3=dp0+dq0+dp3+dq3
        //Cb代表了区域的平坦程度，当区域很不平坦的时候，就不用滤波了
        if (d0 + d3 &gt;= beta) {
            pix += 4 * ystride;
            continue;
        } else {
            const int beta_3 = beta &gt;&gt; 3;
            const int beta_2 = beta &gt;&gt; 2;
            const int tc25   = ((tc * 5 + 1) &gt;&gt; 1);

            //判断是否满足强滤波条件
            if (abs(P3  -  P0) + abs(Q3  -  Q0) &lt; beta_3 &amp;&amp; abs(P0  -  Q0) &lt; tc25 &amp;&amp;
                abs(TP3 - TP0) + abs(TQ3 - TQ0) &lt; beta_3 &amp;&amp; abs(TP0 - TQ0) &lt; tc25 &amp;&amp;
                                      (d0 &lt;&lt; 1) &lt; beta_2 &amp;&amp;      (d3 &lt;&lt; 1) &lt; beta_2) {
                // strong filtering
            	// 强滤波
            	// 修改边界两边一共6个点的像素-一共涉及到8个点的计算
            	// av_clip() 用于限幅
                const int tc2 = tc &lt;&lt; 1;
                // 循环滤波4个点
                for (d = 0; d &lt; 4; d++) {
                    const int p3 = P3;
                    const int p2 = P2;
                    const int p1 = P1;
                    const int p0 = P0;
                    const int q0 = Q0;
                    const int q1 = Q1;
                    const int q2 = Q2;
                    const int q3 = Q3;
                    //p和q的滤波公式
                    if (!no_p) {
                        P0 = p0 + av_clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) &gt;&gt; 3) - p0, -tc2, tc2);
                        P1 = p1 + av_clip(((p2 + p1 + p0 + q0 + 2) &gt;&gt; 2) - p1, -tc2, tc2);
                        P2 = p2 + av_clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) &gt;&gt; 3) - p2, -tc2, tc2);
                    }
                    if (!no_q) {
                        Q0 = q0 + av_clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) &gt;&gt; 3) - q0, -tc2, tc2);
                        Q1 = q1 + av_clip(((p0 + q0 + q1 + q2 + 2) &gt;&gt; 2) - q1, -tc2, tc2);
                        Q2 = q2 + av_clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) &gt;&gt; 3) - q2, -tc2, tc2);
                    }
                    pix += ystride;
                }
            } else {
            	// normal filtering
            	// 普通滤波
            	// 修改边界两边一共4个点的像素-一共涉及到6个点的计算
                int nd_p = 1;
                int nd_q = 1;
                const int tc_2 = tc &gt;&gt; 1;
                if (dp0 + dp3 &lt; ((beta + (beta &gt;&gt; 1)) &gt;&gt; 3))
                    nd_p = 2;
                if (dq0 + dq3 &lt; ((beta + (beta &gt;&gt; 1)) &gt;&gt; 3))
                    nd_q = 2;

                for (d = 0; d &lt; 4; d++) {
                    const int p2 = P2;
                    const int p1 = P1;
                    const int p0 = P0;
                    const int q0 = Q0;
                    const int q1 = Q1;
                    const int q2 = Q2;
                    int delta0   = (9 * (q0 - p0) - 3 * (q1 - p1) + 8) &gt;&gt; 4;
                    //判断该行像素是否需要修正
                    //delta0较大，说明边界处变化程度较大，则不需要修正
                    if (abs(delta0) &lt; 10 * tc) {
                        delta0 = av_clip(delta0, -tc, tc);
                        //修正P0和Q0
                        if (!no_p)
                            P0 = av_clip_pixel(p0 + delta0);
                        if (!no_q)
                            Q0 = av_clip_pixel(q0 - delta0);
                        //修正P1和Q1
                        if (!no_p &amp;&amp; nd_p &gt; 1) {
                            const int deltap1 = av_clip((((p2 + p0 + 1) &gt;&gt; 1) - p1 + delta0) &gt;&gt; 1, -tc_2, tc_2);
                            P1 = av_clip_pixel(p1 + deltap1);
                        }
                        if (!no_q &amp;&amp; nd_q &gt; 1) {
                            const int deltaq1 = av_clip((((q2 + q0 + 1) &gt;&gt; 1) - q1 - delta0) &gt;&gt; 1, -tc_2, tc_2);
                            Q1 = av_clip_pixel(q1 + deltaq1);
                        }
                    }
                    pix += ystride;
                }
            }
        }
    }
}
</pre><br />从源代码中可以看出，hevc_loop_filter_luma_8()完成了前文记录的去块效应滤波的公式。由于源代码中已经做了比较详细的注释，在这里就不在详细叙述了。<br /><br /><h4>hevc_h_loop_filter_luma_8()</h4>hevc_h_loop_filter_luma_8()是处理水平边界亮度数据的去块效应滤波器。该函数的定义如下所示。<br /><pre name="code" class="cpp">//滤波水平边界的滤波器
//      P2
//      P1
//      P0
// -----------
//      Q0
//      Q1
//      Q2
static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
                                          int beta, int32_t *tc, uint8_t *no_p,
                                          uint8_t *no_q)
{
	//xstrice=stride
	//ystride=1
    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),
                                beta, tc, no_p, no_q);
}
</pre><br />从源代码可以看出，hevc_h_loop_filter_luma_8()和hevc_v_loop_filter_luma_8()的逻辑是类似的，都调用了hevc_loop_filter_luma_8()。唯一的不同在于它传递给hevc_loop_filter_luma_8()的第2个参数stride取值为stride，而第3个参数ystride取值为1。<br /><br /><h3>SAO（采样自适应偏移）滤波器汇编函数</h3>下面记录一下C语言版SAO滤波器边界补偿函数sao_edge_filter_0_8()和边带补偿函数sao_band_filter_0_8()。<br /><br /><h4>sao_edge_filter_0_8()</h4>sao_edge_filter_0_8()用于进行SAO滤波中的边界补偿。该函数的定义如下所示。<br /><pre name="code" class="cpp">//SAO滤波-边界补偿-0
static void FUNC(sao_edge_filter_0)(uint8_t *_dst, uint8_t *_src,
                                    ptrdiff_t stride_dst, ptrdiff_t stride_src, SAOParams *sao,
                                    int *borders, int _width, int _height,
                                    int c_idx, uint8_t *vert_edge,
                                    uint8_t *horiz_edge, uint8_t *diag_edge)
{
    int x, y;
    pixel *dst = (pixel *)_dst;
    pixel *src = (pixel *)_src;
    int16_t *sao_offset_val = sao-&gt;offset_val[c_idx];
    int sao_eo_class    = sao-&gt;eo_class[c_idx];
    int init_x = 0, init_y = 0, width = _width, height = _height;

    stride_dst /= sizeof(pixel);
    stride_src /= sizeof(pixel);

    if (sao_eo_class != SAO_EO_VERT) {
        if (borders[0]) {
            int offset_val = sao_offset_val[0];
            for (y = 0; y &lt; height; y++) {
                dst[y * stride_dst] = av_clip_pixel(src[y * stride_src] + offset_val);
            }
            init_x = 1;
        }
        if (borders[2]) {
            int offset_val = sao_offset_val[0];
            int offset     = width - 1;
            for (x = 0; x &lt; height; x++) {
                dst[x * stride_dst + offset] = av_clip_pixel(src[x * stride_src + offset] + offset_val);
            }
            width--;
        }
    }
    if (sao_eo_class != SAO_EO_HORIZ) {
        if (borders[1]) {
            int offset_val = sao_offset_val[0];
            for (x = init_x; x &lt; width; x++)
                dst[x] = av_clip_pixel(src[x] + offset_val);
            init_y = 1;
        }
        if (borders[3]) {
            int offset_val   = sao_offset_val[0];
            int y_stride_dst = stride_dst * (height - 1);
            int y_stride_src = stride_src * (height - 1);
            for (x = init_x; x &lt; width; x++)
                dst[x + y_stride_dst] = av_clip_pixel(src[x + y_stride_src] + offset_val);
            height--;
        }
    }
    //边界补偿-内部函数
    FUNC(sao_edge_filter)((uint8_t *)dst, (uint8_t *)src, stride_dst, stride_src, sao, width, height, c_idx, init_x, init_y);
}
</pre><br />从源代码可以看出，sao_edge_filter_0_8()调用了另外一个函数sao_edge_filter_8()完成具体的滤波工作。<br /><br /><h4>sao_edge_filter_8()</h4>sao_edge_filter_8()完成了具体的边带补偿工作。该函数的定义如下所示。<br /><pre name="code" class="cpp">#define CMP(a, b) ((a) &gt; (b) ? 1 : ((a) == (b) ? 0 : -1))
//SAO滤波-边界补偿-内部函数
static void FUNC(sao_edge_filter)(uint8_t *_dst, uint8_t *_src,
                                  ptrdiff_t stride_dst, ptrdiff_t stride_src, SAOParams *sao,
                                  int width, int height,
                                  int c_idx, int init_x, int init_y) {

    static const uint8_t edge_idx[] = { 1, 2, 0, 3, 4 };
    //4种边界补偿的方向信息
    static const int8_t pos[4][2][2] = {
        { { -1,  0 }, {  1, 0 } }, // horizontal
        { {  0, -1 }, {  0, 1 } }, // vertical
        { { -1, -1 }, {  1, 1 } }, // 45 degree
        { {  1, -1 }, { -1, 1 } }, // 135 degree
    };
    //存储了补偿的数值
    int16_t *sao_offset_val = sao-&gt;offset_val[c_idx];
    //边界补偿模式，水平EO_0，垂直EO_1，135度EO_2,45度EO_3，
    int sao_eo_class    = sao-&gt;eo_class[c_idx];
    pixel *dst = (pixel *)_dst;
    pixel *src = (pixel *)_src;

    int y_stride_src = init_y * stride_src;
    int y_stride_dst = init_y * stride_dst;
    //取出pos[]数组中的值
    //例如边界补偿为EO_2的时候
    //  pos_0_0=-1
    //  pos_0_1=-1
    //  pos_1_0=1
    //  pos_1_1=1
    //
    int pos_0_0  = pos[sao_eo_class][0][0];
    int pos_0_1  = pos[sao_eo_class][0][1];
    int pos_1_0  = pos[sao_eo_class][1][0];
    int pos_1_1  = pos[sao_eo_class][1][1];
    int x, y;
    //例如边界补偿为EO_2的时候
	//  y_stride_0_1=(init_y - 1) * stride_src
	//  y_stride_1_1=(init_y + 1) * stride_src
	//
    int y_stride_0_1 = (init_y + pos_0_1) * stride_src;
    int y_stride_1_1 = (init_y + pos_1_1) * stride_src;
    //依次处理每个点
    for (y = init_y; y &lt; height; y++) {
        for (x = init_x; x &lt; width; x++) {
        	/*
        	 * EO_2的时候
        	 *
        	 *       1
        	 *     X
        	 *   2
        	 *
        	 *              x         lines
        	 *              |           |
        	 * 1: src[x + pos_0_0 + y_stride_0_1]
        	 * 2: src[x + pos_1_0 + y_stride_1_1]
        	 *
        	 */
        	//CMP(a,b)的结果。若a&gt;b则取1，a==b择取0，a&lt;b择取-1
            int diff0             = CMP(src[x + y_stride_src], src[x + pos_0_0 + y_stride_0_1]);
            int diff1             = CMP(src[x + y_stride_src], src[x + pos_1_0 + y_stride_1_1]);
            //根据取值判断像素类型：(1)&quot;\/&quot;  (2)&quot;\_&quot;或&quot;_/&quot;  (3)&quot;/ˉ&quot;或&quot;ˉ\&quot;  (4)&quot;/\&quot; (5)其它
            int offset_val        = edge_idx[2 + diff0 + diff1];
            //补偿，从sao_offset_val[]中取值
            dst[x + y_stride_dst] = av_clip_pixel(src[x + y_stride_src] + sao_offset_val[offset_val]);
        }
        y_stride_src += stride_src;
        y_stride_dst += stride_dst;
        y_stride_0_1 += stride_src;
        y_stride_1_1 += stride_src;
    }
}
</pre><br />从源代码中可以看出，sao_edge_filter_8()完成了前文记录的SAO滤波中的边带补偿功能。由于源代码中已经做了比较详细的注释，在这里就不在详细叙述了。<br /><br /><h4>sao_band_filter_0_8()</h4>sao_band_filter_0_8()用于进行SAO滤波中的边带补偿。该函数的定义如下所示。<br /><pre name="code" class="cpp">//SAO滤波-边带补偿
static void FUNC(sao_band_filter_0)(uint8_t *_dst, uint8_t *_src,
                                  ptrdiff_t stride_dst, ptrdiff_t stride_src, SAOParams *sao,
                                  int *borders, int width, int height,
                                  int c_idx)
{
    pixel *dst = (pixel *)_dst;
    pixel *src = (pixel *)_src;
    int offset_table[32] = { 0 };
    int k, y, x;
    int shift  = BIT_DEPTH - 5;
    //4条连续边带的补偿值
    int16_t *sao_offset_val = sao-&gt;offset_val[c_idx];
    //需要补偿的边带序号
    int sao_left_class  = sao-&gt;band_position[c_idx];

    stride_dst /= sizeof(pixel);
    stride_src /= sizeof(pixel);
    //offset_table[]存储了32个边带中每个边带需要补偿的值
    //只有4个边带是需要补偿的，其它边带补偿值为0
    for (k = 0; k &lt; 4; k++)
        offset_table[(k + sao_left_class) &amp; 31] = sao_offset_val[k + 1];
    //逐个像素点处理，进行补偿
    for (y = 0; y &lt; height; y++) {
        for (x = 0; x &lt; width; x++)
            dst[x] = av_clip_pixel(src[x] + offset_table[src[x] &gt;&gt; shift]);//根据边带的取值，加上不同的补偿值
        dst += stride_dst;
        src += stride_src;
    }
}
</pre><br />从源代码中可以看出，sao_band_filter_0_8()完成了前文记录的SAO滤波中的边带补偿功能。由于源代码中已经做了比较详细的注释，在这里就不在详细叙述了。<br /><br />至此有关FFmpeg HEVC解码器中的环路滤波部分的源代码就分析完毕了。<br /><br /><p><br /></p><p><br /></p><br /><br /><strong><span style="color:#990000;">雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</span></strong><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/46483721		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=ffmpeg&t=blog" target="_blank">ffmpeg						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=libavcodec&t=blog" target="_blank">libavcodec						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=HEVC&t=blog" target="_blank">HEVC						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=SAO&t=blog" target="_blank">SAO						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=环路滤波&t=blog" target="_blank">环路滤波						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795"  target="_blank">FFMPEG						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">FFmpeg</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46483721#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/49736199" target="_blank" strategy="BlogCommendFromGuangxin_0">
				<em>HEVC</em>算法和体系结构：<em>环路</em><em>滤波</em>技术			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/49736199" target="_blank" >
				<em>环路</em><em>滤波</em>（In-<em>Loop</em> <em>Filter</em>ing）技术


类似于以往的视频编码标准，<em>HEVC</em>仍采用基于块的混合编码框架，一些失真效应仍然存在，如方块效应、振铃效应、颜色偏差以及图像模糊等等。为了解...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/FRD2009041510" title="FRD2009041510" target="_blank">
					<img src="https://avatar.csdn.net/6/9/9/3_frd2009041510.jpg" alt="FRD2009041510" class="avatar-pic">
					<span class="name">FRD2009041510</span>
				</a>
			</p>
			<p>
				<span class="date">2015-11-09 11:33:11</span>
			</p>
			<p>
				<span class="read-num">阅读数：2481</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/fireroll/article/details/77827156" target="_blank" strategy="BlogCommendFromGuangxin_1">
				H.265与H.264的差异详解			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/fireroll/article/details/77827156" target="_blank" >
				目录：
1.编解码框架差异
2.压缩性能比较
3.各模块技术差异汇总
4.块划分结构
5.帧内预测
6.帧间预测
7.去块<em>滤波</em>
8.SAO<em>滤波</em>
9.Tile
10.WPP
11....			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/fireroll" title="fireroll" target="_blank">
					<img src="https://avatar.csdn.net/1/3/0/3_fireroll.jpg" alt="fireroll" class="avatar-pic">
					<span class="name">fireroll</span>
				</a>
			</p>
			<p>
				<span class="date">2017-09-03 22:31:14</span>
			</p>
			<p>
				<span class="read-num">阅读数：3784</span>
			</p>
		</div>
	</div>
								<!-- 第四范式广告开关 -->
<script>window.p4sdk_enable_recommendBox=true</script>
			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/51076471" target="_blank" strategy="BlogCommendFromGuangxin_2">
				x264代码剖析（十八）：核心算法之<em>滤波</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/51076471" target="_blank" >
				x264代码剖析（十八）：核心算法之<em>滤波</em>
 
        H.264/MPEG-4 AVC视频编码标准中，在编<em>解码器</em>反变换量化后，图像会出现方块效应，主要原因是：1）基于块的帧内和帧间预测残差...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/FRD2009041510" title="FRD2009041510" target="_blank">
					<img src="https://avatar.csdn.net/6/9/9/3_frd2009041510.jpg" alt="FRD2009041510" class="avatar-pic">
					<span class="name">FRD2009041510</span>
				</a>
			</p>
			<p>
				<span class="date">2016-04-06 17:05:39</span>
			</p>
			<p>
				<span class="read-num">阅读数：1700</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/NB_vol_1/article/details/53288814" target="_blank" strategy="BlogCommendFromGuangxin_3">
				<em>HEVC</em>/H.265理论知识（7）——<em>环路</em><em>滤波</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/NB_vol_1/article/details/53288814" target="_blank" >
				一、<em>环路</em><em>滤波</em>的目的是为了提高视频质量，降低去方块效应和振铃效应。


二、<em>环路</em><em>滤波</em>可以分成两大步骤：
1、去方块<em>滤波</em>
2、SAO（像素自适应补偿）


三、去方块<em>滤波</em>介绍
1、方块效...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/NB_vol_1" title="NB_vol_1" target="_blank">
					<img src="https://avatar.csdn.net/2/1/9/3_nb_vol_1.jpg" alt="NB_vol_1" class="avatar-pic">
					<span class="name">NB_vol_1</span>
				</a>
			</p>
			<p>
				<span class="date">2016-11-22 17:25:42</span>
			</p>
			<p>
				<span class="read-num">阅读数：2006</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/coloriy/article/details/78039973" target="_blank" strategy="BlogCommendFromGuangxin_4">
				H.264与H.265的主要差异			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/coloriy/article/details/78039973" target="_blank" >
				1.    H.264与H.265的主要差异
H.265仍然采用混合编解码，编解码结构域H.264基本一致，
主要的不同在于：
?  编码块划分结构：采用CU (CodingUnit)、PU(P...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/coloriy" title="coloriy" target="_blank">
					<img src="https://avatar.csdn.net/F/D/9/3_coloriy.jpg" alt="coloriy" class="avatar-pic">
					<span class="name">coloriy</span>
				</a>
			</p>
			<p>
				<span class="date">2017-09-20 13:52:43</span>
			</p>
			<p>
				<span class="read-num">阅读数：393</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/yyhjifeng/article/details/71191950" target="_blank" strategy="BlogCommendFromBaidu_5">
				ijkplayer 解决rtmp 延迟长的问题，达到秒开的结果			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/yyhjifeng/article/details/71191950" target="_blank" >
				ijkplayer 播放rtmp等 实时性要求很高的 流媒体时候，会出现10S左右的延迟，原因是因为加了缓冲区处理，可以把其缓存设置变小，达到实时的效果。如下代码 

IjkVideoView.j...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/yyhjifeng" title="yyhjifeng" target="_blank">
					<img src="https://avatar.csdn.net/8/D/F/3_yyhjifeng.jpg" alt="yyhjifeng" class="avatar-pic">
					<span class="name">yyhjifeng</span>
				</a>
			</p>
			<p>
				<span class="date">2017-05-05 10:38:50</span>
			</p>
			<p>
				<span class="read-num">阅读数：3928</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/kevin_Android_123456/article/details/8238598" target="_blank" strategy="BlogCommendFromBaidu_6">
				VLC命令行参数详解			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/kevin_Android_123456/article/details/8238598" target="_blank" >
				Usage: vlc [options] [stream] ...
You can specify multiple streams on the commandline. They will be...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/kevin_Android_123456" title="kevin_Android_123456" target="_blank">
					<img src="https://avatar.csdn.net/2/6/2/3_kevin_android_123456.jpg" alt="kevin_Android_123456" class="avatar-pic">
					<span class="name">kevin_Android_123456</span>
				</a>
			</p>
			<p>
				<span class="date">2012-11-29 14:00:23</span>
			</p>
			<p>
				<span class="read-num">阅读数：18974</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45224579" target="_blank" strategy="BlogCommendFromBaidu_7">
				<em>FFmpeg</em>的H.264<em>解码器</em><em>源代码</em><em>简单</em><em>分析</em>：<em>环路</em><em>滤波</em>（<em>Loop</em> <em>Filter</em>）部分			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45224579" target="_blank" >
				本文<em>分析</em><em>FFmpeg</em>的H.264<em>解码器</em>的<em>环路</em><em>滤波</em>（<em>Loop</em> <em>Filter</em>）部分。<em>FFmpeg</em>的H.264<em>解码器</em>调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-04-23 18:16:26</span>
			</p>
			<p>
				<span class="read-num">阅读数：10621</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/evsqiezi/article/details/52489670" target="_blank" strategy="BlogCommendFromBaidu_9">
				h264解码之<em>环路</em><em>滤波</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/evsqiezi/article/details/52489670" target="_blank" >
				<em>环路</em><em>滤波</em>（<em>Loop</em> <em>Filter</em>）部分
    <em>FFmpeg</em>的H.264<em>解码器</em>调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及<em>环路</em><em>滤波</em>。

...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/evsqiezi" title="evsqiezi" target="_blank">
					<img src="https://avatar.csdn.net/D/0/5/3_evsqiezi.jpg" alt="evsqiezi" class="avatar-pic">
					<span class="name">evsqiezi</span>
				</a>
			</p>
			<p>
				<span class="date">2016-09-09 18:09:56</span>
			</p>
			<p>
				<span class="read-num">阅读数：1505</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/deyangliu/article/details/38984781" target="_blank" strategy="BlogCommendFromBaidu_10">
				<em>ffmpeg</em> <em>filter</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/deyangliu/article/details/38984781" target="_blank" >
				<em>滤波</em>：去除不想要的干扰，噪声，颜色。

后处理去方块效应
problem of block artifacts
 smooth slowing-changing regiongs --&gt;
 ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/deyangliu" title="deyangliu" target="_blank">
					<img src="https://avatar.csdn.net/E/3/0/3_deyangliu.jpg" alt="deyangliu" class="avatar-pic">
					<span class="name">deyangliu</span>
				</a>
			</p>
			<p>
				<span class="date">2014-09-01 20:25:32</span>
			</p>
			<p>
				<span class="read-num">阅读数：2476</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/46483721" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421156">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>3</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "FFmpeg的HEVC解码器源代码简单分析：环路滤波（Loop Filter）";
    var ChannelId = 16;
    var articleId = "46483721";
    var commentscount = 6;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/46483721";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "skip_loop_filter";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"FFmpeg的HEVC解码器源代码简单分析：环路滤波（Loop Filter）");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=skip_loop_filter"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>