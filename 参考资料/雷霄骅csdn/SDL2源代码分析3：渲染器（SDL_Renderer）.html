<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/40723085"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="上一篇文章分析了SDL中创建窗口的函数SDL_CreateWindow()。这篇文章继续分析SDL的源代码。本文分析SDL的渲染器（SDL_Renderer）。" />
    <meta name="keywords" content="SDL,OpenGL" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>SDL2源代码分析3：渲染器（SDL_Renderer） - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/40723085"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">SDL2源代码分析3：渲染器（SDL_Renderer）</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2014年11月04日 00:24:32</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：18983</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p></p><p>=====================================================<br /></p><p>SDL源代码分析系列文章列表：</p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40680907">SDL2源代码分析1：初始化（SDL_Init()）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40701203">SDL2源代码分析2：窗口（SDL_Window）</a><br /></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40723085">SDL2源代码分析3：渲染器（SDL_Renderer）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40743061">SDL2源代码分析4：纹理（SDL_Texture）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40876089">SDL2源代码分析5：更新纹理（SDL_UpdateTexture()）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40895593">SDL2源代码分析6：复制到渲染器（SDL_RenderCopy()）</a></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/40895797">SDL2源代码分析7：显示（SDL_RenderPresent()）</a><br /></p><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/41207787">SDL2源代码分析8：视频显示总结</a><br /></p><p>=====================================================</p><br /><p>上一篇文章分析了SDL中创建窗口的函数SDL_CreateWindow()。这篇文章继续分析SDL的源代码。本文分析SDL的渲染器（SDL_Renderer）。</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20141103004453630" alt="" /><br /></p><br /><p>SDL播放视频的代码流程如下所示。</p><strong>初始化: </strong><br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">SDL_Init(): 初始化SDL。 <br />SDL_CreateWindow(): 创建窗口（Window）。 <br />SDL_CreateRenderer(): 基于窗口创建渲染器（Render）。 <br />SDL_CreateTexture(): 创建纹理（Texture）。 </blockquote><strong>循环渲染数据: </strong><br /><blockquote style="margin:0 0 0 40px;border:none;padding:0px;">SDL_UpdateTexture(): 设置纹理的数据。 <br />SDL_RenderCopy(): 纹理复制给渲染器。 <p>SDL_RenderPresent(): 显示。</p></blockquote><p>上篇文章分析了该流程中的第2个函数SDL_CreateWindow()。本文继续分析该流程中的第3个函数SDL_CreateRenderer()。</p><h2>SDL_Renderer</h2><p>SDL_Renderer结构体定义了一个SDL2中的渲染器。如果直接使用SDL2编译好的SDK的话，是看不到它的内部结构的。有关它的定义在头文件中只有一行代码，如下所示。</p><pre class="cpp">/**
 *  \brief A structure representing rendering state
 */
struct SDL_Renderer;
typedef struct SDL_Renderer SDL_Renderer;</pre><br /><p>在源代码工程中可以看到SDL_Renderer的定义，位于render\SDL_sysrender.h文件中。它的定义如下。</p><p></p><pre class="cpp">/* Define the SDL renderer structure */
struct SDL_Renderer
{
    const void *magic;


    void (*WindowEvent) (SDL_Renderer * renderer, const SDL_WindowEvent *event);
    int (*GetOutputSize) (SDL_Renderer * renderer, int *w, int *h);
    int (*CreateTexture) (SDL_Renderer * renderer, SDL_Texture * texture);
    int (*SetTextureColorMod) (SDL_Renderer * renderer,
                               SDL_Texture * texture);
    int (*SetTextureAlphaMod) (SDL_Renderer * renderer,
                               SDL_Texture * texture);
    int (*SetTextureBlendMode) (SDL_Renderer * renderer,
                                SDL_Texture * texture);
    int (*UpdateTexture) (SDL_Renderer * renderer, SDL_Texture * texture,
                          const SDL_Rect * rect, const void *pixels,
                          int pitch);
    int (*UpdateTextureYUV) (SDL_Renderer * renderer, SDL_Texture * texture,
                            const SDL_Rect * rect,
                            const Uint8 *Yplane, int Ypitch,
                            const Uint8 *Uplane, int Upitch,
                            const Uint8 *Vplane, int Vpitch);
    int (*LockTexture) (SDL_Renderer * renderer, SDL_Texture * texture,
                        const SDL_Rect * rect, void **pixels, int *pitch);
    void (*UnlockTexture) (SDL_Renderer * renderer, SDL_Texture * texture);
    int (*SetRenderTarget) (SDL_Renderer * renderer, SDL_Texture * texture);
    int (*UpdateViewport) (SDL_Renderer * renderer);
    int (*UpdateClipRect) (SDL_Renderer * renderer);
    int (*RenderClear) (SDL_Renderer * renderer);
    int (*RenderDrawPoints) (SDL_Renderer * renderer, const SDL_FPoint * points,
                             int count);
    int (*RenderDrawLines) (SDL_Renderer * renderer, const SDL_FPoint * points,
                            int count);
    int (*RenderFillRects) (SDL_Renderer * renderer, const SDL_FRect * rects,
                            int count);
    int (*RenderCopy) (SDL_Renderer * renderer, SDL_Texture * texture,
                       const SDL_Rect * srcrect, const SDL_FRect * dstrect);
    int (*RenderCopyEx) (SDL_Renderer * renderer, SDL_Texture * texture,
                       const SDL_Rect * srcquad, const SDL_FRect * dstrect,
                       const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip);
    int (*RenderReadPixels) (SDL_Renderer * renderer, const SDL_Rect * rect,
                             Uint32 format, void * pixels, int pitch);
    void (*RenderPresent) (SDL_Renderer * renderer);
    void (*DestroyTexture) (SDL_Renderer * renderer, SDL_Texture * texture);


    void (*DestroyRenderer) (SDL_Renderer * renderer);


    int (*GL_BindTexture) (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh);
    int (*GL_UnbindTexture) (SDL_Renderer * renderer, SDL_Texture *texture);


    /* The current renderer info */
    SDL_RendererInfo info;


    /* The window associated with the renderer */
    SDL_Window *window;
    SDL_bool hidden;


    /* The logical resolution for rendering */
    int logical_w;
    int logical_h;
    int logical_w_backup;
    int logical_h_backup;


    /* The drawable area within the window */
    SDL_Rect viewport;
    SDL_Rect viewport_backup;


    /* The clip rectangle within the window */
    SDL_Rect clip_rect;
    SDL_Rect clip_rect_backup;


    /* The render output coordinate scale */
    SDL_FPoint scale;
    SDL_FPoint scale_backup;


    /* The list of textures */
    SDL_Texture *textures;
    SDL_Texture *target;


    Uint8 r, g, b, a;                   /**&lt; Color for drawing operations values */
    SDL_BlendMode blendMode;            /**&lt; The drawing blend mode */


    void *driverdata;
};</pre><br /><p></p><p>通过代码可以看出其中包含了一个“渲染器”应该包含的各种属性。这个结构体中的各个变量还没有深入研究，暂不详细分析。下面来看看如何创建这个SDL_Renderer。</p><br /><h2>SDL_CreateRenderer()</h2><p><strong>函数简介</strong></p>SDL中使用SDL_CreateRenderer()基于窗口创建渲染器。SDL_CreateRenderer()原型如下。<br /><pre class="cpp">SDL_Renderer * SDLCALL SDL_CreateRenderer(SDL_Window * window,
                                               int index, Uint32 flags);</pre><br /><p>参数含义如下。</p><p>window<span style="white-space:pre;">	</span>： 渲染的目标窗口。</p><p>index<span style="white-space:pre;">	</span>：打算初始化的渲染设备的索引。设置“-1”则初始化默认的渲染设备。</p><p>flags<span style="white-space:pre;">	</span>：支持以下值（位于SDL_RendererFlags定义中）</p>    SDL_RENDERER_SOFTWARE ：使用软件渲染<br /><p>    SDL_RENDERER_ACCELERATED ：使用硬件加速</p>    SDL_RENDERER_PRESENTVSYNC：和显示器的刷新率同步<br /><p>    SDL_RENDERER_TARGETTEXTURE ：不太懂</p><p>返回创建完成的渲染器的ID。如果创建失败则返回NULL。</p><p></p><p><strong><br /></strong></p><p><strong>函数调用关系图</strong></p><p>SDL_CreateRenderer()关键函数的调用关系可以用下图表示。</p><div style="text-align:center;"><a href="http://my.csdn.net/leixiaohua1020/album/detail/1793385"><img src="https://img-blog.csdn.net/20141104002137906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></a><br /></div><p>上述图片不太清晰，相册里面上传了一份原始的大图片：</p><p><a href="http://my.csdn.net/leixiaohua1020/album/detail/1793385">http://my.csdn.net/leixiaohua1020/album/detail/1793385</a><br /></p>打开上述相册里面的图片，右键选择“另存为”即可保存原始图片。<br /><p><br /></p><p><strong>源码分析</strong></p><p>SDL_CreateRenderer()的源代码位于render\SDL_render.c中，如下所示。</p><pre class="cpp">SDL_Renderer * SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)
{
#if !SDL_RENDER_DISABLED
    SDL_Renderer *renderer = NULL;
    int n = SDL_GetNumRenderDrivers();
    const char *hint;


    if (!window) {
        SDL_SetError("Invalid window");
        return NULL;
    }


    if (SDL_GetRenderer(window)) {
        SDL_SetError("Renderer already associated with window");
        return NULL;
    }


    hint = SDL_GetHint(SDL_HINT_RENDER_VSYNC);
    if (hint) {
        if (*hint == '0') {
            flags &amp;= ~SDL_RENDERER_PRESENTVSYNC;
        } else {
            flags |= SDL_RENDERER_PRESENTVSYNC;
        }
    }


    if (index &lt; 0) {
        hint = SDL_GetHint(SDL_HINT_RENDER_DRIVER);
        if (hint) {
            for (index = 0; index &lt; n; ++index) {
                const SDL_RenderDriver *driver = render_drivers[index];


                if (SDL_strcasecmp(hint, driver-&gt;info.name) == 0) {
                    /* Create a new renderer instance */
                    renderer = driver-&gt;CreateRenderer(window, flags);
                    break;
                }
            }
        }


        if (!renderer) {
            for (index = 0; index &lt; n; ++index) {
                const SDL_RenderDriver *driver = render_drivers[index];


                if ((driver-&gt;info.flags &amp; flags) == flags) {
                    /* Create a new renderer instance */
                    renderer = driver-&gt;CreateRenderer(window, flags);
                    if (renderer) {
                        /* Yay, we got one! */
                        break;
                    }
                }
            }
        }
        if (index == n) {
            SDL_SetError("Couldn't find matching render driver");
            return NULL;
        }
    } else {
        if (index &gt;= SDL_GetNumRenderDrivers()) {
            SDL_SetError("index must be -1 or in the range of 0 - %d",
                         SDL_GetNumRenderDrivers() - 1);
            return NULL;
        }
        /* Create a new renderer instance */
        renderer = render_drivers[index]-&gt;CreateRenderer(window, flags);
    }


    if (renderer) {
        renderer-&gt;magic = &amp;renderer_magic;
        renderer-&gt;window = window;
        renderer-&gt;scale.x = 1.0f;
        renderer-&gt;scale.y = 1.0f;


        if (SDL_GetWindowFlags(window) &amp; (SDL_WINDOW_HIDDEN|SDL_WINDOW_MINIMIZED)) {
            renderer-&gt;hidden = SDL_TRUE;
        } else {
            renderer-&gt;hidden = SDL_FALSE;
        }


        SDL_SetWindowData(window, SDL_WINDOWRENDERDATA, renderer);


        SDL_RenderSetViewport(renderer, NULL);


        SDL_AddEventWatch(SDL_RendererEventWatch, renderer);


        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER,
                    "Created renderer: %s", renderer-&gt;info.name);
    }
    return renderer;
#else
    SDL_SetError("SDL not built with rendering support");
    return NULL;
#endif
}</pre><br />SDL_CreateRenderer()中最重要的一个函数就是它调用了SDL_RenderDriver的CreateRenderer()方法。通过该方法可以创建一个渲染器。围绕着这个方法，包含了一些初始化工作以及一些收尾工作。下面针对这个最核心的函数进行分析。<br />我们首先来看一下SDL_RenderDriver这个结构体。从字面的意思可以看出它代表了“渲染器的驱动程序”。这个结构体的定义如下。<br /><pre class="cpp">/* Define the SDL render driver structure */
struct SDL_RenderDriver
{
    SDL_Renderer *(*CreateRenderer) (SDL_Window * window, Uint32 flags);


    /* Info about the renderer capabilities */
    SDL_RendererInfo info;
};</pre><br />从代码中可以看出，这个结构体的成员比较简单，包含了一个函数指针CreateRenderer()和一个存储信息的SDL_RendererInfo类型的结构体info。CreateRenderer()是用于创建渲染器的函数，而SDL_RendererInfo则包含了该结构体的一些信息，可以看一下SDL_RendererInfo的定义。<br /><pre class="cpp">/**
 *  \brief Information on the capabilities of a render driver or context.
 */
typedef struct SDL_RendererInfo
{
    const char *name;           /**&lt; The name of the renderer */
    Uint32 flags;               /**&lt; Supported ::SDL_RendererFlags */
    Uint32 num_texture_formats; /**&lt; The number of available texture formats */
    Uint32 texture_formats[16]; /**&lt; The available texture formats */
    int max_texture_width;      /**&lt; The maximimum texture width */
    int max_texture_height;     /**&lt; The maximimum texture height */
} SDL_RendererInfo;</pre><br />在SDL中有一个全局的SDL_RenderDriver类型的静态数组render_drivers，其中存储了SDL支持的所有渲染器。该数组定义如下。<br /><pre class="cpp">static const SDL_RenderDriver *render_drivers[] = {
#if SDL_VIDEO_RENDER_D3D
    &amp;D3D_RenderDriver,
#endif
#if SDL_VIDEO_RENDER_D3D11
    &amp;D3D11_RenderDriver,
#endif
#if SDL_VIDEO_RENDER_OGL
    &amp;GL_RenderDriver,
#endif
#if SDL_VIDEO_RENDER_OGL_ES2
    &amp;GLES2_RenderDriver,
#endif
#if SDL_VIDEO_RENDER_OGL_ES
    &amp;GLES_RenderDriver,
#endif
#if SDL_VIDEO_RENDER_DIRECTFB
    &amp;DirectFB_RenderDriver,
#endif
#if SDL_VIDEO_RENDER_PSP
    &amp;PSP_RenderDriver,
#endif
    &amp;SW_RenderDriver
};</pre><br />从render_drivers数组的定义可以看出，其中包含了Direct3D，OpenGL，OpenGL ES等各种渲染器的驱动程序。我们可以选择几个看一下。<br />例如Direct3D的渲染器驱动程序D3D_RenderDriver的定义如下（位于render\direct3d\SDL_render_d3d.c）。<br /><pre class="cpp">SDL_RenderDriver D3D_RenderDriver = {
    D3D_CreateRenderer,
    {
     "direct3d",
     (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE),
     1,
     {SDL_PIXELFORMAT_ARGB8888},
     0,
     0}
};</pre><br />可以看出创建Direct3D渲染器的函数是D3D_CreateRenderer()。<br /><br />OpenGL的渲染器驱动程序GL_RenderDriver的定义如下（位于render\opengl\SDL_render_gl.c）。<br /><pre class="cpp">SDL_RenderDriver GL_RenderDriver = {
    GL_CreateRenderer,
    {
     "opengl",
     (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE),
     1,
     {SDL_PIXELFORMAT_ARGB8888},
     0,
     0}
};</pre><br />可以看出创建OpenGL渲染器的函数是GL_CreateRenderer()。<br /><br /><br />软件渲染器驱动程序SW_RenderDriver的定义如下（位于render\software\SDL_render_sw.c）。<br /><pre class="cpp">SDL_RenderDriver SW_RenderDriver = {
    SW_CreateRenderer,
    {
     "software",
     SDL_RENDERER_SOFTWARE | SDL_RENDERER_TARGETTEXTURE,
     8,
     {
      SDL_PIXELFORMAT_RGB555,
      SDL_PIXELFORMAT_RGB565,
      SDL_PIXELFORMAT_RGB888,
      SDL_PIXELFORMAT_BGR888,
      SDL_PIXELFORMAT_ARGB8888,
      SDL_PIXELFORMAT_RGBA8888,
      SDL_PIXELFORMAT_ABGR8888,
      SDL_PIXELFORMAT_BGRA8888
     },
     0,
     0}
};</pre><br />可以看出创建软件渲染器的函数是SW_CreateRenderer ()。<br /><br /><br />有关SDL_RenderDriver这个结构体就不再多说了。下面分别看一下Direct3D，OpenGL，Software这三种最常见的渲染器的创建方法。<br /><h3>1.<span style="white-space:pre;">	</span>Direct3D</h3><p>Direct3D 的渲染器在创建函数是D3D_CreateRenderer()。该函数位于render\direct3d\SDL_render_d3d.c文件中。首先看一下它的代码。</p><p></p><pre class="cpp">SDL_Renderer * D3D_CreateRenderer(SDL_Window * window, Uint32 flags)
{
    SDL_Renderer *renderer;
    D3D_RenderData *data;
    SDL_SysWMinfo windowinfo;
    HRESULT result;
    const char *hint;
    D3DPRESENT_PARAMETERS pparams;
    IDirect3DSwapChain9 *chain;
    D3DCAPS9 caps;
    DWORD device_flags;
    Uint32 window_flags;
    int w, h;
    SDL_DisplayMode fullscreen_mode;
    int displayIndex;


    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
    if (!renderer) {
        SDL_OutOfMemory();
        return NULL;
    }


    data = (D3D_RenderData *) SDL_calloc(1, sizeof(*data));
    if (!data) {
        SDL_free(renderer);
        SDL_OutOfMemory();
        return NULL;
    }


    if (!D3D_LoadDLL(&amp;data-&gt;d3dDLL, &amp;data-&gt;d3d)) {
        SDL_free(renderer);
        SDL_free(data);
        SDL_SetError("Unable to create Direct3D interface");
        return NULL;
    }


    renderer-&gt;WindowEvent = D3D_WindowEvent;
    renderer-&gt;CreateTexture = D3D_CreateTexture;
    renderer-&gt;UpdateTexture = D3D_UpdateTexture;
    renderer-&gt;UpdateTextureYUV = D3D_UpdateTextureYUV;
    renderer-&gt;LockTexture = D3D_LockTexture;
    renderer-&gt;UnlockTexture = D3D_UnlockTexture;
    renderer-&gt;SetRenderTarget = D3D_SetRenderTarget;
    renderer-&gt;UpdateViewport = D3D_UpdateViewport;
    renderer-&gt;UpdateClipRect = D3D_UpdateClipRect;
    renderer-&gt;RenderClear = D3D_RenderClear;
    renderer-&gt;RenderDrawPoints = D3D_RenderDrawPoints;
    renderer-&gt;RenderDrawLines = D3D_RenderDrawLines;
    renderer-&gt;RenderFillRects = D3D_RenderFillRects;
    renderer-&gt;RenderCopy = D3D_RenderCopy;
    renderer-&gt;RenderCopyEx = D3D_RenderCopyEx;
    renderer-&gt;RenderReadPixels = D3D_RenderReadPixels;
    renderer-&gt;RenderPresent = D3D_RenderPresent;
    renderer-&gt;DestroyTexture = D3D_DestroyTexture;
    renderer-&gt;DestroyRenderer = D3D_DestroyRenderer;
    renderer-&gt;info = D3D_RenderDriver.info;
    renderer-&gt;info.flags = (SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);
    renderer-&gt;driverdata = data;


    SDL_VERSION(&amp;windowinfo.version);
    SDL_GetWindowWMInfo(window, &amp;windowinfo);


    window_flags = SDL_GetWindowFlags(window);
    SDL_GetWindowSize(window, &amp;w, &amp;h);
    SDL_GetWindowDisplayMode(window, &amp;fullscreen_mode);


    SDL_zero(pparams);
    pparams.hDeviceWindow = windowinfo.info.win.window;
    pparams.BackBufferWidth = w;
    pparams.BackBufferHeight = h;
    if (window_flags &amp; SDL_WINDOW_FULLSCREEN) {
        pparams.BackBufferFormat =
            PixelFormatToD3DFMT(fullscreen_mode.format);
    } else {
        pparams.BackBufferFormat = D3DFMT_UNKNOWN;
    }
    pparams.BackBufferCount = 1;
    pparams.SwapEffect = D3DSWAPEFFECT_DISCARD;


    if (window_flags &amp; SDL_WINDOW_FULLSCREEN) {
        if ((window_flags &amp; SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP)  {
            pparams.Windowed = TRUE;
            pparams.FullScreen_RefreshRateInHz = 0;
        } else {
            pparams.Windowed = FALSE;
            pparams.FullScreen_RefreshRateInHz = fullscreen_mode.refresh_rate;
        }
    } else {
        pparams.Windowed = TRUE;
        pparams.FullScreen_RefreshRateInHz = 0;
    }
    if (flags &amp; SDL_RENDERER_PRESENTVSYNC) {
        pparams.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    } else {
        pparams.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    }


    /* Get the adapter for the display that the window is on */
    displayIndex = SDL_GetWindowDisplayIndex(window);
    data-&gt;adapter = SDL_Direct3D9GetAdapterIndex(displayIndex);


    IDirect3D9_GetDeviceCaps(data-&gt;d3d, data-&gt;adapter, D3DDEVTYPE_HAL, &amp;caps);


    device_flags = D3DCREATE_FPU_PRESERVE;
    if (caps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT) {
        device_flags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
    } else {
        device_flags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;
    }


    hint = SDL_GetHint(SDL_HINT_RENDER_DIRECT3D_THREADSAFE);
    if (hint &amp;&amp; SDL_atoi(hint)) {
        device_flags |= D3DCREATE_MULTITHREADED;
    }


    result = IDirect3D9_CreateDevice(data-&gt;d3d, data-&gt;adapter,
                                     D3DDEVTYPE_HAL,
                                     pparams.hDeviceWindow,
                                     device_flags,
                                     &amp;pparams, &amp;data-&gt;device);
    if (FAILED(result)) {
        D3D_DestroyRenderer(renderer);
        D3D_SetError("CreateDevice()", result);
        return NULL;
    }


    /* Get presentation parameters to fill info */
    result = IDirect3DDevice9_GetSwapChain(data-&gt;device, 0, &amp;chain);
    if (FAILED(result)) {
        D3D_DestroyRenderer(renderer);
        D3D_SetError("GetSwapChain()", result);
        return NULL;
    }
    result = IDirect3DSwapChain9_GetPresentParameters(chain, &amp;pparams);
    if (FAILED(result)) {
        IDirect3DSwapChain9_Release(chain);
        D3D_DestroyRenderer(renderer);
        D3D_SetError("GetPresentParameters()", result);
        return NULL;
    }
    IDirect3DSwapChain9_Release(chain);
    if (pparams.PresentationInterval == D3DPRESENT_INTERVAL_ONE) {
        renderer-&gt;info.flags |= SDL_RENDERER_PRESENTVSYNC;
    }
    data-&gt;pparams = pparams;


    IDirect3DDevice9_GetDeviceCaps(data-&gt;device, &amp;caps);
    renderer-&gt;info.max_texture_width = caps.MaxTextureWidth;
    renderer-&gt;info.max_texture_height = caps.MaxTextureHeight;
    if (caps.NumSimultaneousRTs &gt;= 2) {
        renderer-&gt;info.flags |= SDL_RENDERER_TARGETTEXTURE;
    }


    if (caps.PrimitiveMiscCaps &amp; D3DPMISCCAPS_SEPARATEALPHABLEND) {
        data-&gt;enableSeparateAlphaBlend = SDL_TRUE;
    }


    /* Store the default render target */
    IDirect3DDevice9_GetRenderTarget(data-&gt;device, 0, &amp;data-&gt;defaultRenderTarget );
    data-&gt;currentRenderTarget = NULL;


    /* Set up parameters for rendering */
    D3D_InitRenderState(data);


    if (caps.MaxSimultaneousTextures &gt;= 3)
    {
#ifdef ASSEMBLE_SHADER
        /* This shader was created by running the following HLSL through the fxc compiler
           and then tuning the generated assembly.


           fxc /T fx_4_0 /O3 /Gfa /Fc yuv.fxc yuv.fx


           --- yuv.fx ---
           Texture2D g_txY;
           Texture2D g_txU;
           Texture2D g_txV;


           SamplerState samLinear
           {
               Filter = ANISOTROPIC;
               AddressU = Clamp;
               AddressV = Clamp;
               MaxAnisotropy = 1;
           };


           struct VS_OUTPUT
           {
                float2 TextureUV  : TEXCOORD0;
           };


           struct PS_OUTPUT
           {
                float4 RGBAColor : SV_Target;
           };


           PS_OUTPUT YUV420( VS_OUTPUT In ) 
           {
               const float3 offset = {-0.0625, -0.5, -0.5};
               const float3 Rcoeff = {1.164,  0.000,  1.596};
               const float3 Gcoeff = {1.164, -0.391, -0.813};
               const float3 Bcoeff = {1.164,  2.018,  0.000};


               PS_OUTPUT Output;
               float2 TextureUV = In.TextureUV;


               float3 yuv;
               yuv.x = g_txY.Sample( samLinear, TextureUV ).r;
               yuv.y = g_txU.Sample( samLinear, TextureUV ).r;
               yuv.z = g_txV.Sample( samLinear, TextureUV ).r;


               yuv += offset;
               Output.RGBAColor.r = dot(yuv, Rcoeff);
               Output.RGBAColor.g = dot(yuv, Gcoeff);
               Output.RGBAColor.b = dot(yuv, Bcoeff);
               Output.RGBAColor.a = 1.0f;


               return Output;
           }


           technique10 RenderYUV420
           {
               pass P0
               {
                    SetPixelShader( CompileShader( ps_4_0_level_9_0, YUV420() ) );
               }
           }
        */
        const char *shader_text =
            "ps_2_0\n"
            "def c0, -0.0625, -0.5, -0.5, 1\n"
            "def c1, 1.16400003, 0, 1.59599996, 0\n"
            "def c2, 1.16400003, -0.391000003, -0.813000023, 0\n"
            "def c3, 1.16400003, 2.01799989, 0, 0\n"
            "dcl t0.xy\n"
            "dcl v0.xyzw\n"
            "dcl_2d s0\n"
            "dcl_2d s1\n"
            "dcl_2d s2\n"
            "texld r0, t0, s0\n"
            "texld r1, t0, s1\n"
            "texld r2, t0, s2\n"
            "mov r0.y, r1.x\n"
            "mov r0.z, r2.x\n"
            "add r0.xyz, r0, c0\n"
            "dp3 r1.x, r0, c1\n"
            "dp3 r1.y, r0, c2\n"
            "dp2add r1.z, r0, c3, c3.z\n"   /* Logically this is "dp3 r1.z, r0, c3" but the optimizer did its magic */
            "mov r1.w, c0.w\n"
            "mul r0, r1, v0\n"              /* Not in the HLSL, multiply by vertex color */
            "mov oC0, r0\n"
        ;
        LPD3DXBUFFER pCode;
        LPD3DXBUFFER pErrorMsgs;
        LPDWORD shader_data = NULL;
        DWORD   shader_size = 0;
        result = D3DXAssembleShader(shader_text, SDL_strlen(shader_text), NULL, NULL, 0, &amp;pCode, &amp;pErrorMsgs);
        if (!FAILED(result)) {
            shader_data = (DWORD*)pCode-&gt;lpVtbl-&gt;GetBufferPointer(pCode);
            shader_size = pCode-&gt;lpVtbl-&gt;GetBufferSize(pCode);
            PrintShaderData(shader_data, shader_size);
        } else {
            const char *error = (const char *)pErrorMsgs-&gt;lpVtbl-&gt;GetBufferPointer(pErrorMsgs);
            SDL_SetError("Couldn't assemble shader: %s", error);
        }
#else
        const DWORD shader_data[] = {
            0xffff0200, 0x05000051, 0xa00f0000, 0xbd800000, 0xbf000000, 0xbf000000,
            0x3f800000, 0x05000051, 0xa00f0001, 0x3f94fdf4, 0x00000000, 0x3fcc49ba,
            0x00000000, 0x05000051, 0xa00f0002, 0x3f94fdf4, 0xbec83127, 0xbf5020c5,
            0x00000000, 0x05000051, 0xa00f0003, 0x3f94fdf4, 0x400126e9, 0x00000000,
            0x00000000, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f, 0x80000000,
            0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
            0xa00f0801, 0x0200001f, 0x90000000, 0xa00f0802, 0x03000042, 0x800f0000,
            0xb0e40000, 0xa0e40800, 0x03000042, 0x800f0001, 0xb0e40000, 0xa0e40801,
            0x03000042, 0x800f0002, 0xb0e40000, 0xa0e40802, 0x02000001, 0x80020000,
            0x80000001, 0x02000001, 0x80040000, 0x80000002, 0x03000002, 0x80070000,
            0x80e40000, 0xa0e40000, 0x03000008, 0x80010001, 0x80e40000, 0xa0e40001,
            0x03000008, 0x80020001, 0x80e40000, 0xa0e40002, 0x0400005a, 0x80040001,
            0x80e40000, 0xa0e40003, 0xa0aa0003, 0x02000001, 0x80080001, 0xa0ff0000,
            0x03000005, 0x800f0000, 0x80e40001, 0x90e40000, 0x02000001, 0x800f0800,
            0x80e40000, 0x0000ffff
        };
#endif
        if (shader_data != NULL) {
            result = IDirect3DDevice9_CreatePixelShader(data-&gt;device, shader_data, &amp;data-&gt;ps_yuv);
            if (!FAILED(result)) {
                renderer-&gt;info.texture_formats[renderer-&gt;info.num_texture_formats++] = SDL_PIXELFORMAT_YV12;
                renderer-&gt;info.texture_formats[renderer-&gt;info.num_texture_formats++] = SDL_PIXELFORMAT_IYUV;
            } else {
                D3D_SetError("CreatePixelShader()", result);
            }
        }
    }


    return renderer;
}</pre><br /><p></p>D3D_CreateRenderer()这个函数的代码很长。在这里提取它最重点的几个进行简单的分析。<br /><p><span style="font-family:'FangSong_GB2312';">PS：由于这个函数中包含了大量的Direct3D的API，这方面如果不熟悉的话，可以参考以下两篇文章：</span></p><p><span style="font-family:'FangSong_GB2312';">《<a href="http://blog.csdn.net/leixiaohua1020/article/details/40279297">最简单的视音频播放示例3：Direct3D播放YUV，RGB（通过Surface）</a>》</span></p><p><span style="font-family:'FangSong_GB2312';">《<a href="http://blog.csdn.net/leixiaohua1020/article/details/40301179">最简单的视音频播放示例4：Direct3D播放RGB（通过Texture）</a>》</span></p><strong>（1）<span style="white-space:pre;">	</span>为SDL_Renderer分配内存</strong><br />这一步比较简单。直接使用SDL_calloc()分配内存就可以了。SDL_calloc()实际上就是calloc()，这一点在前面的文章中已经叙述，在这里不再重复。<br /><strong>（2）<span style="white-space:pre;">	</span>加载Direct3D</strong><br />加载Direct3D通过函数D3D_LoadDLL()完成。调用该函数可以得到一个IDirect3D9类型的接口。IDirect3D9接口可以用于完成D3D后续的初始化工作。D3D_LoadDLL()函数的代码如下。<br /><pre class="cpp">SDL_bool D3D_LoadDLL( void **pD3DDLL, IDirect3D9 **pDirect3D9Interface )
{
	*pD3DDLL = SDL_LoadObject("D3D9.DLL");
	if (*pD3DDLL) {
		IDirect3D9 *(WINAPI * D3DCreate) (UINT SDKVersion);


		D3DCreate =
			(IDirect3D9 * (WINAPI *) (UINT)) SDL_LoadFunction(*pD3DDLL,
			"Direct3DCreate9");
		if (D3DCreate) {
			*pDirect3D9Interface = D3DCreate(D3D_SDK_VERSION);
		}
		if (!*pDirect3D9Interface) {
			SDL_UnloadObject(*pD3DDLL);
			*pD3DDLL = NULL;
			return SDL_FALSE;
		}


		return SDL_TRUE;
	} else {
		*pDirect3D9Interface = NULL;
		return SDL_FALSE;
	}
}</pre><br />从代码中可以看出，该函数加载了一个“D3D9.DLL”的Dll，并且调用了其中的Direct3DCreate9()方法。<br /><br /><br /><strong>（3）<span style="white-space:pre;">	</span>渲染器接口函数赋值</strong><br /><p>SDL_Render结构体中有一系列的函数指针，包含了有关渲染器的各种功能。SDL通过调用这些函数指针就可以调用渲染器相应的功能。这是SDL支持多种渲染器的一个重要特点。代码如下所示。</p><p></p><pre class="cpp">    renderer-&gt;WindowEvent = D3D_WindowEvent;
    renderer-&gt;CreateTexture = D3D_CreateTexture;
    renderer-&gt;UpdateTexture = D3D_UpdateTexture;
    renderer-&gt;UpdateTextureYUV = D3D_UpdateTextureYUV;
    renderer-&gt;LockTexture = D3D_LockTexture;
    renderer-&gt;UnlockTexture = D3D_UnlockTexture;
    renderer-&gt;SetRenderTarget = D3D_SetRenderTarget;
    renderer-&gt;UpdateViewport = D3D_UpdateViewport;
    renderer-&gt;UpdateClipRect = D3D_UpdateClipRect;
    renderer-&gt;RenderClear = D3D_RenderClear;
    renderer-&gt;RenderDrawPoints = D3D_RenderDrawPoints;
    renderer-&gt;RenderDrawLines = D3D_RenderDrawLines;
    renderer-&gt;RenderFillRects = D3D_RenderFillRects;
    renderer-&gt;RenderCopy = D3D_RenderCopy;
    renderer-&gt;RenderCopyEx = D3D_RenderCopyEx;
    renderer-&gt;RenderReadPixels = D3D_RenderReadPixels;
    renderer-&gt;RenderPresent = D3D_RenderPresent;
    renderer-&gt;DestroyTexture = D3D_DestroyTexture;
    renderer-&gt;DestroyRenderer = D3D_DestroyRenderer;</pre><br /><p></p><strong>（4）<span style="white-space:pre;">	</span>创建Device</strong><br /><p>创建Direct3D的Device通过IDirect3D9_CreateDevice()函数来实现。这一方面的知识不再叙述，可以参考Direct3D创建Device的相关的文章。</p><p><strong>（5）<span style="white-space:pre;">	</span>设置渲染状态</strong></p>设置渲染状态在函数D3D_InitRenderState()中完成。该部分的知识也不再详述，可以参考Direct3D相关的渲染教程。贴出D3D_InitRenderState()的代码。<br /><pre class="cpp">static void D3D_InitRenderState(D3D_RenderData *data)
{
    D3DMATRIX matrix;


    IDirect3DDevice9 *device = data-&gt;device;


    IDirect3DDevice9_SetVertexShader(device, NULL);
    IDirect3DDevice9_SetFVF(device, D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
    IDirect3DDevice9_SetRenderState(device, D3DRS_ZENABLE, D3DZB_FALSE);
    IDirect3DDevice9_SetRenderState(device, D3DRS_CULLMODE, D3DCULL_NONE);
    IDirect3DDevice9_SetRenderState(device, D3DRS_LIGHTING, FALSE);


    /* Enable color modulation by diffuse color */
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_COLOROP,
                                          D3DTOP_MODULATE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_COLORARG1,
                                          D3DTA_TEXTURE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_COLORARG2,
                                          D3DTA_DIFFUSE);


    /* Enable alpha modulation by diffuse alpha */
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_ALPHAOP,
                                          D3DTOP_MODULATE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_ALPHAARG1,
                                          D3DTA_TEXTURE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_ALPHAARG2,
                                          D3DTA_DIFFUSE);


    /* Enable separate alpha blend function, if possible */
    if (data-&gt;enableSeparateAlphaBlend) {
        IDirect3DDevice9_SetRenderState(device, D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
    }


    /* Disable second texture stage, since we're done */
    IDirect3DDevice9_SetTextureStageState(device, 1, D3DTSS_COLOROP,
                                          D3DTOP_DISABLE);
    IDirect3DDevice9_SetTextureStageState(device, 1, D3DTSS_ALPHAOP,
                                          D3DTOP_DISABLE);


    /* Set an identity world and view matrix */
    matrix.m[0][0] = 1.0f;
    matrix.m[0][1] = 0.0f;
    matrix.m[0][2] = 0.0f;
    matrix.m[0][3] = 0.0f;
    matrix.m[1][0] = 0.0f;
    matrix.m[1][1] = 1.0f;
    matrix.m[1][2] = 0.0f;
    matrix.m[1][3] = 0.0f;
    matrix.m[2][0] = 0.0f;
    matrix.m[2][1] = 0.0f;
    matrix.m[2][2] = 1.0f;
    matrix.m[2][3] = 0.0f;
    matrix.m[3][0] = 0.0f;
    matrix.m[3][1] = 0.0f;
    matrix.m[3][2] = 0.0f;
    matrix.m[3][3] = 1.0f;
    IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, &amp;matrix);
    IDirect3DDevice9_SetTransform(device, D3DTS_VIEW, &amp;matrix);


    /* Reset our current scale mode */
    SDL_memset(data-&gt;scaleMode, 0xFF, sizeof(data-&gt;scaleMode));


    /* Start the render with beginScene */
    data-&gt;beginScene = SDL_TRUE;
}</pre><br /><strong>（6）<span style="white-space:pre;">	</span>创建Shader</strong><br /><p>创建Shader通过函数IDirect3DDevice9_CreatePixelShader()完成。</p><p>完成以上步骤之后，Direct3D的渲染器就创建完毕了。</p><br /><h3>2.<span style="white-space:pre;">	</span>OpenGL</h3><p>OpenGL 的渲染器在创建函数是GL_CreateRenderer()。该函数位于render\opengl\SDL_render_gl.c文件中。首先看一下它的代码。</p><p><span style="font-family:'FangSong_GB2312';">PS：其中用到了OpenGL的很多API。如果对OpenGL的API还不熟悉的话，可以参考文章：</span></p><p><span style="font-family:'FangSong_GB2312';">《<a href="http://blog.csdn.net/leixiaohua1020/article/details/40379845">最简单的视音频播放示例6：OpenGL播放YUV420P（通过Texture，使用Shader）</a>》</span><br /></p><pre class="cpp">SDL_Renderer * GL_CreateRenderer(SDL_Window * window, Uint32 flags)
{
    SDL_Renderer *renderer;
    GL_RenderData *data;
    const char *hint;
    GLint value;
    Uint32 window_flags;
    int profile_mask, major, minor;


    SDL_GL_GetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, &amp;profile_mask);
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &amp;major);
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &amp;minor);
    
    window_flags = SDL_GetWindowFlags(window);
    if (!(window_flags &amp; SDL_WINDOW_OPENGL) ||
        profile_mask == SDL_GL_CONTEXT_PROFILE_ES || major != RENDERER_CONTEXT_MAJOR || minor != RENDERER_CONTEXT_MINOR) {
        
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, 0);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, RENDERER_CONTEXT_MAJOR);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RENDERER_CONTEXT_MINOR);


        if (SDL_RecreateWindow(window, window_flags | SDL_WINDOW_OPENGL) &lt; 0) {
            /* Uh oh, better try to put it back... */
            SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile_mask);
            SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, major);
            SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minor);
            SDL_RecreateWindow(window, window_flags);
            return NULL;
        }
    }


    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
    if (!renderer) {
        SDL_OutOfMemory();
        return NULL;
    }


    data = (GL_RenderData *) SDL_calloc(1, sizeof(*data));
    if (!data) {
        GL_DestroyRenderer(renderer);
        SDL_OutOfMemory();
        return NULL;
    }


    renderer-&gt;WindowEvent = GL_WindowEvent;
    renderer-&gt;GetOutputSize = GL_GetOutputSize;
    renderer-&gt;CreateTexture = GL_CreateTexture;
    renderer-&gt;UpdateTexture = GL_UpdateTexture;
    renderer-&gt;UpdateTextureYUV = GL_UpdateTextureYUV;
    renderer-&gt;LockTexture = GL_LockTexture;
    renderer-&gt;UnlockTexture = GL_UnlockTexture;
    renderer-&gt;SetRenderTarget = GL_SetRenderTarget;
    renderer-&gt;UpdateViewport = GL_UpdateViewport;
    renderer-&gt;UpdateClipRect = GL_UpdateClipRect;
    renderer-&gt;RenderClear = GL_RenderClear;
    renderer-&gt;RenderDrawPoints = GL_RenderDrawPoints;
    renderer-&gt;RenderDrawLines = GL_RenderDrawLines;
    renderer-&gt;RenderFillRects = GL_RenderFillRects;
    renderer-&gt;RenderCopy = GL_RenderCopy;
    renderer-&gt;RenderCopyEx = GL_RenderCopyEx;
    renderer-&gt;RenderReadPixels = GL_RenderReadPixels;
    renderer-&gt;RenderPresent = GL_RenderPresent;
    renderer-&gt;DestroyTexture = GL_DestroyTexture;
    renderer-&gt;DestroyRenderer = GL_DestroyRenderer;
    renderer-&gt;GL_BindTexture = GL_BindTexture;
    renderer-&gt;GL_UnbindTexture = GL_UnbindTexture;
    renderer-&gt;info = GL_RenderDriver.info;
    renderer-&gt;info.flags = (SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);
    renderer-&gt;driverdata = data;
    renderer-&gt;window = window;


    data-&gt;context = SDL_GL_CreateContext(window);
    if (!data-&gt;context) {
        GL_DestroyRenderer(renderer);
        return NULL;
    }
    if (SDL_GL_MakeCurrent(window, data-&gt;context) &lt; 0) {
        GL_DestroyRenderer(renderer);
        return NULL;
    }


    if (GL_LoadFunctions(data) &lt; 0) {
        GL_DestroyRenderer(renderer);
        return NULL;
    }


#ifdef __MACOSX__
    /* Enable multi-threaded rendering */
    /* Disabled until Ryan finishes his VBO/PBO code...
       CGLEnable(CGLGetCurrentContext(), kCGLCEMPEngine);
     */
#endif


    if (flags &amp; SDL_RENDERER_PRESENTVSYNC) {
        SDL_GL_SetSwapInterval(1);
    } else {
        SDL_GL_SetSwapInterval(0);
    }
    if (SDL_GL_GetSwapInterval() &gt; 0) {
        renderer-&gt;info.flags |= SDL_RENDERER_PRESENTVSYNC;
    }


    /* Check for debug output support */
    if (SDL_GL_GetAttribute(SDL_GL_CONTEXT_FLAGS, &amp;value) == 0 &amp;&amp;
        (value &amp; SDL_GL_CONTEXT_DEBUG_FLAG)) {
        data-&gt;debug_enabled = SDL_TRUE;
    }
    if (data-&gt;debug_enabled &amp;&amp; SDL_GL_ExtensionSupported("GL_ARB_debug_output")) {
        PFNGLDEBUGMESSAGECALLBACKARBPROC glDebugMessageCallbackARBFunc = (PFNGLDEBUGMESSAGECALLBACKARBPROC) SDL_GL_GetProcAddress("glDebugMessageCallbackARB");


        data-&gt;GL_ARB_debug_output_supported = SDL_TRUE;
        data-&gt;glGetPointerv(GL_DEBUG_CALLBACK_FUNCTION_ARB, (GLvoid **)&amp;data-&gt;next_error_callback);
        data-&gt;glGetPointerv(GL_DEBUG_CALLBACK_USER_PARAM_ARB, &amp;data-&gt;next_error_userparam);
        glDebugMessageCallbackARBFunc(GL_HandleDebugMessage, renderer);


        /* Make sure our callback is called when errors actually happen */
        data-&gt;glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB);
    }


    if (SDL_GL_ExtensionSupported("GL_ARB_texture_rectangle")
        || SDL_GL_ExtensionSupported("GL_EXT_texture_rectangle")) {
        data-&gt;GL_ARB_texture_rectangle_supported = SDL_TRUE;
        data-&gt;glGetIntegerv(GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB, &amp;value);
        renderer-&gt;info.max_texture_width = value;
        renderer-&gt;info.max_texture_height = value;
    } else {
        data-&gt;glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;value);
        renderer-&gt;info.max_texture_width = value;
        renderer-&gt;info.max_texture_height = value;
    }


    /* Check for multitexture support */
    if (SDL_GL_ExtensionSupported("GL_ARB_multitexture")) {
        data-&gt;glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC) SDL_GL_GetProcAddress("glActiveTextureARB");
        if (data-&gt;glActiveTextureARB) {
            data-&gt;GL_ARB_multitexture_supported = SDL_TRUE;
            data-&gt;glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &amp;data-&gt;num_texture_units);
        }
    }


    /* Check for shader support */
    hint = SDL_GetHint(SDL_HINT_RENDER_OPENGL_SHADERS);
    if (!hint || *hint != '0') {
        data-&gt;shaders = GL_CreateShaderContext();
    }
    SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "OpenGL shaders: %s",
                data-&gt;shaders ? "ENABLED" : "DISABLED");


    /* We support YV12 textures using 3 textures and a shader */
    if (data-&gt;shaders &amp;&amp; data-&gt;num_texture_units &gt;= 3) {
        renderer-&gt;info.texture_formats[renderer-&gt;info.num_texture_formats++] = SDL_PIXELFORMAT_YV12;
        renderer-&gt;info.texture_formats[renderer-&gt;info.num_texture_formats++] = SDL_PIXELFORMAT_IYUV;
    }


#ifdef __MACOSX__
    renderer-&gt;info.texture_formats[renderer-&gt;info.num_texture_formats++] = SDL_PIXELFORMAT_UYVY;
#endif


    if (SDL_GL_ExtensionSupported("GL_EXT_framebuffer_object")) {
        data-&gt;GL_EXT_framebuffer_object_supported = SDL_TRUE;
        data-&gt;glGenFramebuffersEXT = (PFNGLGENFRAMEBUFFERSEXTPROC)
            SDL_GL_GetProcAddress("glGenFramebuffersEXT");
        data-&gt;glDeleteFramebuffersEXT = (PFNGLDELETEFRAMEBUFFERSEXTPROC)
            SDL_GL_GetProcAddress("glDeleteFramebuffersEXT");
        data-&gt;glFramebufferTexture2DEXT = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)
            SDL_GL_GetProcAddress("glFramebufferTexture2DEXT");
        data-&gt;glBindFramebufferEXT = (PFNGLBINDFRAMEBUFFEREXTPROC)
            SDL_GL_GetProcAddress("glBindFramebufferEXT");
        data-&gt;glCheckFramebufferStatusEXT = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)
            SDL_GL_GetProcAddress("glCheckFramebufferStatusEXT");
        renderer-&gt;info.flags |= SDL_RENDERER_TARGETTEXTURE;
    }
    data-&gt;framebuffers = NULL;


    /* Set up parameters for rendering */
    GL_ResetState(renderer);


    return renderer;
}</pre><br />GL_CreateRenderer()这个函数的代码很长。在这里提取它最重点的几个进行简单的分析。<br /><br /><strong>（1）<span style="white-space:pre;">	</span>为SDL_Renderer分配内存</strong><br /><p>这一步比较简单。直接使用SDL_calloc()分配内存就可以了。</p><p><strong>（2）<span style="white-space:pre;">	</span>渲染器接口函数赋值</strong></p>SDL_Render结构体中有一系列的函数指针，包含了有关渲染器的各种功能。这一点在Direct3D的时候已经提过，不再重复。代码如下。<br /><pre class="cpp">    renderer-&gt;WindowEvent = GL_WindowEvent;
    renderer-&gt;GetOutputSize = GL_GetOutputSize;
    renderer-&gt;CreateTexture = GL_CreateTexture;
    renderer-&gt;UpdateTexture = GL_UpdateTexture;
    renderer-&gt;UpdateTextureYUV = GL_UpdateTextureYUV;
    renderer-&gt;LockTexture = GL_LockTexture;
    renderer-&gt;UnlockTexture = GL_UnlockTexture;
    renderer-&gt;SetRenderTarget = GL_SetRenderTarget;
    renderer-&gt;UpdateViewport = GL_UpdateViewport;
    renderer-&gt;UpdateClipRect = GL_UpdateClipRect;
    renderer-&gt;RenderClear = GL_RenderClear;
    renderer-&gt;RenderDrawPoints = GL_RenderDrawPoints;
    renderer-&gt;RenderDrawLines = GL_RenderDrawLines;
    renderer-&gt;RenderFillRects = GL_RenderFillRects;
    renderer-&gt;RenderCopy = GL_RenderCopy;
    renderer-&gt;RenderCopyEx = GL_RenderCopyEx;
    renderer-&gt;RenderReadPixels = GL_RenderReadPixels;
    renderer-&gt;RenderPresent = GL_RenderPresent;
    renderer-&gt;DestroyTexture = GL_DestroyTexture;
    renderer-&gt;DestroyRenderer = GL_DestroyRenderer;
    renderer-&gt;GL_BindTexture = GL_BindTexture;
    renderer-&gt;GL_UnbindTexture = GL_UnbindTexture;</pre><br /><strong>（3）<span style="white-space:pre;">	</span>初始化OpenGL</strong><br />初始化OpenGL各种变量，包括SDL_GL_CreateContext()，SDL_GL_MakeCurrent()，GL_LoadFunctions()等函数。这一部分还没有详细分析。<br /><br /><p><strong>（4）<span style="white-space:pre;">	</span>初始化Shader</strong></p><p>对Shader的初始化在函数GL_CreateShaderContext()中完成。GL_CreateShaderContext()的代码如下（位于render\opengl\SDL_shaders_gl.c）。</p><pre class="cpp">GL_ShaderContext * GL_CreateShaderContext()
{
    GL_ShaderContext *ctx;
    SDL_bool shaders_supported;
    int i;


    ctx = (GL_ShaderContext *)SDL_calloc(1, sizeof(*ctx));
    if (!ctx) {
        return NULL;
    }


    if (SDL_GL_ExtensionSupported("GL_ARB_texture_rectangle")
        || SDL_GL_ExtensionSupported("GL_EXT_texture_rectangle")) {
        ctx-&gt;GL_ARB_texture_rectangle_supported = SDL_TRUE;
    }


    /* Check for shader support */
    shaders_supported = SDL_FALSE;
    if (SDL_GL_ExtensionSupported("GL_ARB_shader_objects") &amp;&amp;
        SDL_GL_ExtensionSupported("GL_ARB_shading_language_100") &amp;&amp;
        SDL_GL_ExtensionSupported("GL_ARB_vertex_shader") &amp;&amp;
        SDL_GL_ExtensionSupported("GL_ARB_fragment_shader")) {
        ctx-&gt;glGetError = (GLenum (*)(void)) SDL_GL_GetProcAddress("glGetError");
        ctx-&gt;glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC) SDL_GL_GetProcAddress("glAttachObjectARB");
        ctx-&gt;glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC) SDL_GL_GetProcAddress("glCompileShaderARB");
        ctx-&gt;glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC) SDL_GL_GetProcAddress("glCreateProgramObjectARB");
        ctx-&gt;glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC) SDL_GL_GetProcAddress("glCreateShaderObjectARB");
        ctx-&gt;glDeleteObjectARB = (PFNGLDELETEOBJECTARBPROC) SDL_GL_GetProcAddress("glDeleteObjectARB");
        ctx-&gt;glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC) SDL_GL_GetProcAddress("glGetInfoLogARB");
        ctx-&gt;glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC) SDL_GL_GetProcAddress("glGetObjectParameterivARB");
        ctx-&gt;glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC) SDL_GL_GetProcAddress("glGetUniformLocationARB");
        ctx-&gt;glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC) SDL_GL_GetProcAddress("glLinkProgramARB");
        ctx-&gt;glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC) SDL_GL_GetProcAddress("glShaderSourceARB");
        ctx-&gt;glUniform1iARB = (PFNGLUNIFORM1IARBPROC) SDL_GL_GetProcAddress("glUniform1iARB");
        ctx-&gt;glUniform1fARB = (PFNGLUNIFORM1FARBPROC) SDL_GL_GetProcAddress("glUniform1fARB");
        ctx-&gt;glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC) SDL_GL_GetProcAddress("glUseProgramObjectARB");
        if (ctx-&gt;glGetError &amp;&amp;
            ctx-&gt;glAttachObjectARB &amp;&amp;
            ctx-&gt;glCompileShaderARB &amp;&amp;
            ctx-&gt;glCreateProgramObjectARB &amp;&amp;
            ctx-&gt;glCreateShaderObjectARB &amp;&amp;
            ctx-&gt;glDeleteObjectARB &amp;&amp;
            ctx-&gt;glGetInfoLogARB &amp;&amp;
            ctx-&gt;glGetObjectParameterivARB &amp;&amp;
            ctx-&gt;glGetUniformLocationARB &amp;&amp;
            ctx-&gt;glLinkProgramARB &amp;&amp;
            ctx-&gt;glShaderSourceARB &amp;&amp;
            ctx-&gt;glUniform1iARB &amp;&amp;
            ctx-&gt;glUniform1fARB &amp;&amp;
            ctx-&gt;glUseProgramObjectARB) {
            shaders_supported = SDL_TRUE;
        }
    }


    if (!shaders_supported) {
        SDL_free(ctx);
        return NULL;
    }


    /* Compile all the shaders */
    for (i = 0; i &lt; NUM_SHADERS; ++i) {
        if (!CompileShaderProgram(ctx, i, &amp;ctx-&gt;shaders[i])) {
            GL_DestroyShaderContext(ctx);
            return NULL;
        }
    }


    /* We're done! */
    return ctx;
}</pre><br />上述代码主要完成了以下两步：<br /><strong>第一步，初始化GL_ShaderContext。</strong>GL_ShaderContext中包含了OpenGL的Shader方面用到的各种接口函数。GL_ShaderContext定义如下。<br /><pre class="cpp">struct GL_ShaderContext
{
    GLenum (*glGetError)(void);


    PFNGLATTACHOBJECTARBPROC glAttachObjectARB;
    PFNGLCOMPILESHADERARBPROC glCompileShaderARB;
    PFNGLCREATEPROGRAMOBJECTARBPROC glCreateProgramObjectARB;
    PFNGLCREATESHADEROBJECTARBPROC glCreateShaderObjectARB;
    PFNGLDELETEOBJECTARBPROC glDeleteObjectARB;
    PFNGLGETINFOLOGARBPROC glGetInfoLogARB;
    PFNGLGETOBJECTPARAMETERIVARBPROC glGetObjectParameterivARB;
    PFNGLGETUNIFORMLOCATIONARBPROC glGetUniformLocationARB;
    PFNGLLINKPROGRAMARBPROC glLinkProgramARB;
    PFNGLSHADERSOURCEARBPROC glShaderSourceARB;
    PFNGLUNIFORM1IARBPROC glUniform1iARB;
    PFNGLUNIFORM1FARBPROC glUniform1fARB;
    PFNGLUSEPROGRAMOBJECTARBPROC glUseProgramObjectARB;


    SDL_bool GL_ARB_texture_rectangle_supported;


    GL_ShaderData shaders[NUM_SHADERS];
};</pre><br />看这个结构体的定义会给人一种很混乱的感觉。不用去理会那些大串的大写字母，只要知道这个结构体是函数的接口的“合集”就可以了。从函数的名称中我们可以看出有编译Shader的glCreateShaderObject()，glShaderSource()，glCompileShader()等；以及编译Program的glCreateProgramObject()，glAttachObject ()，glLinkProgram()，glUseProgramObject ()等等。<br />GL_CreateShaderContext()函数中创建了一个GL_ShaderContext并对其中的接口函数进行了赋值。<br /><br /><strong>第二步，编译Shader程序。</strong>该功能在CompileShaderProgram()函数中完成。CompileShaderProgram()的函数代码如下所示。<br /><pre class="cpp">static SDL_bool CompileShaderProgram(GL_ShaderContext *ctx, int index, GL_ShaderData *data)
{
    const int num_tmus_bound = 4;
    const char *vert_defines = "";
    const char *frag_defines = "";
    int i;
    GLint location;


    if (index == SHADER_NONE) {
        return SDL_TRUE;
    }


    ctx-&gt;glGetError();


    /* Make sure we use the correct sampler type for our texture type */
    if (ctx-&gt;GL_ARB_texture_rectangle_supported) {
        frag_defines =
"#define sampler2D sampler2DRect\n"
"#define texture2D texture2DRect\n";
    }


    /* Create one program object to rule them all */
    data-&gt;program = ctx-&gt;glCreateProgramObjectARB();


    /* Create the vertex shader */
    data-&gt;vert_shader = ctx-&gt;glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
    if (!CompileShader(ctx, data-&gt;vert_shader, vert_defines, shader_source[index][0])) {
        return SDL_FALSE;
    }


    /* Create the fragment shader */
    data-&gt;frag_shader = ctx-&gt;glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
    if (!CompileShader(ctx, data-&gt;frag_shader, frag_defines, shader_source[index][1])) {
        return SDL_FALSE;
    }


    /* ... and in the darkness bind them */
    ctx-&gt;glAttachObjectARB(data-&gt;program, data-&gt;vert_shader);
    ctx-&gt;glAttachObjectARB(data-&gt;program, data-&gt;frag_shader);
    ctx-&gt;glLinkProgramARB(data-&gt;program);


    /* Set up some uniform variables */
    ctx-&gt;glUseProgramObjectARB(data-&gt;program);
    for (i = 0; i &lt; num_tmus_bound; ++i) {
        char tex_name[10];
        SDL_snprintf(tex_name, SDL_arraysize(tex_name), "tex%d", i);
        location = ctx-&gt;glGetUniformLocationARB(data-&gt;program, tex_name);
        if (location &gt;= 0) {
            ctx-&gt;glUniform1iARB(location, i);
        }
    }
    ctx-&gt;glUseProgramObjectARB(0);


    return (ctx-&gt;glGetError() == GL_NO_ERROR);
}</pre><br /><p>从代码中可以看出，这个函数调用了GL_ShaderContext中用于初始化Shader以及Program的各个函数。有关初始化的流程不再细说，可以参考相关的文章。</p>在该函数中，调用了CompileShader()专门用于初始化Shader。该函数被调用了两次，分别用于初始化vertex shader和fragment shader。<br /><p>CompileShader()的代码如下。</p><p></p><pre class="cpp">static SDL_bool CompileShader(GL_ShaderContext *ctx, GLhandleARB shader, const char *defines, const char *source)
{
    GLint status;
    const char *sources[2];


    sources[0] = defines;
    sources[1] = source;


    ctx-&gt;glShaderSourceARB(shader, SDL_arraysize(sources), sources, NULL);
    ctx-&gt;glCompileShaderARB(shader);
    ctx-&gt;glGetObjectParameterivARB(shader, GL_OBJECT_COMPILE_STATUS_ARB, &amp;status);
    if (status == 0) {
        GLint length;
        char *info;


        ctx-&gt;glGetObjectParameterivARB(shader, GL_OBJECT_INFO_LOG_LENGTH_ARB, &amp;length);
        info = SDL_stack_alloc(char, length+1);
        ctx-&gt;glGetInfoLogARB(shader, length, NULL, info);
        SDL_LogError(SDL_LOG_CATEGORY_RENDER,
            "Failed to compile shader:\n%s%s\n%s", defines, source, info);
#ifdef DEBUG_SHADERS
        fprintf(stderr,
            "Failed to compile shader:\n%s%s\n%s", defines, source, info);
#endif
        SDL_stack_free(info);


        return SDL_FALSE;
    } else {
        return SDL_TRUE;
    }
}</pre><br /><p></p>从代码中可以看出，该函数调用glShaderSource()，glCompileShader()，glGetObjectParameteriv()这几个函数初始化一个Shader。<br />Shader的代码位于一个名称为shader_source的char型二维数组里，源代码如下所示。数组中每个元素代表一个Shader的代码，每个Shader的代码包含两个部分：vertex shader代码（对应元素[0]）以及fragment shader代码（对应元素[1]）。<br /><pre class="cpp">/*
 * NOTE: Always use sampler2D, etc here. We'll #define them to the
 *  texture_rectangle versions if we choose to use that extension.
 */
static const char *shader_source[NUM_SHADERS][2] =
{
    /* SHADER_NONE */
    { NULL, NULL },


    /* SHADER_SOLID */
    {
        /* vertex shader */
"varying vec4 v_color;\n"
"\n"
"void main()\n"
"{\n"
"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"    v_color = gl_Color;\n"
"}",
        /* fragment shader */
"varying vec4 v_color;\n"
"\n"
"void main()\n"
"{\n"
"    gl_FragColor = v_color;\n"
"}"
    },


    /* SHADER_RGB */
    {
        /* vertex shader */
"varying vec4 v_color;\n"
"varying vec2 v_texCoord;\n"
"\n"
"void main()\n"
"{\n"
"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"    v_color = gl_Color;\n"
"    v_texCoord = vec2(gl_MultiTexCoord0);\n"
"}",
        /* fragment shader */
"varying vec4 v_color;\n"
"varying vec2 v_texCoord;\n"
"uniform sampler2D tex0;\n"
"\n"
"void main()\n"
"{\n"
"    gl_FragColor = texture2D(tex0, v_texCoord) * v_color;\n"
"}"
    },


    /* SHADER_YV12 */
    {
        /* vertex shader */
"varying vec4 v_color;\n"
"varying vec2 v_texCoord;\n"
"\n"
"void main()\n"
"{\n"
"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"    v_color = gl_Color;\n"
"    v_texCoord = vec2(gl_MultiTexCoord0);\n"
"}",
        /* fragment shader */
"varying vec4 v_color;\n"
"varying vec2 v_texCoord;\n"
"uniform sampler2D tex0; // Y \n"
"uniform sampler2D tex1; // U \n"
"uniform sampler2D tex2; // V \n"
"\n"
"// YUV offset \n"
"const vec3 offset = vec3(-0.0625, -0.5, -0.5);\n"
"\n"
"// RGB coefficients \n"
"const vec3 Rcoeff = vec3(1.164,  0.000,  1.596);\n"
"const vec3 Gcoeff = vec3(1.164, -0.391, -0.813);\n"
"const vec3 Bcoeff = vec3(1.164,  2.018,  0.000);\n"
"\n"
"void main()\n"
"{\n"
"    vec2 tcoord;\n"
"    vec3 yuv, rgb;\n"
"\n"
"    // Get the Y value \n"
"    tcoord = v_texCoord;\n"
"    yuv.x = texture2D(tex0, tcoord).r;\n"
"\n"
"    // Get the U and V values \n"
"    tcoord *= 0.5;\n"
"    yuv.y = texture2D(tex1, tcoord).r;\n"
"    yuv.z = texture2D(tex2, tcoord).r;\n"
"\n"
"    // Do the color transform \n"
"    yuv += offset;\n"
"    rgb.r = dot(yuv, Rcoeff);\n"
"    rgb.g = dot(yuv, Gcoeff);\n"
"    rgb.b = dot(yuv, Bcoeff);\n"
"\n"
"    // That was easy. :) \n"
"    gl_FragColor = vec4(rgb, 1.0) * v_color;\n"
"}"
    },
};</pre><br />有关OpenGL的渲染器的初始化代码暂时分析到这里。<br /><h3>3.<span style="white-space:pre;">	</span>Software</h3><p>Software的渲染器在创建函数是SW_CreateRenderer()。该函数位于render\software\SDL_render_sw.c文件中。首先看一下它的代码。</p><pre class="cpp">SDL_Renderer * SW_CreateRenderer(SDL_Window * window, Uint32 flags)
{
    SDL_Surface *surface;


    surface = SDL_GetWindowSurface(window);
    if (!surface) {
        return NULL;
    }
    return SW_CreateRendererForSurface(surface);
}</pre><br />从代码中可以看出，SW_CreateRenderer()调用了2个函数：SDL_GetWindowSurface()和SW_CreateRendererForSurface()。SDL_GetWindowSurface()用于创建一个Surface；SW_CreateRendererForSurface()基于Surface创建一个Renderer。<br />下面分别看一下这2个函数的代码。<br />SDL_GetWindowSurface()的代码如下所示（位于video\SDL_video.c）。<br /><pre class="cpp">SDL_Surface * SDL_GetWindowSurface(SDL_Window * window)
{
    CHECK_WINDOW_MAGIC(window, NULL);


    if (!window-&gt;surface_valid) {
        if (window-&gt;surface) {
            window-&gt;surface-&gt;flags &amp;= ~SDL_DONTFREE;
            SDL_FreeSurface(window-&gt;surface);
        }
        window-&gt;surface = SDL_CreateWindowFramebuffer(window);
        if (window-&gt;surface) {
            window-&gt;surface_valid = SDL_TRUE;
            window-&gt;surface-&gt;flags |= SDL_DONTFREE;
        }
    }
    return window-&gt;surface;
}</pre><br />其中调用了一个函数SDL_CreateWindowFramebuffer()，看一下该函数的代码。<br /><pre class="cpp">static SDL_Surface * SDL_CreateWindowFramebuffer(SDL_Window * window)
{
    Uint32 format;
    void *pixels;
    int pitch;
    int bpp;
    Uint32 Rmask, Gmask, Bmask, Amask;


    if (!_this-&gt;CreateWindowFramebuffer || !_this-&gt;UpdateWindowFramebuffer) {
        return NULL;
    }


    if (_this-&gt;CreateWindowFramebuffer(_this, window, &amp;format, &amp;pixels, &amp;pitch) &lt; 0) {
        return NULL;
    }


    if (!SDL_PixelFormatEnumToMasks(format, &amp;bpp, &amp;Rmask, &amp;Gmask, &amp;Bmask, &amp;Amask)) {
        return NULL;
    }


    return SDL_CreateRGBSurfaceFrom(pixels, window-&gt;w, window-&gt;h, bpp, pitch, Rmask, Gmask, Bmask, Amask);
}</pre><br /><p>该函数中调用了SDL_VideoDevice中的一个函数CreateWindowFramebuffer()。我们以“Windows视频驱动”为例，看看CreateWindowFramebuffer()中的代码。在“Windows视频驱动”下，CreateWindowFramebuffer()对应的函数是WIN_CreateWindowFramebuffer()。下面看一下该函数的代码。</p><p></p><pre class="cpp">int WIN_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch)
{
    SDL_WindowData *data = (SDL_WindowData *) window-&gt;driverdata;
    size_t size;
    LPBITMAPINFO info;
    HBITMAP hbm;


    /* Free the old framebuffer surface */
    if (data-&gt;mdc) {
        DeleteDC(data-&gt;mdc);
    }
    if (data-&gt;hbm) {
        DeleteObject(data-&gt;hbm);
    }


    /* Find out the format of the screen */
    size = sizeof(BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD);
    info = (LPBITMAPINFO)SDL_stack_alloc(Uint8, size);


    SDL_memset(info, 0, size);
    info-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER);


    /* The second call to GetDIBits() fills in the bitfields */
    hbm = CreateCompatibleBitmap(data-&gt;hdc, 1, 1);
    GetDIBits(data-&gt;hdc, hbm, 0, 0, NULL, info, DIB_RGB_COLORS);
    GetDIBits(data-&gt;hdc, hbm, 0, 0, NULL, info, DIB_RGB_COLORS);
    DeleteObject(hbm);


    *format = SDL_PIXELFORMAT_UNKNOWN;
    if (info-&gt;bmiHeader.biCompression == BI_BITFIELDS) {
        int bpp;
        Uint32 *masks;


        bpp = info-&gt;bmiHeader.biPlanes * info-&gt;bmiHeader.biBitCount;
        masks = (Uint32*)((Uint8*)info + info-&gt;bmiHeader.biSize);
        *format = SDL_MasksToPixelFormatEnum(bpp, masks[0], masks[1], masks[2], 0);
    }
    if (*format == SDL_PIXELFORMAT_UNKNOWN)
    {
        /* We'll use RGB format for now */
        *format = SDL_PIXELFORMAT_RGB888;


        /* Create a new one */
        SDL_memset(info, 0, size);
        info-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        info-&gt;bmiHeader.biPlanes = 1;
        info-&gt;bmiHeader.biBitCount = 32;
        info-&gt;bmiHeader.biCompression = BI_RGB;
    }


    /* Fill in the size information */
    *pitch = (((window-&gt;w * SDL_BYTESPERPIXEL(*format)) + 3) &amp; ~3);
    info-&gt;bmiHeader.biWidth = window-&gt;w;
    info-&gt;bmiHeader.biHeight = -window-&gt;h;  /* negative for topdown bitmap */
    info-&gt;bmiHeader.biSizeImage = window-&gt;h * (*pitch);


    data-&gt;mdc = CreateCompatibleDC(data-&gt;hdc);
    data-&gt;hbm = CreateDIBSection(data-&gt;hdc, info, DIB_RGB_COLORS, pixels, NULL, 0);
    SDL_stack_free(info);


    if (!data-&gt;hbm) {
        return WIN_SetError("Unable to create DIB");
    }
    SelectObject(data-&gt;mdc, data-&gt;hbm);


    return 0;
}</pre><br /><p></p>从代码中可以看出，该函数调用了Win32的API函数CreateCompatibleBitmap()，CreateCompatibleDC()等一系列方法创建了“Surface”。<br /><br />SDL_GetWindowSurface()函数到此分析完毕，现在回过头来再看SW_CreateRenderer ()的另一个函数SW_CreateRendererForSurface()。该函数的代码如下。<br /><pre class="cpp">SDL_Renderer * SW_CreateRendererForSurface(SDL_Surface * surface)
{
    SDL_Renderer *renderer;
    SW_RenderData *data;


    if (!surface) {
        SDL_SetError("Can't create renderer for NULL surface");
        return NULL;
    }


    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
    if (!renderer) {
        SDL_OutOfMemory();
        return NULL;
    }


    data = (SW_RenderData *) SDL_calloc(1, sizeof(*data));
    if (!data) {
        SW_DestroyRenderer(renderer);
        SDL_OutOfMemory();
        return NULL;
    }
    data-&gt;surface = surface;


    renderer-&gt;WindowEvent = SW_WindowEvent;
    renderer-&gt;GetOutputSize = SW_GetOutputSize;
    renderer-&gt;CreateTexture = SW_CreateTexture;
    renderer-&gt;SetTextureColorMod = SW_SetTextureColorMod;
    renderer-&gt;SetTextureAlphaMod = SW_SetTextureAlphaMod;
    renderer-&gt;SetTextureBlendMode = SW_SetTextureBlendMode;
    renderer-&gt;UpdateTexture = SW_UpdateTexture;
    renderer-&gt;LockTexture = SW_LockTexture;
    renderer-&gt;UnlockTexture = SW_UnlockTexture;
    renderer-&gt;SetRenderTarget = SW_SetRenderTarget;
    renderer-&gt;UpdateViewport = SW_UpdateViewport;
    renderer-&gt;UpdateClipRect = SW_UpdateClipRect;
    renderer-&gt;RenderClear = SW_RenderClear;
    renderer-&gt;RenderDrawPoints = SW_RenderDrawPoints;
    renderer-&gt;RenderDrawLines = SW_RenderDrawLines;
    renderer-&gt;RenderFillRects = SW_RenderFillRects;
    renderer-&gt;RenderCopy = SW_RenderCopy;
    renderer-&gt;RenderCopyEx = SW_RenderCopyEx;
    renderer-&gt;RenderReadPixels = SW_RenderReadPixels;
    renderer-&gt;RenderPresent = SW_RenderPresent;
    renderer-&gt;DestroyTexture = SW_DestroyTexture;
    renderer-&gt;DestroyRenderer = SW_DestroyRenderer;
    renderer-&gt;info = SW_RenderDriver.info;
    renderer-&gt;driverdata = data;


    SW_ActivateRenderer(renderer);


    return renderer;
}</pre><br />与前面的函数一样，该函数完成了SDL_Renderer结构体中函数指针的赋值。<br /><br /><div><h2><br /></h2></div>            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/40723085		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=SDL&t=blog" target="_blank">SDL						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=OpenGL&t=blog" target="_blank">OpenGL						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=Direct3D&t=blog" target="_blank">Direct3D						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=GDI&t=blog" target="_blank">GDI						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=渲染&t=blog" target="_blank">渲染						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/2619497"  target="_blank">SDL						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/osmedia.html" target="_blank">开源多媒体项目源代码分析</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div data-track-view='{"mod":"popu_625","con": ",https://blog.csdn.net/leixiaohua1020/article/details/40723085,from_360"}' style="margin-top: 8px;padding: 20px;background-color: #fff;overflow: hidden;" id="adt0"></div>
                            <script>
                                var adWidth = $("div.blog-content-box").outerWidth() - 40;
                                NEWS_FEED({
                                    w: adWidth,
                                    h : 130,
                                    showid : "s02a31",
                                    placeholderId: "adt0",
                                    inject : "define",
                                    define : {
                                    imagePosition : "right",
                                    imageBorderRadius : 0,
                                    imageWidth: 231,
                                    imageHeight: 130,
                                    imageFill : "clip",
                                    displayImage : true,
                                    displayTitle : true,
                                    titleFontSize: 20,
                                    titleFontColor: "#333",
                                    titleFontFamily : "Microsoft Yahei",
                                    titleFontWeight: "bold",
                                    titlePaddingTop : 0,
                                    titlePaddingRight : 0,
                                    titlePaddingBottom : 10,
                                    titlePaddingLeft : 0,
                                    displayDesc : true,
                                    descFontSize: 14,
                                    descFontColor: "#6b6b6b",
                                    descFontFamily : "Microsoft Yahei",
                                    paddingTop : 0,
                                    paddingRight : 0,
                                    paddingBottom : 0,
                                    paddingLeft : 0,
                                    backgroundColor: "#fff",
                                    hoverColor: "#ca0c16"
                                    }
                                })
                            </script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/40723085#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/cffishappy/article/details/51671684" target="_blank" strategy="BlogCommendFromBaidu_0">
				SDL_CreateRenderer(screen, -1, 0)在xp中崩溃			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/cffishappy/article/details/51671684" target="_blank" >
				SDL_CreateRenderer()

函数简介
SDL中使用SDL_CreateRenderer()基于窗口创建<em>渲染器</em>。SDL_CreateRenderer()原型如下。



[cpp] vi...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/cffishappy" title="cffishappy" target="_blank">
					<img src="https://avatar.csdn.net/C/1/9/3_cffishappy.jpg" alt="cffishappy" class="avatar-pic">
					<span class="name">cffishappy</span>
				</a>
			</p>
			<p>
				<span class="date">2016-06-14 14:48:45</span>
			</p>
			<p>
				<span class="read-num">阅读数：1608</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/konga/article/details/44837669" target="_blank" strategy="BlogCommendFromBaidu_1">
				SDL_Texture与<em>SDL_Renderer</em>示例			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/konga/article/details/44837669" target="_blank" >
				#include 
#include 
#include 

SDL_Window * window;
<em>SDL_Renderer</em> * renderer;
SDL_Texture * texture;
...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/konga" title="konga" target="_blank">
					<img src="https://avatar.csdn.net/2/B/0/3_konga.jpg" alt="konga" class="avatar-pic">
					<span class="name">konga</span>
				</a>
			</p>
			<p>
				<span class="date">2015-04-02 21:25:04</span>
			</p>
			<p>
				<span class="read-num">阅读数：2872</span>
			</p>
		</div>
	</div>
								<div class="recommend-item-box recommend-ad-box" id="ad1"></div>
				<script>
				  var width = $("div.recommend-box").outerWidth() - 48;
					NEWS_FEED({
						w: width,
						h : 90,
						showid : 'GNKXx7',
						placeholderId: "ad1",
						inject : 'define',
						define : {
							imagePosition : 'right',
							imageBorderRadius : 0,
							imageWidth: 120,
							imageHeight: 90,
							imageFill : 'clip',
							displayImage : true,
							displayTitle : true,
							titleFontSize: 20,
							titleFontColor: '#333',
							titleFontFamily : 'Microsoft Yahei',
							titleFontWeight: 'bold',
							titlePaddingTop : 0,
							titlePaddingRight : 0,
							titlePaddingBottom : 10,
							titlePaddingLeft : 0,
							displayDesc : true,
							descFontSize: 14,
							descFontColor: '#6b6b6b',
							descFontFamily : 'Microsoft Yahei',
							paddingTop : 0,
							paddingRight : 0,
							paddingBottom : 0,
							paddingLeft : 0,
							backgroundColor: '#fff',
							hoverColor: '#ca0c16'
						}
					})
				</script>

			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/kof98765/article/details/16115425" target="_blank" strategy="BlogCommendFromBaidu_2">
				SDL学习——画图、点阵显示			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/kof98765/article/details/16115425" target="_blank" >
				很久以前，发表了几篇SDL在Windows编译的文章，同时也参考网上的一个十分简单的例子写了测试的程序，本文章将以此为基础并添加自己的代码。

回首第1篇关于SDL的文章，那已是去年12月份写的了...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/kof98765" title="kof98765" target="_blank">
					<img src="https://avatar.csdn.net/5/7/6/3_kof98765.jpg" alt="kof98765" class="avatar-pic">
					<span class="name">kof98765</span>
				</a>
			</p>
			<p>
				<span class="date">2013-11-14 13:17:45</span>
			</p>
			<p>
				<span class="read-num">阅读数：2560</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/qp120291570/article/details/14442895" target="_blank" strategy="BlogCommendFromBaidu_3">
				<em>SDL2</em>.0上手试用			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/qp120291570/article/details/14442895" target="_blank" >
				前言       个人喜好原因，写OpenGL的程序都喜欢用SDL做框架，没有Qt那么臃肿，也没有glut那么坑跌,在不失灵活性的情况下保持了自己的轻量。<em>SDL2</em>.0在今年很早的时候时候就发布了，几天...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/qp120291570" title="qp120291570" target="_blank">
					<img src="https://avatar.csdn.net/5/2/9/3_qp120291570.jpg" alt="qp120291570" class="avatar-pic">
					<span class="name">qp120291570</span>
				</a>
			</p>
			<p>
				<span class="date">2013-11-09 17:02:39</span>
			</p>
			<p>
				<span class="read-num">阅读数：10407</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/u014299153/article/details/69267077" target="_blank" strategy="BlogCommendFromBaidu_4">
				SDL 2 游戏编程（零）配置环境			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/u014299153/article/details/69267077" target="_blank" >
				原文链接Lazy Foo’ Productions (2004-2015) 
因为我用的code block，所以这里只放下code block的环境配置方法供参考~
从官网下载 SDL 2，code...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/u014299153" title="u014299153" target="_blank">
					<img src="https://avatar.csdn.net/1/0/3/3_u014299153.jpg" alt="u014299153" class="avatar-pic">
					<span class="name">u014299153</span>
				</a>
			</p>
			<p>
				<span class="date">2017-04-05 17:36:23</span>
			</p>
			<p>
				<span class="read-num">阅读数：843</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/i_scream_/article/details/52760033" target="_blank" strategy="BlogCommendFromBaidu_5">
				[6] ffmpeg + <em>SDL2</em> 实现的视频播放器「视音频同步」			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/i_scream_/article/details/52760033" target="_blank" >
				日期：2016.10.8 
作者：isshe  
github：github.com/isshe  
邮箱：i.sshe@outlook.com  
平台：ubuntu16.04 64bit前言
这个...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/i_scream_" title="i_scream_" target="_blank">
					<img src="https://avatar.csdn.net/F/E/8/3_i_scream_.jpg" alt="i_scream_" class="avatar-pic">
					<span class="name">i_scream_</span>
				</a>
			</p>
			<p>
				<span class="date">2016-10-09 00:40:27</span>
			</p>
			<p>
				<span class="read-num">阅读数：4402</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/gz_chen/article/details/72639146" target="_blank" strategy="BlogCommendFromBaidu_6">
				<em>SDL2</em>显示YUV图像			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/gz_chen/article/details/72639146" target="_blank" >
				<em>SDL2</em>显示YUV图像简单例子			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/gz_chen" title="gz_chen" target="_blank">
					<img src="https://avatar.csdn.net/A/F/9/3_gz_chen.jpg" alt="gz_chen" class="avatar-pic">
					<span class="name">gz_chen</span>
				</a>
			</p>
			<p>
				<span class="date">2017-05-23 13:59:23</span>
			</p>
			<p>
				<span class="read-num">阅读数：610</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/sdragonx/article/details/54846897" target="_blank" strategy="BlogCommendFromBaidu_7">
				<em>SDL2</em>和glfw库windows下创建到界面窗口中的简单方法			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/sdragonx/article/details/54846897" target="_blank" >
				<em>SDL2</em>和glfw库windows下创建到界面窗口中的简单方法：网上查了一天的资料，有介绍如何修改源代码的，操作很复杂。最简单的方法，就是通过wglGetCurrentDC()这个函数得到当前<em>SDL2</em>...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/sdragonx" title="sdragonx" target="_blank">
					<img src="https://avatar.csdn.net/C/9/6/3_sdragonx.jpg" alt="sdragonx" class="avatar-pic">
					<span class="name">sdragonx</span>
				</a>
			</p>
			<p>
				<span class="date">2017-02-03 15:06:09</span>
			</p>
			<p>
				<span class="read-num">阅读数：1573</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/i_scream_/article/details/52714378" target="_blank" strategy="BlogCommendFromBaidu_8">
				[2] SDL的基础知识以及利用SDL播放视频			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/i_scream_/article/details/52714378" target="_blank" >
				SDL 的基础知识以及利用SDL播放视频此博文相关知识点从雷神的博客以及视频学习，截图也是用了他的课件,  
雷神博客地址：http://blog.csdn.net/leixiaohua1020/日期...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/i_scream_" title="i_scream_" target="_blank">
					<img src="https://avatar.csdn.net/F/E/8/3_i_scream_.jpg" alt="i_scream_" class="avatar-pic">
					<span class="name">i_scream_</span>
				</a>
			</p>
			<p>
				<span class="date">2016-10-01 01:07:54</span>
			</p>
			<p>
				<span class="read-num">阅读数：2949</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/korekara88730/article/details/70880061" target="_blank" strategy="BlogCommendFromBaidu_9">
				<em>SDL2</em>画点 随手记			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/korekara88730/article/details/70880061" target="_blank" >
				SDL官网
http://www.libsdl.org/

参考链接
http://lazyfoo.net/tutorials/SDL/08_geometry_rendering/index....			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/korekara88730" title="korekara88730" target="_blank">
					<img src="https://avatar.csdn.net/A/8/8/3_korekara88730.jpg" alt="korekara88730" class="avatar-pic">
					<span class="name">korekara88730</span>
				</a>
			</p>
			<p>
				<span class="date">2017-04-27 21:37:57</span>
			</p>
			<p>
				<span class="read-num">阅读数：632</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/40723085" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421240">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>8</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "SDL2源代码分析3：渲染器（SDL_Renderer）";
    var ChannelId = 16;
    var articleId = "40723085";
    var commentscount = 1;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/40723085";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "sdl2+%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81sdl_renderer_accelerated";
    var needInsertBaidu = true;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"SDL2源代码分析3：渲染器（SDL_Renderer）");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=sdl2+%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81sdl_renderer_accelerated"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>