<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/45583217"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文简单分析x264项目中的命令行工具（x264.exe）的源代码。该命令行工具可以调用libx264将YUV格式像素数据编码为H.264码流。" />
    <meta name="keywords" content="x264,H.264" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>x264源代码简单分析：x264命令行工具（x264.exe） - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45583217"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">x264源代码简单分析：x264命令行工具（x264.exe）</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年05月08日 18:30:23</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：11945</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p></p><p>=====================================================</p><p>H.264源代码分析文章列表：</p><p>【编码 - x264】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45536607" rel="nofollow">x264源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45583217" rel="nofollow">x264源代码简单分析：x264命令行工具（x264.exe）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45644367" rel="nofollow">x264源代码简单分析：编码器主干部分-1</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45719905" rel="nofollow">x264源代码简单分析：编码器主干部分-2</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45790195" rel="nofollow">x264源代码简单分析：x264_slice_write()</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45870269" rel="nofollow">x264源代码简单分析：滤波（Filter）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45917757" rel="nofollow">x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45936267" rel="nofollow">x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45938927" rel="nofollow">x264源代码简单分析：宏块编码（Encode）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45944811" rel="nofollow">x264源代码简单分析：熵编码（Entropy Encoding）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45960409" rel="nofollow">FFmpeg与libx264接口源代码简单分析</a></p><p>【解码 - libavcodec H.264 解码器】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/44864509" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45001033" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45042755" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：解码器主干部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45114453" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45143075" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45195291" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45224579" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分</a></p><p>=====================================================</p><br /><p>本文简单分析x264项目中的命令行工具（x264.exe）的源代码。该命令行工具可以调用libx264将YUV格式像素数据编码为H.264码流。</p><p><br /></p><p><br /></p><h2>函数调用关系图</h2><p>X264命令行工具的源代码在x264中的位置如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201505/06/1430897637_6272.jpg" rel="nofollow"><img src="https://img-blog.csdn.net/20150508175003437" alt="" /></a><br /></p><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1807927" rel="nofollow">单击查看更清晰的图片</a></div><br />X264命令行工具的源代码的调用关系如下图所示。<br /><div style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201505/08/1431078768_4360.jpg" rel="nofollow"><img src="https://img-blog.csdn.net/20150508174931625" alt="" />&nbsp;</a></div><div style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1808029" rel="nofollow">单击查看更清晰的图片</a></div><br />从图中可以看出，X264命令行工具调用了libx264的几个API完成了H.264编码工作。使用libx264的API进行编码可以参考《<a target=_blank target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/42078645" rel="nofollow">最简单的视频编码器：基于libx264（编码YUV为H.264）</a>》，这个流程中最关键的API包括：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">x264_param_default()：设置参数集结构体x264_param_t的缺省值。<br />x264_encoder_open()：打开编码器。<br />x264_encoder_headers()：输出SPS，PPS，SEI等信息。<br />x264_encoder_encode()：编码输出一帧图像。<br />x264_encoder_close()：关闭编码器。</blockquote><p>在X264命令行工具中，main()首先调用parse()解析输入的命令行参数，然后调用encode()进行编码。parse()首先调用x264_param_default()为存储参数的结构体x264_param_t赋默认值；然后在一个大循环中调用getopt_long()逐个解析输入的参数，并作相应的处理；最后调用select_input()和select_output()解析输入文件格式（例如yuv，y4m…）和输出文件格式（例如raw，flv，MP4…）。encode()首先调用x264_encoder_open()打开H.264编码器，然后调用x264_encoder_headers()输出H.264码流的头信息（例如SPS、PPS、SEI），接着进入一个循环并且调用encode_frame()逐帧编码视频，最后调用x264_encoder_close()关闭解码器。其中encode_frame()中又调用了x264_encoder_encode()完成了具体的编码工作。下文将会对上述流程展开分析。</p><p><br /></p><p><br /></p><h2>main()</h2>main()是x264控制台程序的入口函数，定义如下所示。<br /><pre name="code" class="cpp">//主函数
int main( int argc, char **argv )
{
	//参数集
    x264_param_t param;
    cli_opt_t opt = {0};
    int ret = 0;

    FAIL_IF_ERROR( x264_threading_init(), &quot;unable to initialize threading\n&quot; )

#ifdef _WIN32
    FAIL_IF_ERROR( !get_argv_utf8( &amp;argc, &amp;argv ), &quot;unable to convert command line to UTF-8\n&quot; )

    GetConsoleTitleW( org_console_title, CONSOLE_TITLE_SIZE );
    _setmode( _fileno( stdin ),  _O_BINARY );
    _setmode( _fileno( stdout ), _O_BINARY );
    _setmode( _fileno( stderr ), _O_BINARY );
#endif

    /* Parse command line */
    //解析命令行输入
    if( parse( argc, argv, ¶m, &amp;opt ) &lt; 0 )
        ret = -1;

#ifdef _WIN32
    /* Restore title; it can be changed by input modules */
    SetConsoleTitleW( org_console_title );
#endif

    /* Control-C handler */
    signal( SIGINT, sigint_handler );
    //编码
    if( !ret )
        ret = encode( ¶m, &amp;opt );

    /* clean up handles */
    if( filter.free )
        filter.free( opt.hin );
    else if( opt.hin )
        cli_input.close_file( opt.hin );
    if( opt.hout )
        cli_output.close_file( opt.hout, 0, 0 );
    if( opt.tcfile_out )
        fclose( opt.tcfile_out );
    if( opt.qpfile )
        fclose( opt.qpfile );

#ifdef _WIN32
    SetConsoleTitleW( org_console_title );
    free( argv );
#endif

    return ret;
}
</pre><br />可以看出main()的定义很简单，它主要调用了两个函数：parse()和encode()。main()首先调用parse()解析输入的命令行参数，然后调用encode()进行编码。下面分别分析这两个函数。<br /><p><br /></p><p><br /></p><h2>parse()</h2>parse()用于解析命令行输入的参数（存储于argv[]中）。它的定义如下所示。<br /><pre name="code" class="cpp">//解析命令行输入
static int parse( int argc, char **argv, x264_param_t *param, cli_opt_t *opt )
{
    char *input_filename = NULL;
    const char *demuxer = demuxer_names[0];
    char *output_filename = NULL;
    const char *muxer = muxer_names[0];
    char *tcfile_name = NULL;
    x264_param_t defaults;
    char *profile = NULL;
    char *vid_filters = NULL;
    int b_thread_input = 0;
    int b_turbo = 1;
    int b_user_ref = 0;
    int b_user_fps = 0;
    int b_user_interlaced = 0;
    cli_input_opt_t input_opt;
    cli_output_opt_t output_opt;
    char *preset = NULL;
    char *tune = NULL;
    //初始化参数默认值
    x264_param_default( &amp;defaults );
    cli_log_level = defaults.i_log_level;

    memset( &amp;input_opt, 0, sizeof(cli_input_opt_t) );
    memset( &amp;output_opt, 0, sizeof(cli_output_opt_t) );
    input_opt.bit_depth = 8;
    input_opt.input_range = input_opt.output_range = param-&gt;vui.b_fullrange = RANGE_AUTO;
    int output_csp = defaults.i_csp;
    opt-&gt;b_progress = 1;

    /* Presets are applied before all other options. */
    for( optind = 0;; )
    {
        int c = getopt_long( argc, argv, short_options, long_options, NULL );
        if( c == -1 )
            break;
        if( c == OPT_PRESET )
            preset = optarg;
        if( c == OPT_TUNE )
            tune = optarg;
        else if( c == '?' )
            return -1;
    }

    if( preset &amp;&amp; !strcasecmp( preset, &quot;placebo&quot; ) )
        b_turbo = 0;
    //设置preset，tune
    if( x264_param_default_preset( param, preset, tune ) &lt; 0 )
        return -1;

    /* Parse command line options */
    //解析命令行选项
    for( optind = 0;; )
    {
        int b_error = 0;
        int long_options_index = -1;

        int c = getopt_long( argc, argv, short_options, long_options, &amp;long_options_index );

        if( c == -1 )
        {
            break;
        }
        //不同的选项做不同的处理
        switch( c )
        {
            case 'h':
                help( &amp;defaults, 0 );//&quot;-h&quot;帮助菜单
                exit(0);
            case OPT_LONGHELP:
                help( &amp;defaults, 1 );
                exit(0);
            case OPT_FULLHELP:
                help( &amp;defaults, 2 );
                exit(0);
            case 'V':
                print_version_info();//打印版本信息
                exit(0);
            case OPT_FRAMES:
                param-&gt;i_frame_total = X264_MAX( atoi( optarg ), 0 );
                break;
            case OPT_SEEK:
                opt-&gt;i_seek = X264_MAX( atoi( optarg ), 0 );
                break;
            case 'o':
                output_filename = optarg;//输出文件路径
                break;
            case OPT_MUXER:
                FAIL_IF_ERROR( parse_enum_name( optarg, muxer_names, &amp;muxer ), &quot;Unknown muxer `%s'\n&quot;, optarg )
                break;
            case OPT_DEMUXER:
                FAIL_IF_ERROR( parse_enum_name( optarg, demuxer_names, &amp;demuxer ), &quot;Unknown demuxer `%s'\n&quot;, optarg )
                break;
            case OPT_INDEX:
                input_opt.index_file = optarg;
                break;
            case OPT_QPFILE:
                opt-&gt;qpfile = x264_fopen( optarg, &quot;rb&quot; );
                FAIL_IF_ERROR( !opt-&gt;qpfile, &quot;can't open qpfile `%s'\n&quot;, optarg )
                if( !x264_is_regular_file( opt-&gt;qpfile ) )
                {
                    x264_cli_log( &quot;x264&quot;, X264_LOG_ERROR, &quot;qpfile incompatible with non-regular file `%s'\n&quot;, optarg );
                    fclose( opt-&gt;qpfile );
                    return -1;
                }
                break;
            case OPT_THREAD_INPUT:
                b_thread_input = 1;
                break;
            case OPT_QUIET:
                cli_log_level = param-&gt;i_log_level = X264_LOG_NONE;//设置log级别
                break;
            case 'v':
                cli_log_level = param-&gt;i_log_level = X264_LOG_DEBUG;//设置log级别
                break;
            case OPT_LOG_LEVEL:
                if( !parse_enum_value( optarg, log_level_names, &amp;cli_log_level ) )
                    cli_log_level += X264_LOG_NONE;
                else
                    cli_log_level = atoi( optarg );
                param-&gt;i_log_level = cli_log_level;//设置log级别
                break;
            case OPT_NOPROGRESS:
                opt-&gt;b_progress = 0;
                break;
            case OPT_TUNE:
            case OPT_PRESET:
                break;
            case OPT_PROFILE:
                profile = optarg;
                break;
            case OPT_SLOWFIRSTPASS:
                b_turbo = 0;
                break;
            case 'r':
                b_user_ref = 1;
                goto generic_option;
            case OPT_FPS:
                b_user_fps = 1;
                param-&gt;b_vfr_input = 0;
                goto generic_option;
            case OPT_INTERLACED:
                b_user_interlaced = 1;
                goto generic_option;
            case OPT_TCFILE_IN:
                tcfile_name = optarg;
                break;
            case OPT_TCFILE_OUT:
                opt-&gt;tcfile_out = x264_fopen( optarg, &quot;wb&quot; );
                FAIL_IF_ERROR( !opt-&gt;tcfile_out, &quot;can't open `%s'\n&quot;, optarg )
                break;
            case OPT_TIMEBASE:
                input_opt.timebase = optarg;
                break;
            case OPT_PULLDOWN:
                FAIL_IF_ERROR( parse_enum_value( optarg, pulldown_names, &amp;opt-&gt;i_pulldown ), &quot;Unknown pulldown `%s'\n&quot;, optarg )
                break;
            case OPT_VIDEO_FILTER:
                vid_filters = optarg;
                break;
            case OPT_INPUT_FMT:
                input_opt.format = optarg;//输入文件格式
                break;
            case OPT_INPUT_RES:
                input_opt.resolution = optarg;//输入分辨率
                break;
            case OPT_INPUT_CSP:
                input_opt.colorspace = optarg;//输入色域
                break;
            case OPT_INPUT_DEPTH:
                input_opt.bit_depth = atoi( optarg );//输入颜色位深
                break;
            case OPT_DTS_COMPRESSION:
                output_opt.use_dts_compress = 1;
                break;
            case OPT_OUTPUT_CSP:
                FAIL_IF_ERROR( parse_enum_value( optarg, output_csp_names, &amp;output_csp ), &quot;Unknown output csp `%s'\n&quot;, optarg )
                // correct the parsed value to the libx264 csp value
#if X264_CHROMA_FORMAT
                static const uint8_t output_csp_fix[] = { X264_CHROMA_FORMAT, X264_CSP_RGB };
#else
                static const uint8_t output_csp_fix[] = { X264_CSP_I420, X264_CSP_I422, X264_CSP_I444, X264_CSP_RGB };
#endif
                param-&gt;i_csp = output_csp = output_csp_fix[output_csp];
                break;
            case OPT_INPUT_RANGE:
                FAIL_IF_ERROR( parse_enum_value( optarg, range_names, &amp;input_opt.input_range ), &quot;Unknown input range `%s'\n&quot;, optarg )
                input_opt.input_range += RANGE_AUTO;
                break;
            case OPT_RANGE:
                FAIL_IF_ERROR( parse_enum_value( optarg, range_names, ¶m-&gt;vui.b_fullrange ), &quot;Unknown range `%s'\n&quot;, optarg );
                input_opt.output_range = param-&gt;vui.b_fullrange += RANGE_AUTO;
                break;
            default:
generic_option:
            {
                if( long_options_index &lt; 0 )
                {
                    for( int i = 0; long_options[i].name; i++ )
                        if( long_options[i].val == c )
                        {
                            long_options_index = i;
                            break;
                        }
                    if( long_options_index &lt; 0 )
                    {
                        /* getopt_long already printed an error message */
                        return -1;
                    }
                }
                //解析以字符串方式输入的参数
                //即选项名称和选项值都是字符串
                b_error |= x264_param_parse( param, long_options[long_options_index].name, optarg );
            }
        }

        if( b_error )
        {
            const char *name = long_options_index &gt; 0 ? long_options[long_options_index].name : argv[optind-2];
            x264_cli_log( &quot;x264&quot;, X264_LOG_ERROR, &quot;invalid argument: %s = %s\n&quot;, name, optarg );
            return -1;
        }
    }

    /* If first pass mode is used, apply faster settings. */
    if( b_turbo )
        x264_param_apply_fastfirstpass( param );

    /* Apply profile restrictions. */
    //设置profile
    if( x264_param_apply_profile( param, profile ) &lt; 0 )
        return -1;

    /* Get the file name */
    FAIL_IF_ERROR( optind &gt; argc - 1 || !output_filename, &quot;No %s file. Run x264 --help for a list of options.\n&quot;,
                   optind &gt; argc - 1 ? &quot;input&quot; : &quot;output&quot; )
    //根据文件名的后缀确定输出的文件格式（raw H264，flv，mp4...）
    if( select_output( muxer, output_filename, param ) )
        return -1;
    FAIL_IF_ERROR( cli_output.open_file( output_filename, &amp;opt-&gt;hout, &amp;output_opt ), &quot;could not open output file `%s'\n&quot;, output_filename )
    //输入文件路径
    input_filename = argv[optind++];
    video_info_t info = {0};
    char demuxername[5];

    /* set info flags to be overwritten by demuxer as necessary. */
    //设置info结构体
    info.csp        = param-&gt;i_csp;
    info.fps_num    = param-&gt;i_fps_num;
    info.fps_den    = param-&gt;i_fps_den;
    info.fullrange  = input_opt.input_range == RANGE_PC;
    info.interlaced = param-&gt;b_interlaced;
    if( param-&gt;vui.i_sar_width &gt; 0 &amp;&amp; param-&gt;vui.i_sar_height &gt; 0 )
    {
        info.sar_width  = param-&gt;vui.i_sar_width;
        info.sar_height = param-&gt;vui.i_sar_height;
    }
    info.tff        = param-&gt;b_tff;
    info.vfr        = param-&gt;b_vfr_input;

    input_opt.seek = opt-&gt;i_seek;
    input_opt.progress = opt-&gt;b_progress;
    input_opt.output_csp = output_csp;
    //设置输入文件的格式（yuv，y4m...）
    if( select_input( demuxer, demuxername, input_filename, &amp;opt-&gt;hin, &amp;info, &amp;input_opt ) )
        return -1;

    FAIL_IF_ERROR( !opt-&gt;hin &amp;&amp; cli_input.open_file( input_filename, &amp;opt-&gt;hin, &amp;info, &amp;input_opt ),
                   &quot;could not open input file `%s'\n&quot;, input_filename )

    x264_reduce_fraction( &amp;info.sar_width, &amp;info.sar_height );
    x264_reduce_fraction( &amp;info.fps_num, &amp;info.fps_den );
    x264_cli_log( demuxername, X264_LOG_INFO, &quot;%dx%d%c %u:%u @ %u/%u fps (%cfr)\n&quot;, info.width,
                  info.height, info.interlaced ? 'i' : 'p', info.sar_width, info.sar_height,
                  info.fps_num, info.fps_den, info.vfr ? 'v' : 'c' );

    if( tcfile_name )
    {
        FAIL_IF_ERROR( b_user_fps, &quot;--fps + --tcfile-in is incompatible.\n&quot; )
        FAIL_IF_ERROR( timecode_input.open_file( tcfile_name, &amp;opt-&gt;hin, &amp;info, &amp;input_opt ), &quot;timecode input failed\n&quot; )
        cli_input = timecode_input;
    }
    else FAIL_IF_ERROR( !info.vfr &amp;&amp; input_opt.timebase, &quot;--timebase is incompatible with cfr input\n&quot; )

    /* init threaded input while the information about the input video is unaltered by filtering */
#if HAVE_THREAD
    if( info.thread_safe &amp;&amp; (b_thread_input || param-&gt;i_threads &gt; 1
        || (param-&gt;i_threads == X264_THREADS_AUTO &amp;&amp; x264_cpu_num_processors() &gt; 1)) )
    {
        if( thread_input.open_file( NULL, &amp;opt-&gt;hin, &amp;info, NULL ) )
        {
            fprintf( stderr, &quot;x264 [error]: threaded input failed\n&quot; );
            return -1;
        }
        cli_input = thread_input;
    }
#endif

    /* override detected values by those specified by the user */
    if( param-&gt;vui.i_sar_width &gt; 0 &amp;&amp; param-&gt;vui.i_sar_height &gt; 0 )
    {
        info.sar_width  = param-&gt;vui.i_sar_width;
        info.sar_height = param-&gt;vui.i_sar_height;
    }
    if( b_user_fps )
    {
        info.fps_num = param-&gt;i_fps_num;
        info.fps_den = param-&gt;i_fps_den;
    }
    if( !info.vfr )
    {
        info.timebase_num = info.fps_den;
        info.timebase_den = info.fps_num;
    }
    if( !tcfile_name &amp;&amp; input_opt.timebase )
    {
        uint64_t i_user_timebase_num;
        uint64_t i_user_timebase_den;
        int ret = sscanf( input_opt.timebase, &quot;%&quot;SCNu64&quot;/%&quot;SCNu64, &amp;i_user_timebase_num, &amp;i_user_timebase_den );
        FAIL_IF_ERROR( !ret, &quot;invalid argument: timebase = %s\n&quot;, input_opt.timebase )
        else if( ret == 1 )
        {
            i_user_timebase_num = info.timebase_num;
            i_user_timebase_den = strtoul( input_opt.timebase, NULL, 10 );
        }
        FAIL_IF_ERROR( i_user_timebase_num &gt; UINT32_MAX || i_user_timebase_den &gt; UINT32_MAX,
                       &quot;timebase you specified exceeds H.264 maximum\n&quot; )
        opt-&gt;timebase_convert_multiplier = ((double)i_user_timebase_den / info.timebase_den)
                                         * ((double)info.timebase_num / i_user_timebase_num);
        info.timebase_num = i_user_timebase_num;
        info.timebase_den = i_user_timebase_den;
        info.vfr = 1;
    }
    if( b_user_interlaced )
    {
        info.interlaced = param-&gt;b_interlaced;
        info.tff = param-&gt;b_tff;
    }
    if( input_opt.input_range != RANGE_AUTO )
        info.fullrange = input_opt.input_range;

    //初始化滤镜filter
    //filter可以认为是一种“扩展”了的输入源
    if( init_vid_filters( vid_filters, &amp;opt-&gt;hin, &amp;info, param, output_csp ) )
        return -1;

    /* set param flags from the post-filtered video */
    param-&gt;b_vfr_input = info.vfr;
    param-&gt;i_fps_num = info.fps_num;
    param-&gt;i_fps_den = info.fps_den;
    param-&gt;i_timebase_num = info.timebase_num;
    param-&gt;i_timebase_den = info.timebase_den;
    param-&gt;vui.i_sar_width  = info.sar_width;
    param-&gt;vui.i_sar_height = info.sar_height;

    info.num_frames = X264_MAX( info.num_frames - opt-&gt;i_seek, 0 );
    if( (!info.num_frames || param-&gt;i_frame_total &lt; info.num_frames)
        &amp;&amp; param-&gt;i_frame_total &gt; 0 )
        info.num_frames = param-&gt;i_frame_total;
    param-&gt;i_frame_total = info.num_frames;

    if( !b_user_interlaced &amp;&amp; info.interlaced )
    {
#if HAVE_INTERLACED
        x264_cli_log( &quot;x264&quot;, X264_LOG_WARNING, &quot;input appears to be interlaced, enabling %cff interlaced mode.\n&quot;
                      &quot;                If you want otherwise, use --no-interlaced or --%cff\n&quot;,
                      info.tff ? 't' : 'b', info.tff ? 'b' : 't' );
        param-&gt;b_interlaced = 1;
        param-&gt;b_tff = !!info.tff;
#else
        x264_cli_log( &quot;x264&quot;, X264_LOG_WARNING, &quot;input appears to be interlaced, but not compiled with interlaced support\n&quot; );
#endif
    }
    /* if the user never specified the output range and the input is now rgb, default it to pc */
    int csp = param-&gt;i_csp &amp; X264_CSP_MASK;
    if( csp &gt;= X264_CSP_BGR &amp;&amp; csp &lt;= X264_CSP_RGB )
    {
        if( input_opt.output_range == RANGE_AUTO )
            param-&gt;vui.b_fullrange = RANGE_PC;
        /* otherwise fail if they specified tv */
        FAIL_IF_ERROR( !param-&gt;vui.b_fullrange, &quot;RGB must be PC range&quot; )
    }

    /* Automatically reduce reference frame count to match the user's target level
     * if the user didn't explicitly set a reference frame count. */
    if( !b_user_ref )
    {
        int mbs = (((param-&gt;i_width)+15)&gt;&gt;4) * (((param-&gt;i_height)+15)&gt;&gt;4);
        for( int i = 0; x264_levels[i].level_idc != 0; i++ )
            if( param-&gt;i_level_idc == x264_levels[i].level_idc )
            {
                while( mbs * param-&gt;i_frame_reference &gt; x264_levels[i].dpb &amp;&amp; param-&gt;i_frame_reference &gt; 1 )
                    param-&gt;i_frame_reference--;
                break;
            }
    }


    return 0;
}
</pre><br />下面简单梳理parse()的流程：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用x264_param_default()为存储参数的结构体x264_param_t赋默认值<br />（2）调用x264_param_default_preset()为x264_param_t赋值<br />（3）在一个大循环中调用getopt_long()逐个解析输入的参数，并作相应的处理。举几个例子：<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)“-h”：调用help()打开帮助菜单。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)“-V”调用print_version_info()打印版本信息。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)对于长选项，调用x264_param_parse()进行处理。</blockquote>（4）调用select_input()解析输出文件格式（例如raw，flv，MP4…）<br />（5）调用select_output()解析输入文件格式（例如yuv，y4m…）</blockquote><p>下文按照顺序记录parse()中涉及到的函数：</p><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">x264_param_default()<br />x264_param_default_preset()<br />help()<br />print_version_info()<br />x264_param_parse()<br />select_input()<br />select_output()</blockquote><br /><h3>x264_param_default()</h3>x264_param_default()是一个x264的API。该函数用于设置x264中x264_param_t结构体的默认值。函数的声明如下所示。<br /><pre name="code" class="cpp">/* x264_param_default:
 *      fill x264_param_t with default values and do CPU detection */
void    x264_param_default( x264_param_t * );</pre>x264_param_default()的定义如下所示。<br /><pre name="code" class="cpp">/****************************************************************************
 * x264_param_default:
 ****************************************************************************/
//初始化参数默认值
void x264_param_default( x264_param_t *param )
{
    /* */
    memset( param, 0, sizeof( x264_param_t ) );

    /* CPU autodetect */
    param-&gt;cpu = x264_cpu_detect();
    param-&gt;i_threads = X264_THREADS_AUTO;
    param-&gt;i_lookahead_threads = X264_THREADS_AUTO;
    param-&gt;b_deterministic = 1;
    param-&gt;i_sync_lookahead = X264_SYNC_LOOKAHEAD_AUTO;

    /* Video properties */
    param-&gt;i_csp           = X264_CHROMA_FORMAT ? X264_CHROMA_FORMAT : X264_CSP_I420;
    param-&gt;i_width         = 0;
    param-&gt;i_height        = 0;
    param-&gt;vui.i_sar_width = 0;
    param-&gt;vui.i_sar_height= 0;
    param-&gt;vui.i_overscan  = 0;  /* undef */
    param-&gt;vui.i_vidformat = 5;  /* undef */
    param-&gt;vui.b_fullrange = -1; /* default depends on input */
    param-&gt;vui.i_colorprim = 2;  /* undef */
    param-&gt;vui.i_transfer  = 2;  /* undef */
    param-&gt;vui.i_colmatrix = -1; /* default depends on input */
    param-&gt;vui.i_chroma_loc= 0;  /* left center */
    param-&gt;i_fps_num       = 25;
    param-&gt;i_fps_den       = 1;
    param-&gt;i_level_idc     = -1;
    param-&gt;i_slice_max_size = 0;
    param-&gt;i_slice_max_mbs = 0;
    param-&gt;i_slice_count = 0;

    /* Encoder parameters */
    //编码参数--最常见
    param-&gt;i_frame_reference = 3;
    param-&gt;i_keyint_max = 250;
    param-&gt;i_keyint_min = X264_KEYINT_MIN_AUTO;
    param-&gt;i_bframe = 3;
    param-&gt;i_scenecut_threshold = 40;
    param-&gt;i_bframe_adaptive = X264_B_ADAPT_FAST;
    param-&gt;i_bframe_bias = 0;
    param-&gt;i_bframe_pyramid = X264_B_PYRAMID_NORMAL;
    param-&gt;b_interlaced = 0;
    param-&gt;b_constrained_intra = 0;

    param-&gt;b_deblocking_filter = 1;
    param-&gt;i_deblocking_filter_alphac0 = 0;
    param-&gt;i_deblocking_filter_beta = 0;

    param-&gt;b_cabac = 1;
    param-&gt;i_cabac_init_idc = 0;
    //码率控制模块 Rate Control
    param-&gt;rc.i_rc_method = X264_RC_CRF;
    param-&gt;rc.i_bitrate = 0;
    param-&gt;rc.f_rate_tolerance = 1.0;
    param-&gt;rc.i_vbv_max_bitrate = 0;
    param-&gt;rc.i_vbv_buffer_size = 0;
    param-&gt;rc.f_vbv_buffer_init = 0.9;
    param-&gt;rc.i_qp_constant = 23 + QP_BD_OFFSET;
    param-&gt;rc.f_rf_constant = 23;
    param-&gt;rc.i_qp_min = 0;
    param-&gt;rc.i_qp_max = QP_MAX;
    param-&gt;rc.i_qp_step = 4;
    param-&gt;rc.f_ip_factor = 1.4;
    param-&gt;rc.f_pb_factor = 1.3;
    param-&gt;rc.i_aq_mode = X264_AQ_VARIANCE;
    param-&gt;rc.f_aq_strength = 1.0;
    param-&gt;rc.i_lookahead = 40;

    param-&gt;rc.b_stat_write = 0;
    param-&gt;rc.psz_stat_out = &quot;x264_2pass.log&quot;;
    param-&gt;rc.b_stat_read = 0;
    param-&gt;rc.psz_stat_in = &quot;x264_2pass.log&quot;;
    param-&gt;rc.f_qcompress = 0.6;
    param-&gt;rc.f_qblur = 0.5;
    param-&gt;rc.f_complexity_blur = 20;
    param-&gt;rc.i_zones = 0;
    param-&gt;rc.b_mb_tree = 1;

    /* Log */
    //日志模块
    param-&gt;pf_log = x264_log_default;
    param-&gt;p_log_private = NULL;
    param-&gt;i_log_level = X264_LOG_INFO;

    /* */
    //分析模块 Analysis
    param-&gt;analyse.intra = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8;
    param-&gt;analyse.inter = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8
                         | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_BSUB16x16;
    param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_SPATIAL;
    param-&gt;analyse.i_me_method = X264_ME_HEX;
    param-&gt;analyse.f_psy_rd = 1.0;
    param-&gt;analyse.b_psy = 1;
    param-&gt;analyse.f_psy_trellis = 0;
    param-&gt;analyse.i_me_range = 16;
    param-&gt;analyse.i_subpel_refine = 7;
    param-&gt;analyse.b_mixed_references = 1;
    param-&gt;analyse.b_chroma_me = 1;
    param-&gt;analyse.i_mv_range_thread = -1;
    param-&gt;analyse.i_mv_range = -1; // set from level_idc
    param-&gt;analyse.i_chroma_qp_offset = 0;
    param-&gt;analyse.b_fast_pskip = 1;
    param-&gt;analyse.b_weighted_bipred = 1;
    param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SMART;
    param-&gt;analyse.b_dct_decimate = 1;
    param-&gt;analyse.b_transform_8x8 = 1;
    param-&gt;analyse.i_trellis = 1;
    param-&gt;analyse.i_luma_deadzone[0] = 21;
    param-&gt;analyse.i_luma_deadzone[1] = 11;
    param-&gt;analyse.b_psnr = 0;
    param-&gt;analyse.b_ssim = 0;

    param-&gt;i_cqm_preset = X264_CQM_FLAT;
    memset( param-&gt;cqm_4iy, 16, sizeof( param-&gt;cqm_4iy ) );
    memset( param-&gt;cqm_4py, 16, sizeof( param-&gt;cqm_4py ) );
    memset( param-&gt;cqm_4ic, 16, sizeof( param-&gt;cqm_4ic ) );
    memset( param-&gt;cqm_4pc, 16, sizeof( param-&gt;cqm_4pc ) );
    memset( param-&gt;cqm_8iy, 16, sizeof( param-&gt;cqm_8iy ) );
    memset( param-&gt;cqm_8py, 16, sizeof( param-&gt;cqm_8py ) );
    memset( param-&gt;cqm_8ic, 16, sizeof( param-&gt;cqm_8ic ) );
    memset( param-&gt;cqm_8pc, 16, sizeof( param-&gt;cqm_8pc ) );

    param-&gt;b_repeat_headers = 1;
    param-&gt;b_annexb = 1;
    param-&gt;b_aud = 0;
    param-&gt;b_vfr_input = 1;
    param-&gt;i_nal_hrd = X264_NAL_HRD_NONE;
    param-&gt;b_tff = 1;
    param-&gt;b_pic_struct = 0;
    param-&gt;b_fake_interlaced = 0;
    param-&gt;i_frame_packing = -1;
    param-&gt;b_opencl = 0;
    param-&gt;i_opencl_device = 0;
    param-&gt;opencl_device_id = NULL;
    param-&gt;psz_clbin_file = NULL;
}
</pre><br />从源代码可以看出，x264_param_default()对输入的存储参数的结构体x264_param_t的成员变量进行了赋值工作。<br /><br /><h3>x264_param_default_preset()</h3>x264_param_default_preset()是一个libx264的API，用于设置x264的preset和tune。该函数的声明如下所示。<br /><pre name="code" class="cpp">/*      Multiple tunings can be used if separated by a delimiter in &quot;,./-+&quot;,
 *      however multiple psy tunings cannot be used.
 *      film, animation, grain, stillimage, psnr, and ssim are psy tunings.
 *
 *      returns 0 on success, negative on failure (e.g. invalid preset/tune name). */
int     x264_param_default_preset( x264_param_t *, const char *preset, const char *tune );</pre>x264_param_default_preset()的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_6_9167640" name="code" class="cpp">//设置preset，tune
int x264_param_default_preset( x264_param_t *param, const char *preset, const char *tune )
{
    x264_param_default( param );

    //设置preset
    if( preset &amp;&amp; x264_param_apply_preset( param, preset ) &lt; 0 )
        return -1;

    //设置tune
    if( tune &amp;&amp; x264_param_apply_tune( param, tune ) &lt; 0 )
        return -1;
    return 0;
}
</pre><br />从源代码可以看出，x264_param_default_preset()调用x264_param_apply_preset()设置preset，调用x264_param_apply_tune()设置tune。记录一下这两个函数。<br /><br /><strong>x264_param_apply_preset()</strong><br />x264_param_apply_preset()用于设置preset。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_7_8356700" name="code" class="cpp">//设置preset
static int x264_param_apply_preset( x264_param_t *param, const char *preset )
{
    char *end;
    int i = strtol( preset, &amp;end, 10 );
    if( *end == 0 &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; sizeof(x264_preset_names)/sizeof(*x264_preset_names)-1 )
        preset = x264_preset_names[i];

    //几种不同的preset设置不同的参数
    if( !strcasecmp( preset, &quot;ultrafast&quot; ) )
    {
        param-&gt;i_frame_reference = 1;
        param-&gt;i_scenecut_threshold = 0;
        param-&gt;b_deblocking_filter = 0;//不使用去块滤波
        param-&gt;b_cabac = 0;//不使用CABAC
        param-&gt;i_bframe = 0;//不使用B帧
        param-&gt;analyse.intra = 0;
        param-&gt;analyse.inter = 0;
        param-&gt;analyse.b_transform_8x8 = 0;//不使用8x8DCT
        param-&gt;analyse.i_me_method = X264_ME_DIA;//运动搜索方法使用“Diamond”
        param-&gt;analyse.i_subpel_refine = 0;
        param-&gt;rc.i_aq_mode = 0;
        param-&gt;analyse.b_mixed_references = 0;
        param-&gt;analyse.i_trellis = 0;
        param-&gt;i_bframe_adaptive = X264_B_ADAPT_NONE;
        param-&gt;rc.b_mb_tree = 0;
        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_NONE;//不使用加权
        param-&gt;analyse.b_weighted_bipred = 0;
        param-&gt;rc.i_lookahead = 0;
    }
    else if( !strcasecmp( preset, &quot;superfast&quot; ) )
    {
        param-&gt;analyse.inter = X264_ANALYSE_I8x8|X264_ANALYSE_I4x4;
        param-&gt;analyse.i_me_method = X264_ME_DIA;//钻石模板
        param-&gt;analyse.i_subpel_refine = 1;//亚像素运动估计质量为1
        param-&gt;i_frame_reference = 1;
        param-&gt;analyse.b_mixed_references = 0;
        param-&gt;analyse.i_trellis = 0;
        param-&gt;rc.b_mb_tree = 0;
        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;
        param-&gt;rc.i_lookahead = 0;
    }
    else if( !strcasecmp( preset, &quot;veryfast&quot; ) )
    {
        param-&gt;analyse.i_me_method = X264_ME_HEX;//六边形模板
        param-&gt;analyse.i_subpel_refine = 2;
        param-&gt;i_frame_reference = 1;
        param-&gt;analyse.b_mixed_references = 0;
        param-&gt;analyse.i_trellis = 0;
        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;
        param-&gt;rc.i_lookahead = 10;
    }
    else if( !strcasecmp( preset, &quot;faster&quot; ) )
    {
        param-&gt;analyse.b_mixed_references = 0;
        param-&gt;i_frame_reference = 2;
        param-&gt;analyse.i_subpel_refine = 4;
        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;
        param-&gt;rc.i_lookahead = 20;
    }
    else if( !strcasecmp( preset, &quot;fast&quot; ) )
    {
        param-&gt;i_frame_reference = 2;
        param-&gt;analyse.i_subpel_refine = 6;
        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;
        param-&gt;rc.i_lookahead = 30;
    }
    else if( !strcasecmp( preset, &quot;medium&quot; ) )
    {
        /* Default is medium */
    }
    else if( !strcasecmp( preset, &quot;slow&quot; ) )
    {
        param-&gt;analyse.i_me_method = X264_ME_UMH;//UMH相对复杂
        param-&gt;analyse.i_subpel_refine = 8;//亚像素运动估计质量为8
        param-&gt;i_frame_reference = 5;
        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;
        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;
        param-&gt;rc.i_lookahead = 50;
    }
    else if( !strcasecmp( preset, &quot;slower&quot; ) )
    {
        param-&gt;analyse.i_me_method = X264_ME_UMH;
        param-&gt;analyse.i_subpel_refine = 9;
        param-&gt;i_frame_reference = 8;
        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;
        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;
        param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;
        param-&gt;analyse.i_trellis = 2;
        param-&gt;rc.i_lookahead = 60;
    }
    else if( !strcasecmp( preset, &quot;veryslow&quot; ) )
    {
        param-&gt;analyse.i_me_method = X264_ME_UMH;
        param-&gt;analyse.i_subpel_refine = 10;
        param-&gt;analyse.i_me_range = 24;
        param-&gt;i_frame_reference = 16;
        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;
        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;
        param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;
        param-&gt;analyse.i_trellis = 2;
        param-&gt;i_bframe = 8;
        param-&gt;rc.i_lookahead = 60;
    }
    else if( !strcasecmp( preset, &quot;placebo&quot; ) )
    {
        param-&gt;analyse.i_me_method = X264_ME_TESA;//TESA很慢
        param-&gt;analyse.i_subpel_refine = 11;
        param-&gt;analyse.i_me_range = 24;
        param-&gt;i_frame_reference = 16;
        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;
        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;
        param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;
        param-&gt;analyse.b_fast_pskip = 0;
        param-&gt;analyse.i_trellis = 2;
        param-&gt;i_bframe = 16;
        param-&gt;rc.i_lookahead = 60;
    }
    else
    {
        x264_log( NULL, X264_LOG_ERROR, &quot;invalid preset '%s'\n&quot;, preset );
        return -1;
    }
    return 0;
}
</pre><br />可以看出x264_param_apply_preset()通过strcasecmp()比较字符串的方法得到输入的preset类型；然后根据preset类型，设定 x264_param_t中相应的参数。<br /><br /><strong>x264_param_apply_tune()</strong><br />x264_param_apply_tune()用于设置tune。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_8_6291241" name="code" class="cpp">//设置tune
static int x264_param_apply_tune( x264_param_t *param, const char *tune )
{
    char *tmp = x264_malloc( strlen( tune ) + 1 );
    if( !tmp )
        return -1;
    tmp = strcpy( tmp, tune );
    //分解一个字符串为一个字符串数组。第2个参数为分隔符
    char *s = strtok( tmp, &quot;,./-+&quot; );
    int psy_tuning_used = 0;

    //设置
    //这里是循环的，可以设置多次
    while( s )
    {
        if( !strncasecmp( s, &quot;film&quot;, 4 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;i_deblocking_filter_alphac0 = -1;
            param-&gt;i_deblocking_filter_beta = -1;
            param-&gt;analyse.f_psy_trellis = 0.15;
        }
        else if( !strncasecmp( s, &quot;animation&quot;, 9 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;i_frame_reference = param-&gt;i_frame_reference &gt; 1 ? param-&gt;i_frame_reference*2 : 1;
            param-&gt;i_deblocking_filter_alphac0 = 1;
            param-&gt;i_deblocking_filter_beta = 1;
            param-&gt;analyse.f_psy_rd = 0.4;
            param-&gt;rc.f_aq_strength = 0.6;
            param-&gt;i_bframe += 2;
        }
        else if( !strncasecmp( s, &quot;grain&quot;, 5 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;i_deblocking_filter_alphac0 = -2;
            param-&gt;i_deblocking_filter_beta = -2;
            param-&gt;analyse.f_psy_trellis = 0.25;
            param-&gt;analyse.b_dct_decimate = 0;
            param-&gt;rc.f_pb_factor = 1.1;
            param-&gt;rc.f_ip_factor = 1.1;
            param-&gt;rc.f_aq_strength = 0.5;
            param-&gt;analyse.i_luma_deadzone[0] = 6;
            param-&gt;analyse.i_luma_deadzone[1] = 6;
            param-&gt;rc.f_qcompress = 0.8;
        }
        else if( !strncasecmp( s, &quot;stillimage&quot;, 10 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;i_deblocking_filter_alphac0 = -3;
            param-&gt;i_deblocking_filter_beta = -3;
            param-&gt;analyse.f_psy_rd = 2.0;
            param-&gt;analyse.f_psy_trellis = 0.7;
            param-&gt;rc.f_aq_strength = 1.2;
        }
        else if( !strncasecmp( s, &quot;psnr&quot;, 4 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;rc.i_aq_mode = X264_AQ_NONE;
            param-&gt;analyse.b_psy = 0;
        }
        else if( !strncasecmp( s, &quot;ssim&quot;, 4 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;rc.i_aq_mode = X264_AQ_AUTOVARIANCE;
            param-&gt;analyse.b_psy = 0;
        }
        else if( !strncasecmp( s, &quot;fastdecode&quot;, 10 ) )
        {
            param-&gt;b_deblocking_filter = 0;
            param-&gt;b_cabac = 0;
            param-&gt;analyse.b_weighted_bipred = 0;
            param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_NONE;
        }
        else if( !strncasecmp( s, &quot;zerolatency&quot;, 11 ) )
        {
        	//zerolatency速度快
            param-&gt;rc.i_lookahead = 0;
            param-&gt;i_sync_lookahead = 0;
            param-&gt;i_bframe = 0;//不使用B帧
            param-&gt;b_sliced_threads = 1;
            param-&gt;b_vfr_input = 0;
            param-&gt;rc.b_mb_tree = 0;
        }
        else if( !strncasecmp( s, &quot;touhou&quot;, 6 ) )
        {
            if( psy_tuning_used++ ) goto psy_failure;
            param-&gt;i_frame_reference = param-&gt;i_frame_reference &gt; 1 ? param-&gt;i_frame_reference*2 : 1;
            param-&gt;i_deblocking_filter_alphac0 = -1;
            param-&gt;i_deblocking_filter_beta = -1;
            param-&gt;analyse.f_psy_trellis = 0.2;
            param-&gt;rc.f_aq_strength = 1.3;
            if( param-&gt;analyse.inter &amp; X264_ANALYSE_PSUB16x16 )
                param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;
        }
        else
        {
            x264_log( NULL, X264_LOG_ERROR, &quot;invalid tune '%s'\n&quot;, s );
            x264_free( tmp );
            return -1;
        }
        if( 0 )
        {
    psy_failure:
            x264_log( NULL, X264_LOG_WARNING, &quot;only 1 psy tuning can be used: ignoring tune %s\n&quot;, s );
        }
        s = strtok( NULL, &quot;,./-+&quot; );
    }
    x264_free( tmp );
    return 0;
}
</pre><br />可以看出x264_param_apply_tune()首先通过strtok()得到存储tune[]数组；然后通过strncasecmp()比较字符串的方法判断当前的tune类型；最后根据tune类型，设定 x264_param_t中相应的参数。<br /><br /><h3>help()</h3>help()用于打印帮助菜单。在x264命令行程序中添加“-h”参数后会调用该函数。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_9_5022952" name="code" class="cpp">//帮助菜单
//longhelp标识是否展开更长的帮助菜单
static void help( x264_param_t *defaults, int longhelp )
{
    char buf[50];
    //H0(),H1(),H2()都是printf()
    //H1(),H2()只有“长帮助菜单”的情况下才会调用printf()
#define H0 printf
#define H1 if(longhelp&gt;=1) printf
#define H2 if(longhelp==2) printf
    H0( &quot;x264 core:%d%s\n&quot;
        &quot;Syntax: x264 [options] -o outfile infile\n&quot;
        &quot;\n&quot;
        &quot;Infile can be raw (in which case resolution is required),\n&quot;
        &quot;  or YUV4MPEG (*.y4m),\n&quot;
        &quot;  or Avisynth if compiled with support (%s).\n&quot;
        &quot;  or libav* formats if compiled with lavf support (%s) or ffms support (%s).\n&quot;
        &quot;Outfile type is selected by filename:\n&quot;
        &quot; .264 -&gt; Raw bytestream\n&quot;
        &quot; .mkv -&gt; Matroska\n&quot;
        &quot; .flv -&gt; Flash Video\n&quot;
        &quot; .mp4 -&gt; MP4 if compiled with GPAC or L-SMASH support (%s)\n&quot;
        &quot;Output bit depth: %d (configured at compile time)\n&quot;
        &quot;\n&quot;
        &quot;Options:\n&quot;
        &quot;\n&quot;
        &quot;  -h, --help                  List basic options\n&quot;
        &quot;      --longhelp              List more options\n&quot;
        &quot;      --fullhelp              List all options\n&quot;
        &quot;\n&quot;,
        X264_BUILD, X264_VERSION,
#if HAVE_AVS
        &quot;yes&quot;,
#else
        &quot;no&quot;,
#endif
#if HAVE_LAVF
        &quot;yes&quot;,
#else
        &quot;no&quot;,
#endif
#if HAVE_FFMS
        &quot;yes&quot;,
#else
        &quot;no&quot;,
#endif
#if HAVE_GPAC
        &quot;gpac&quot;,
#elif HAVE_LSMASH
        &quot;lsmash&quot;,
#else
        &quot;no&quot;,
#endif
        x264_bit_depth
      );
    H0( &quot;Example usage:\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Constant quality mode:\n&quot; );
    H0( &quot;            x264 --crf 24 -o &lt;output&gt; &lt;input&gt;\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Two-pass with a bitrate of 1000kbps:\n&quot; );
    H0( &quot;            x264 --pass 1 --bitrate 1000 -o &lt;output&gt; &lt;input&gt;\n&quot; );
    H0( &quot;            x264 --pass 2 --bitrate 1000 -o &lt;output&gt; &lt;input&gt;\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Lossless:\n&quot; );
    H0( &quot;            x264 --qp 0 -o &lt;output&gt; &lt;input&gt;\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Maximum PSNR at the cost of speed and visual quality:\n&quot; );
    H0( &quot;            x264 --preset placebo --tune psnr -o &lt;output&gt; &lt;input&gt;\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Constant bitrate at 1000kbps with a 2 second-buffer:\n&quot;);
    H0( &quot;            x264 --vbv-bufsize 2000 --bitrate 1000 -o &lt;output&gt; &lt;input&gt;\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;Presets:\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      --profile &lt;string&gt;      Force the limits of an H.264 profile\n&quot;
        &quot;                                  Overrides all settings.\n&quot; );
    H2(
#if X264_CHROMA_FORMAT &lt;= X264_CSP_I420
#if BIT_DEPTH==8
        &quot;                                  - baseline:\n&quot;
        &quot;                                    --no-8x8dct --bframes 0 --no-cabac\n&quot;
        &quot;                                    --cqm flat --weightp 0\n&quot;
        &quot;                                    No interlaced.\n&quot;
        &quot;                                    No lossless.\n&quot;
        &quot;                                  - main:\n&quot;
        &quot;                                    --no-8x8dct --cqm flat\n&quot;
        &quot;                                    No lossless.\n&quot;
        &quot;                                  - high:\n&quot;
        &quot;                                    No lossless.\n&quot;
#endif
        &quot;                                  - high10:\n&quot;
        &quot;                                    No lossless.\n&quot;
        &quot;                                    Support for bit depth 8-10.\n&quot;
#endif
#if X264_CHROMA_FORMAT &lt;= X264_CSP_I422
        &quot;                                  - high422:\n&quot;
        &quot;                                    No lossless.\n&quot;
        &quot;                                    Support for bit depth 8-10.\n&quot;
        &quot;                                    Support for 4:2:0/4:2:2 chroma subsampling.\n&quot;
#endif
        &quot;                                  - high444:\n&quot;
        &quot;                                    Support for bit depth 8-10.\n&quot;
        &quot;                                    Support for 4:2:0/4:2:2/4:4:4 chroma subsampling.\n&quot; );
        else H0(
        &quot;                                  - &quot;
#if X264_CHROMA_FORMAT &lt;= X264_CSP_I420
#if BIT_DEPTH==8
        &quot;baseline,main,high,&quot;
#endif
        &quot;high10,&quot;
#endif
#if X264_CHROMA_FORMAT &lt;= X264_CSP_I422
        &quot;high422,&quot;
#endif
        &quot;high444\n&quot;
               );
    H0( &quot;      --preset &lt;string&gt;       Use a preset to select encoding settings [medium]\n&quot;
        &quot;                                  Overridden by user settings.\n&quot; );
    H2( &quot;                                  - ultrafast:\n&quot;
        &quot;                                    --no-8x8dct --aq-mode 0 --b-adapt 0\n&quot;
        &quot;                                    --bframes 0 --no-cabac --no-deblock\n&quot;
        &quot;                                    --no-mbtree --me dia --no-mixed-refs\n&quot;
        &quot;                                    --partitions none --rc-lookahead 0 --ref 1\n&quot;
        &quot;                                    --scenecut 0 --subme 0 --trellis 0\n&quot;
        &quot;                                    --no-weightb --weightp 0\n&quot;
        &quot;                                  - superfast:\n&quot;
        &quot;                                    --no-mbtree --me dia --no-mixed-refs\n&quot;
        &quot;                                    --partitions i8x8,i4x4 --rc-lookahead 0\n&quot;
        &quot;                                    --ref 1 --subme 1 --trellis 0 --weightp 1\n&quot;
        &quot;                                  - veryfast:\n&quot;
        &quot;                                    --no-mixed-refs --rc-lookahead 10\n&quot;
        &quot;                                    --ref 1 --subme 2 --trellis 0 --weightp 1\n&quot;
        &quot;                                  - faster:\n&quot;
        &quot;                                    --no-mixed-refs --rc-lookahead 20\n&quot;
        &quot;                                    --ref 2 --subme 4 --weightp 1\n&quot;
        &quot;                                  - fast:\n&quot;
        &quot;                                    --rc-lookahead 30 --ref 2 --subme 6\n&quot;
        &quot;                                    --weightp 1\n&quot;
        &quot;                                  - medium:\n&quot;
        &quot;                                    Default settings apply.\n&quot;
        &quot;                                  - slow:\n&quot;
        &quot;                                    --b-adapt 2 --direct auto --me umh\n&quot;
        &quot;                                    --rc-lookahead 50 --ref 5 --subme 8\n&quot;
        &quot;                                  - slower:\n&quot;
        &quot;                                    --b-adapt 2 --direct auto --me umh\n&quot;
        &quot;                                    --partitions all --rc-lookahead 60\n&quot;
        &quot;                                    --ref 8 --subme 9 --trellis 2\n&quot;
        &quot;                                  - veryslow:\n&quot;
        &quot;                                    --b-adapt 2 --bframes 8 --direct auto\n&quot;
        &quot;                                    --me umh --merange 24 --partitions all\n&quot;
        &quot;                                    --ref 16 --subme 10 --trellis 2\n&quot;
        &quot;                                    --rc-lookahead 60\n&quot;
        &quot;                                  - placebo:\n&quot;
        &quot;                                    --bframes 16 --b-adapt 2 --direct auto\n&quot;
        &quot;                                    --slow-firstpass --no-fast-pskip\n&quot;
        &quot;                                    --me tesa --merange 24 --partitions all\n&quot;
        &quot;                                    --rc-lookahead 60 --ref 16 --subme 11\n&quot;
        &quot;                                    --trellis 2\n&quot; );
    else H0( &quot;                                  - ultrafast,superfast,veryfast,faster,fast\n&quot;
             &quot;                                  - medium,slow,slower,veryslow,placebo\n&quot; );
    H0( &quot;      --tune &lt;string&gt;         Tune the settings for a particular type of source\n&quot;
        &quot;                              or situation\n&quot;
        &quot;                                  Overridden by user settings.\n&quot;
        &quot;                                  Multiple tunings are separated by commas.\n&quot;
        &quot;                                  Only one psy tuning can be used at a time.\n&quot; );
    H2( &quot;                                  - film (psy tuning):\n&quot;
        &quot;                                    --deblock -1:-1 --psy-rd &lt;unset&gt;:0.15\n&quot;
        &quot;                                  - animation (psy tuning):\n&quot;
        &quot;                                    --bframes {+2} --deblock 1:1\n&quot;
        &quot;                                    --psy-rd 0.4:&lt;unset&gt; --aq-strength 0.6\n&quot;
        &quot;                                    --ref {Double if &gt;1 else 1}\n&quot;
        &quot;                                  - grain (psy tuning):\n&quot;
        &quot;                                    --aq-strength 0.5 --no-dct-decimate\n&quot;
        &quot;                                    --deadzone-inter 6 --deadzone-intra 6\n&quot;
        &quot;                                    --deblock -2:-2 --ipratio 1.1 \n&quot;
        &quot;                                    --pbratio 1.1 --psy-rd &lt;unset&gt;:0.25\n&quot;
        &quot;                                    --qcomp 0.8\n&quot;
        &quot;                                  - stillimage (psy tuning):\n&quot;
        &quot;                                    --aq-strength 1.2 --deblock -3:-3\n&quot;
        &quot;                                    --psy-rd 2.0:0.7\n&quot;
        &quot;                                  - psnr (psy tuning):\n&quot;
        &quot;                                    --aq-mode 0 --no-psy\n&quot;
        &quot;                                  - ssim (psy tuning):\n&quot;
        &quot;                                    --aq-mode 2 --no-psy\n&quot;
        &quot;                                  - fastdecode:\n&quot;
        &quot;                                    --no-cabac --no-deblock --no-weightb\n&quot;
        &quot;                                    --weightp 0\n&quot;
        &quot;                                  - zerolatency:\n&quot;
        &quot;                                    --bframes 0 --force-cfr --no-mbtree\n&quot;
        &quot;                                    --sync-lookahead 0 --sliced-threads\n&quot;
        &quot;                                    --rc-lookahead 0\n&quot; );
    else H0( &quot;                                  - psy tunings: film,animation,grain,\n&quot;
             &quot;                                                 stillimage,psnr,ssim\n&quot;
             &quot;                                  - other tunings: fastdecode,zerolatency\n&quot; );
    H2( &quot;      --slow-firstpass        Don't force these faster settings with --pass 1:\n&quot;
        &quot;                                  --no-8x8dct --me dia --partitions none\n&quot;
        &quot;                                  --ref 1 --subme {2 if &gt;2 else unchanged}\n&quot;
        &quot;                                  --trellis 0 --fast-pskip\n&quot; );
    else H1( &quot;      --slow-firstpass        Don't force faster settings with --pass 1\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;Frame-type options:\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;  -I, --keyint &lt;integer or \&quot;infinite\&quot;&gt; Maximum GOP size [%d]\n&quot;, defaults-&gt;i_keyint_max );
    H2( &quot;  -i, --min-keyint &lt;integer&gt;  Minimum GOP size [auto]\n&quot; );
    H2( &quot;      --no-scenecut           Disable adaptive I-frame decision\n&quot; );
    H2( &quot;      --scenecut &lt;integer&gt;    How aggressively to insert extra I-frames [%d]\n&quot;, defaults-&gt;i_scenecut_threshold );
    H2( &quot;      --intra-refresh         Use Periodic Intra Refresh instead of IDR frames\n&quot; );
    H1( &quot;  -b, --bframes &lt;integer&gt;     Number of B-frames between I and P [%d]\n&quot;, defaults-&gt;i_bframe );
    H1( &quot;      --b-adapt &lt;integer&gt;     Adaptive B-frame decision method [%d]\n&quot;
        &quot;                                  Higher values may lower threading efficiency.\n&quot;
        &quot;                                  - 0: Disabled\n&quot;
        &quot;                                  - 1: Fast\n&quot;
        &quot;                                  - 2: Optimal (slow with high --bframes)\n&quot;, defaults-&gt;i_bframe_adaptive );
    H2( &quot;      --b-bias &lt;integer&gt;      Influences how often B-frames are used [%d]\n&quot;, defaults-&gt;i_bframe_bias );
    H1( &quot;      --b-pyramid &lt;string&gt;    Keep some B-frames as references [%s]\n&quot;
        &quot;                                  - none: Disabled\n&quot;
        &quot;                                  - strict: Strictly hierarchical pyramid\n&quot;
        &quot;                                  - normal: Non-strict (not Blu-ray compatible)\n&quot;,
        strtable_lookup( x264_b_pyramid_names, defaults-&gt;i_bframe_pyramid ) );
    H1( &quot;      --open-gop              Use recovery points to close GOPs\n&quot;
        &quot;                              Only available with b-frames\n&quot; );
    H1( &quot;      --no-cabac              Disable CABAC\n&quot; );
    H1( &quot;  -r, --ref &lt;integer&gt;         Number of reference frames [%d]\n&quot;, defaults-&gt;i_frame_reference );
    H1( &quot;      --no-deblock            Disable loop filter\n&quot; );
    H1( &quot;  -f, --deblock &lt;alpha:beta&gt;  Loop filter parameters [%d:%d]\n&quot;,
                                       defaults-&gt;i_deblocking_filter_alphac0, defaults-&gt;i_deblocking_filter_beta );
    H2( &quot;      --slices &lt;integer&gt;      Number of slices per frame; forces rectangular\n&quot;
        &quot;                              slices and is overridden by other slicing options\n&quot; );
    else H1( &quot;      --slices &lt;integer&gt;      Number of slices per frame\n&quot; );
    H2( &quot;      --slices-max &lt;integer&gt;  Absolute maximum slices per frame; overrides\n&quot;
        &quot;                              slice-max-size/slice-max-mbs when necessary\n&quot; );
    H2( &quot;      --slice-max-size &lt;integer&gt; Limit the size of each slice in bytes\n&quot;);
    H2( &quot;      --slice-max-mbs &lt;integer&gt; Limit the size of each slice in macroblocks (max)\n&quot;);
    H2( &quot;      --slice-min-mbs &lt;integer&gt; Limit the size of each slice in macroblocks (min)\n&quot;);
    H0( &quot;      --tff                   Enable interlaced mode (top field first)\n&quot; );
    H0( &quot;      --bff                   Enable interlaced mode (bottom field first)\n&quot; );
    H2( &quot;      --constrained-intra     Enable constrained intra prediction.\n&quot; );
    H0( &quot;      --pulldown &lt;string&gt;     Use soft pulldown to change frame rate\n&quot;
        &quot;                                  - none, 22, 32, 64, double, triple, euro (requires cfr input)\n&quot; );
    H2( &quot;      --fake-interlaced       Flag stream as interlaced but encode progressive.\n&quot;
        &quot;                              Makes it possible to encode 25p and 30p Blu-Ray\n&quot;
        &quot;                              streams. Ignored in interlaced mode.\n&quot; );
    H2( &quot;      --frame-packing &lt;integer&gt; For stereoscopic videos define frame arrangement\n&quot;
        &quot;                                  - 0: checkerboard - pixels are alternatively from L and R\n&quot;
        &quot;                                  - 1: column alternation - L and R are interlaced by column\n&quot;
        &quot;                                  - 2: row alternation - L and R are interlaced by row\n&quot;
        &quot;                                  - 3: side by side - L is on the left, R on the right\n&quot;
        &quot;                                  - 4: top bottom - L is on top, R on bottom\n&quot;
        &quot;                                  - 5: frame alternation - one view per frame\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;Ratecontrol:\n&quot; );
    H0( &quot;\n&quot; );
    H1( &quot;  -q, --qp &lt;integer&gt;          Force constant QP (0-%d, 0=lossless)\n&quot;, QP_MAX );
    H0( &quot;  -B, --bitrate &lt;integer&gt;     Set bitrate (kbit/s)\n&quot; );
    H0( &quot;      --crf &lt;float&gt;           Quality-based VBR (%d-51) [%.1f]\n&quot;, 51 - QP_MAX_SPEC, defaults-&gt;rc.f_rf_constant );
    H1( &quot;      --rc-lookahead &lt;integer&gt; Number of frames for frametype lookahead [%d]\n&quot;, defaults-&gt;rc.i_lookahead );
    H0( &quot;      --vbv-maxrate &lt;integer&gt; Max local bitrate (kbit/s) [%d]\n&quot;, defaults-&gt;rc.i_vbv_max_bitrate );
    H0( &quot;      --vbv-bufsize &lt;integer&gt; Set size of the VBV buffer (kbit) [%d]\n&quot;, defaults-&gt;rc.i_vbv_buffer_size );
    H2( &quot;      --vbv-init &lt;float&gt;      Initial VBV buffer occupancy [%.1f]\n&quot;, defaults-&gt;rc.f_vbv_buffer_init );
    H2( &quot;      --crf-max &lt;float&gt;       With CRF+VBV, limit RF to this value\n&quot;
        &quot;                                  May cause VBV underflows!\n&quot; );
    H2( &quot;      --qpmin &lt;integer&gt;       Set min QP [%d]\n&quot;, defaults-&gt;rc.i_qp_min );
    H2( &quot;      --qpmax &lt;integer&gt;       Set max QP [%d]\n&quot;, defaults-&gt;rc.i_qp_max );
    H2( &quot;      --qpstep &lt;integer&gt;      Set max QP step [%d]\n&quot;, defaults-&gt;rc.i_qp_step );
    H2( &quot;      --ratetol &lt;float&gt;       Tolerance of ABR ratecontrol and VBV [%.1f]\n&quot;, defaults-&gt;rc.f_rate_tolerance );
    H2( &quot;      --ipratio &lt;float&gt;       QP factor between I and P [%.2f]\n&quot;, defaults-&gt;rc.f_ip_factor );
    H2( &quot;      --pbratio &lt;float&gt;       QP factor between P and B [%.2f]\n&quot;, defaults-&gt;rc.f_pb_factor );
    H2( &quot;      --chroma-qp-offset &lt;integer&gt;  QP difference between chroma and luma [%d]\n&quot;, defaults-&gt;analyse.i_chroma_qp_offset );
    H2( &quot;      --aq-mode &lt;integer&gt;     AQ method [%d]\n&quot;
        &quot;                                  - 0: Disabled\n&quot;
        &quot;                                  - 1: Variance AQ (complexity mask)\n&quot;
        &quot;                                  - 2: Auto-variance AQ (experimental)\n&quot;, defaults-&gt;rc.i_aq_mode );
    H1( &quot;      --aq-strength &lt;float&gt;   Reduces blocking and blurring in flat and\n&quot;
        &quot;                              textured areas. [%.1f]\n&quot;, defaults-&gt;rc.f_aq_strength );
    H1( &quot;\n&quot; );
    H0( &quot;  -p, --pass &lt;integer&gt;        Enable multipass ratecontrol\n&quot;
        &quot;                                  - 1: First pass, creates stats file\n&quot;
        &quot;                                  - 2: Last pass, does not overwrite stats file\n&quot; );
    H2( &quot;                                  - 3: Nth pass, overwrites stats file\n&quot; );
    H1( &quot;      --stats &lt;string&gt;        Filename for 2 pass stats [\&quot;%s\&quot;]\n&quot;, defaults-&gt;rc.psz_stat_out );
    H2( &quot;      --no-mbtree             Disable mb-tree ratecontrol.\n&quot;);
    H2( &quot;      --qcomp &lt;float&gt;         QP curve compression [%.2f]\n&quot;, defaults-&gt;rc.f_qcompress );
    H2( &quot;      --cplxblur &lt;float&gt;      Reduce fluctuations in QP (before curve compression) [%.1f]\n&quot;, defaults-&gt;rc.f_complexity_blur );
    H2( &quot;      --qblur &lt;float&gt;         Reduce fluctuations in QP (after curve compression) [%.1f]\n&quot;, defaults-&gt;rc.f_qblur );
    H2( &quot;      --zones &lt;zone0&gt;/&lt;zone1&gt;/...  Tweak the bitrate of regions of the video\n&quot; );
    H2( &quot;                              Each zone is of the form\n&quot;
        &quot;                                  &lt;start frame&gt;,&lt;end frame&gt;,&lt;option&gt;\n&quot;
        &quot;                                  where &lt;option&gt; is either\n&quot;
        &quot;                                      q=&lt;integer&gt; (force QP)\n&quot;
        &quot;                                  or  b=&lt;float&gt; (bitrate multiplier)\n&quot; );
    H2( &quot;      --qpfile &lt;string&gt;       Force frametypes and QPs for some or all frames\n&quot;
        &quot;                              Format of each line: framenumber frametype QP\n&quot;
        &quot;                              QP is optional (none lets x264 choose). Frametypes: I,i,K,P,B,b.\n&quot;
        &quot;                                  K=&lt;I or i&gt; depending on open-gop setting\n&quot;
        &quot;                              QPs are restricted by qpmin/qpmax.\n&quot; );
    H1( &quot;\n&quot; );
    H1( &quot;Analysis:\n&quot; );
    H1( &quot;\n&quot; );
    H1( &quot;  -A, --partitions &lt;string&gt;   Partitions to consider [\&quot;p8x8,b8x8,i8x8,i4x4\&quot;]\n&quot;
        &quot;                                  - p8x8, p4x4, b8x8, i8x8, i4x4\n&quot;
        &quot;                                  - none, all\n&quot;
        &quot;                                  (p4x4 requires p8x8. i8x8 requires --8x8dct.)\n&quot; );
    H1( &quot;      --direct &lt;string&gt;       Direct MV prediction mode [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - none, spatial, temporal, auto\n&quot;,
                                       strtable_lookup( x264_direct_pred_names, defaults-&gt;analyse.i_direct_mv_pred ) );
    H2( &quot;      --no-weightb            Disable weighted prediction for B-frames\n&quot; );
    H1( &quot;      --weightp &lt;integer&gt;     Weighted prediction for P-frames [%d]\n&quot;
        &quot;                                  - 0: Disabled\n&quot;
        &quot;                                  - 1: Weighted refs\n&quot;
        &quot;                                  - 2: Weighted refs + Duplicates\n&quot;, defaults-&gt;analyse.i_weighted_pred );
    H1( &quot;      --me &lt;string&gt;           Integer pixel motion estimation method [\&quot;%s\&quot;]\n&quot;,
                                       strtable_lookup( x264_motion_est_names, defaults-&gt;analyse.i_me_method ) );
    H2( &quot;                                  - dia: diamond search, radius 1 (fast)\n&quot;
        &quot;                                  - hex: hexagonal search, radius 2\n&quot;
        &quot;                                  - umh: uneven multi-hexagon search\n&quot;
        &quot;                                  - esa: exhaustive search\n&quot;
        &quot;                                  - tesa: hadamard exhaustive search (slow)\n&quot; );
    else H1( &quot;                                  - dia, hex, umh\n&quot; );
    H2( &quot;      --merange &lt;integer&gt;     Maximum motion vector search range [%d]\n&quot;, defaults-&gt;analyse.i_me_range );
    H2( &quot;      --mvrange &lt;integer&gt;     Maximum motion vector length [-1 (auto)]\n&quot; );
    H2( &quot;      --mvrange-thread &lt;int&gt;  Minimum buffer between threads [-1 (auto)]\n&quot; );
    H1( &quot;  -m, --subme &lt;integer&gt;       Subpixel motion estimation and mode decision [%d]\n&quot;, defaults-&gt;analyse.i_subpel_refine );
    H2( &quot;                                  - 0: fullpel only (not recommended)\n&quot;
        &quot;                                  - 1: SAD mode decision, one qpel iteration\n&quot;
        &quot;                                  - 2: SATD mode decision\n&quot;
        &quot;                                  - 3-5: Progressively more qpel\n&quot;
        &quot;                                  - 6: RD mode decision for I/P-frames\n&quot;
        &quot;                                  - 7: RD mode decision for all frames\n&quot;
        &quot;                                  - 8: RD refinement for I/P-frames\n&quot;
        &quot;                                  - 9: RD refinement for all frames\n&quot;
        &quot;                                  - 10: QP-RD - requires trellis=2, aq-mode&gt;0\n&quot;
        &quot;                                  - 11: Full RD: disable all early terminations\n&quot; );
    else H1( &quot;                                  decision quality: 1=fast, 11=best\n&quot; );
    H1( &quot;      --psy-rd &lt;float:float&gt;  Strength of psychovisual optimization [\&quot;%.1f:%.1f\&quot;]\n&quot;
        &quot;                                  #1: RD (requires subme&gt;=6)\n&quot;
        &quot;                                  #2: Trellis (requires trellis, experimental)\n&quot;,
                                       defaults-&gt;analyse.f_psy_rd, defaults-&gt;analyse.f_psy_trellis );
    H2( &quot;      --no-psy                Disable all visual optimizations that worsen\n&quot;
        &quot;                              both PSNR and SSIM.\n&quot; );
    H2( &quot;      --no-mixed-refs         Don't decide references on a per partition basis\n&quot; );
    H2( &quot;      --no-chroma-me          Ignore chroma in motion estimation\n&quot; );
    H1( &quot;      --no-8x8dct             Disable adaptive spatial transform size\n&quot; );
    H1( &quot;  -t, --trellis &lt;integer&gt;     Trellis RD quantization. [%d]\n&quot;
        &quot;                                  - 0: disabled\n&quot;
        &quot;                                  - 1: enabled only on the final encode of a MB\n&quot;
        &quot;                                  - 2: enabled on all mode decisions\n&quot;, defaults-&gt;analyse.i_trellis );
    H2( &quot;      --no-fast-pskip         Disables early SKIP detection on P-frames\n&quot; );
    H2( &quot;      --no-dct-decimate       Disables coefficient thresholding on P-frames\n&quot; );
    H1( &quot;      --nr &lt;integer&gt;          Noise reduction [%d]\n&quot;, defaults-&gt;analyse.i_noise_reduction );
    H2( &quot;\n&quot; );
    H2( &quot;      --deadzone-inter &lt;int&gt;  Set the size of the inter luma quantization deadzone [%d]\n&quot;, defaults-&gt;analyse.i_luma_deadzone[0] );
    H2( &quot;      --deadzone-intra &lt;int&gt;  Set the size of the intra luma quantization deadzone [%d]\n&quot;, defaults-&gt;analyse.i_luma_deadzone[1] );
    H2( &quot;                                  Deadzones should be in the range 0 - 32.\n&quot; );
    H2( &quot;      --cqm &lt;string&gt;          Preset quant matrices [\&quot;flat\&quot;]\n&quot;
        &quot;                                  - jvt, flat\n&quot; );
    H1( &quot;      --cqmfile &lt;string&gt;      Read custom quant matrices from a JM-compatible file\n&quot; );
    H2( &quot;                                  Overrides any other --cqm* options.\n&quot; );
    H2( &quot;      --cqm4 &lt;list&gt;           Set all 4x4 quant matrices\n&quot;
        &quot;                                  Takes a comma-separated list of 16 integers.\n&quot; );
    H2( &quot;      --cqm8 &lt;list&gt;           Set all 8x8 quant matrices\n&quot;
        &quot;                                  Takes a comma-separated list of 64 integers.\n&quot; );
    H2( &quot;      --cqm4i, --cqm4p, --cqm8i, --cqm8p &lt;list&gt;\n&quot;
        &quot;                              Set both luma and chroma quant matrices\n&quot; );
    H2( &quot;      --cqm4iy, --cqm4ic, --cqm4py, --cqm4pc &lt;list&gt;\n&quot;
        &quot;                              Set individual quant matrices\n&quot; );
    H2( &quot;\n&quot; );
    H2( &quot;Video Usability Info (Annex E):\n&quot; );
    H2( &quot;The VUI settings are not used by the encoder but are merely suggestions to\n&quot; );
    H2( &quot;the playback equipment. See doc/vui.txt for details. Use at your own risk.\n&quot; );
    H2( &quot;\n&quot; );
    H2( &quot;      --overscan &lt;string&gt;     Specify crop overscan setting [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - undef, show, crop\n&quot;,
                                       strtable_lookup( x264_overscan_names, defaults-&gt;vui.i_overscan ) );
    H2( &quot;      --videoformat &lt;string&gt;  Specify video format [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - component, pal, ntsc, secam, mac, undef\n&quot;,
                                       strtable_lookup( x264_vidformat_names, defaults-&gt;vui.i_vidformat ) );
    H2( &quot;      --range &lt;string&gt;        Specify color range [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - %s\n&quot;, range_names[0], stringify_names( buf, range_names ) );
    H2( &quot;      --colorprim &lt;string&gt;    Specify color primaries [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - undef, bt709, bt470m, bt470bg, smpte170m,\n&quot;
        &quot;                                    smpte240m, film, bt2020\n&quot;,
                                       strtable_lookup( x264_colorprim_names, defaults-&gt;vui.i_colorprim ) );
    H2( &quot;      --transfer &lt;string&gt;     Specify transfer characteristics [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - undef, bt709, bt470m, bt470bg, smpte170m,\n&quot;
        &quot;                                    smpte240m, linear, log100, log316,\n&quot;
        &quot;                                    iec61966-2-4, bt1361e, iec61966-2-1,\n&quot;
        &quot;                                    bt2020-10, bt2020-12\n&quot;,
                                       strtable_lookup( x264_transfer_names, defaults-&gt;vui.i_transfer ) );
    H2( &quot;      --colormatrix &lt;string&gt;  Specify color matrix setting [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - undef, bt709, fcc, bt470bg, smpte170m,\n&quot;
        &quot;                                    smpte240m, GBR, YCgCo, bt2020nc, bt2020c\n&quot;,
                                       strtable_lookup( x264_colmatrix_names, defaults-&gt;vui.i_colmatrix ) );
    H2( &quot;      --chromaloc &lt;integer&gt;   Specify chroma sample location (0 to 5) [%d]\n&quot;,
                                       defaults-&gt;vui.i_chroma_loc );

    H2( &quot;      --nal-hrd &lt;string&gt;      Signal HRD information (requires vbv-bufsize)\n&quot;
        &quot;                                  - none, vbr, cbr (cbr not allowed in .mp4)\n&quot; );
    H2( &quot;      --filler                Force hard-CBR and generate filler (implied by\n&quot;
        &quot;                              --nal-hrd cbr)\n&quot; );
    H2( &quot;      --pic-struct            Force pic_struct in Picture Timing SEI\n&quot; );
    H2( &quot;      --crop-rect &lt;string&gt;    Add 'left,top,right,bottom' to the bitstream-level\n&quot;
        &quot;                              cropping rectangle\n&quot; );

    H0( &quot;\n&quot; );
    H0( &quot;Input/Output:\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;  -o, --output &lt;string&gt;       Specify output file\n&quot; );
    H1( &quot;      --muxer &lt;string&gt;        Specify output container format [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - %s\n&quot;, muxer_names[0], stringify_names( buf, muxer_names ) );
    H1( &quot;      --demuxer &lt;string&gt;      Specify input container format [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - %s\n&quot;, demuxer_names[0], stringify_names( buf, demuxer_names ) );
    H1( &quot;      --input-fmt &lt;string&gt;    Specify input file format (requires lavf support)\n&quot; );
    H1( &quot;      --input-csp &lt;string&gt;    Specify input colorspace format for raw input\n&quot; );
    print_csp_names( longhelp );
    H1( &quot;      --output-csp &lt;string&gt;   Specify output colorspace [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - %s\n&quot;, output_csp_names[0], stringify_names( buf, output_csp_names ) );
    H1( &quot;      --input-depth &lt;integer&gt; Specify input bit depth for raw input\n&quot; );
    H1( &quot;      --input-range &lt;string&gt;  Specify input color range [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - %s\n&quot;, range_names[0], stringify_names( buf, range_names ) );
    H1( &quot;      --input-res &lt;intxint&gt;   Specify input resolution (width x height)\n&quot; );
    H1( &quot;      --index &lt;string&gt;        Filename for input index file\n&quot; );
    H0( &quot;      --sar width:height      Specify Sample Aspect Ratio\n&quot; );
    H0( &quot;      --fps &lt;float|rational&gt;  Specify framerate\n&quot; );
    H0( &quot;      --seek &lt;integer&gt;        First frame to encode\n&quot; );
    H0( &quot;      --frames &lt;integer&gt;      Maximum number of frames to encode\n&quot; );
    H0( &quot;      --level &lt;string&gt;        Specify level (as defined by Annex A)\n&quot; );
    H1( &quot;      --bluray-compat         Enable compatibility hacks for Blu-ray support\n&quot; );
    H1( &quot;      --avcintra-class &lt;integer&gt; Use compatibility hacks for AVC-Intra class\n&quot;
        &quot;                                  - 50, 100, 200\n&quot; );
    H1( &quot;      --stitchable            Don't optimize headers based on video content\n&quot;
        &quot;                              Ensures ability to recombine a segmented encode\n&quot; );
    H1( &quot;\n&quot; );
    H1( &quot;  -v, --verbose               Print stats for each frame\n&quot; );
    H1( &quot;      --no-progress           Don't show the progress indicator while encoding\n&quot; );
    H0( &quot;      --quiet                 Quiet Mode\n&quot; );
    H1( &quot;      --log-level &lt;string&gt;    Specify the maximum level of logging [\&quot;%s\&quot;]\n&quot;
        &quot;                                  - %s\n&quot;, strtable_lookup( log_level_names, cli_log_level - X264_LOG_NONE ),
                                       stringify_names( buf, log_level_names ) );
    H1( &quot;      --psnr                  Enable PSNR computation\n&quot; );
    H1( &quot;      --ssim                  Enable SSIM computation\n&quot; );
    H1( &quot;      --threads &lt;integer&gt;     Force a specific number of threads\n&quot; );
    H2( &quot;      --lookahead-threads &lt;integer&gt; Force a specific number of lookahead threads\n&quot; );
    H2( &quot;      --sliced-threads        Low-latency but lower-efficiency threading\n&quot; );
    H2( &quot;      --thread-input          Run Avisynth in its own thread\n&quot; );
    H2( &quot;      --sync-lookahead &lt;integer&gt; Number of buffer frames for threaded lookahead\n&quot; );
    H2( &quot;      --non-deterministic     Slightly improve quality of SMP, at the cost of repeatability\n&quot; );
    H2( &quot;      --cpu-independent       Ensure exact reproducibility across different cpus,\n&quot;
        &quot;                                  as opposed to letting them select different algorithms\n&quot; );
    H2( &quot;      --asm &lt;integer&gt;         Override CPU detection\n&quot; );
    H2( &quot;      --no-asm                Disable all CPU optimizations\n&quot; );
    H2( &quot;      --opencl                Enable use of OpenCL\n&quot; );
    H2( &quot;      --opencl-clbin &lt;string&gt; Specify path of compiled OpenCL kernel cache\n&quot; );
    H2( &quot;      --opencl-device &lt;integer&gt; Specify OpenCL device ordinal\n&quot; );
    H2( &quot;      --dump-yuv &lt;string&gt;     Save reconstructed frames\n&quot; );
    H2( &quot;      --sps-id &lt;integer&gt;      Set SPS and PPS id numbers [%d]\n&quot;, defaults-&gt;i_sps_id );
    H2( &quot;      --aud                   Use access unit delimiters\n&quot; );
    H2( &quot;      --force-cfr             Force constant framerate timestamp generation\n&quot; );
    H2( &quot;      --tcfile-in &lt;string&gt;    Force timestamp generation with timecode file\n&quot; );
    H2( &quot;      --tcfile-out &lt;string&gt;   Output timecode v2 file from input timestamps\n&quot; );
    H2( &quot;      --timebase &lt;int/int&gt;    Specify timebase numerator and denominator\n&quot;
        &quot;                 &lt;integer&gt;    Specify timebase numerator for input timecode file\n&quot;
        &quot;                              or specify timebase denominator for other input\n&quot; );
    H2( &quot;      --dts-compress          Eliminate initial delay with container DTS hack\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;Filtering:\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      --vf, --video-filter &lt;filter0&gt;/&lt;filter1&gt;/... Apply video filtering to the input file\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Filter options may be specified in &lt;filter&gt;:&lt;option&gt;=&lt;value&gt; format.\n&quot; );
    H0( &quot;\n&quot; );
    H0( &quot;      Available filters:\n&quot; );
    x264_register_vid_filters();
    x264_vid_filter_help( longhelp );
    H0( &quot;\n&quot; );
}
</pre><br />help()中主要有3个宏定义：H0()，H1()和H2()。这三个宏定义实质上都是printf()。它们之间的区别在于：H0()无论如何都会调用print()；H1()在longhelp大于等于1的时候才会调用print()；而H2()在longhelp等于2时候才会调用print()。<br /><br /><h3>print_version_info()</h3>print_version_info()用于打印x264的版本信息。在x264命令行程序中添加“-V”参数后会调用该函数。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_10_5117083" name="code" class="cpp">//打印版本信息
static void print_version_info( void )
{
#ifdef X264_POINTVER
    printf( &quot;x264 &quot;X264_POINTVER&quot;\n&quot; );
#else
    printf( &quot;x264 0.%d.X\n&quot;, X264_BUILD );
#endif
#if HAVE_SWSCALE
    printf( &quot;(libswscale %d.%d.%d)\n&quot;, LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO );
#endif
#if HAVE_LAVF
    printf( &quot;(libavformat %d.%d.%d)\n&quot;, LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO );
#endif
#if HAVE_FFMS
    printf( &quot;(ffmpegsource %d.%d.%d.%d)\n&quot;, FFMS_VERSION &gt;&gt; 24, (FFMS_VERSION &amp; 0xff0000) &gt;&gt; 16, (FFMS_VERSION &amp; 0xff00) &gt;&gt; 8, FFMS_VERSION &amp; 0xff );
#endif
    printf( &quot;built on &quot; __DATE__ &quot;, &quot; );
#ifdef __INTEL_COMPILER
    printf( &quot;intel: %.2f (%d)\n&quot;, __INTEL_COMPILER / 100.f, __INTEL_COMPILER_BUILD_DATE );
#elif defined(__GNUC__)
    printf( &quot;gcc: &quot; __VERSION__ &quot;\n&quot; );
#elif defined(_MSC_FULL_VER)
    printf( &quot;msvc: %.2f (%u)\n&quot;, _MSC_VER / 100.f, _MSC_FULL_VER );
#else
    printf( &quot;using an unknown compiler\n&quot; );
#endif
    printf( &quot;configuration: --bit-depth=%d --chroma-format=%s\n&quot;, x264_bit_depth, X264_CHROMA_FORMAT ? (output_csp_names[0]+1) : &quot;all&quot; );
    printf( &quot;x264 license: &quot; );
#if HAVE_GPL
    printf( &quot;GPL version 2 or later\n&quot; );
#else
    printf( &quot;Non-GPL commercial\n&quot; );
#endif
#if HAVE_SWSCALE
    const char *license = swscale_license();
    printf( &quot;libswscale%s%s license: %s\n&quot;, HAVE_LAVF ? &quot;/libavformat&quot; : &quot;&quot;, HAVE_FFMS ? &quot;/ffmpegsource&quot; : &quot;&quot; , license );
    if( !strcmp( license, &quot;nonfree and unredistributable&quot; ) ||
       (!HAVE_GPL &amp;&amp; (!strcmp( license, &quot;GPL version 2 or later&quot; )
                  ||  !strcmp( license, &quot;GPL version 3 or later&quot; ))))
        printf( &quot;WARNING: This binary is unredistributable!\n&quot; );
#endif
}
</pre><br />该函数定义比较浅显易懂，不再详细记录。<br /><br /><h3>x264_param_parse()</h3>x264_param_parse()是一个x264的API。该函数以字符串键值对的方式设置x264_param_t结构体的一个成员变量。该函数的声明如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_11_9638297" name="code" class="cpp">/* x264_param_parse:
 *  set one parameter by name.
 *  returns 0 on success, or returns one of the following errors.
 *  note: BAD_VALUE occurs only if it can't even parse the value,
 *  numerical range is not checked until x264_encoder_open() or
 *  x264_encoder_reconfig().
 *  value=NULL means &quot;true&quot; for boolean options, but is a BAD_VALUE for non-booleans. */
int x264_param_parse( x264_param_t *, const char *name, const char *value );</pre>x264_param_parse()的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_12_3145756" name="code" class="cpp">//解析以字符串方式输入的参数
//即选项名称和选项值都是字符串
//实质就是通过strcmp()方法
int x264_param_parse( x264_param_t *p, const char *name, const char *value )
{
    char *name_buf = NULL;
    int b_error = 0;
    int name_was_bool;
    int value_was_null = !value;
    int i;

    if( !name )
        return X264_PARAM_BAD_NAME;
    if( !value )
        value = &quot;true&quot;;

    if( value[0] == '=' )
        value++;

    if( strchr( name, '_' ) ) // s/_/-/g
    {
        char *c;
        name_buf = strdup(name);
        while( (c = strchr( name_buf, '_' )) )
            *c = '-';
        name = name_buf;
    }

    if( (!strncmp( name, &quot;no-&quot;, 3 ) &amp;&amp; (i = 3)) ||
        (!strncmp( name, &quot;no&quot;, 2 ) &amp;&amp; (i = 2)) )
    {
        name += i;
        value = atobool(value) ? &quot;false&quot; : &quot;true&quot;;
    }
    name_was_bool = 0;

#define OPT(STR) else if( !strcmp( name, STR ) )
#define OPT2(STR0, STR1) else if( !strcmp( name, STR0 ) || !strcmp( name, STR1 ) )
    if(0);
    //OPT()实际上就是strcmp()
    OPT(&quot;asm&quot;)
    {
        p-&gt;cpu = isdigit(value[0]) ? atoi(value) :
                 !strcasecmp(value, &quot;auto&quot;) || atobool(value) ? x264_cpu_detect() : 0;
        if( b_error )
        {
            char *buf = strdup(value);
            char *tok, UNUSED *saveptr=NULL, *init;
            b_error = 0;
            p-&gt;cpu = 0;
            for( init=buf; (tok=strtok_r(init, &quot;,&quot;, &amp;saveptr)); init=NULL )
            {
                for( i=0; x264_cpu_names[i].flags &amp;&amp; strcasecmp(tok, x264_cpu_names[i].name); i++ );
                p-&gt;cpu |= x264_cpu_names[i].flags;
                if( !x264_cpu_names[i].flags )
                    b_error = 1;
            }
            free( buf );
            if( (p-&gt;cpu&amp;X264_CPU_SSSE3) &amp;&amp; !(p-&gt;cpu&amp;X264_CPU_SSE2_IS_SLOW) )
                p-&gt;cpu |= X264_CPU_SSE2_IS_FAST;
        }
    }
    OPT(&quot;threads&quot;)
    {
        if( !strcasecmp(value, &quot;auto&quot;) )
            p-&gt;i_threads = X264_THREADS_AUTO;
        else
            p-&gt;i_threads = atoi(value);
    }
    OPT(&quot;lookahead-threads&quot;)
    {
        if( !strcasecmp(value, &quot;auto&quot;) )
            p-&gt;i_lookahead_threads = X264_THREADS_AUTO;
        else
            p-&gt;i_lookahead_threads = atoi(value);
    }
    OPT(&quot;sliced-threads&quot;)
        p-&gt;b_sliced_threads = atobool(value);
    OPT(&quot;sync-lookahead&quot;)
    {
        if( !strcasecmp(value, &quot;auto&quot;) )
            p-&gt;i_sync_lookahead = X264_SYNC_LOOKAHEAD_AUTO;
        else
            p-&gt;i_sync_lookahead = atoi(value);
    }
    OPT2(&quot;deterministic&quot;, &quot;n-deterministic&quot;)
        p-&gt;b_deterministic = atobool(value);
    OPT(&quot;cpu-independent&quot;)
        p-&gt;b_cpu_independent = atobool(value);
    OPT2(&quot;level&quot;, &quot;level-idc&quot;)
    {
        if( !strcmp(value, &quot;1b&quot;) )
            p-&gt;i_level_idc = 9;
        else if( atof(value) &lt; 6 )
            p-&gt;i_level_idc = (int)(10*atof(value)+.5);
        else
            p-&gt;i_level_idc = atoi(value);
    }
    OPT(&quot;bluray-compat&quot;)
        p-&gt;b_bluray_compat = atobool(value);
    OPT(&quot;avcintra-class&quot;)
        p-&gt;i_avcintra_class = atoi(value);
    OPT(&quot;sar&quot;)
    {
        b_error = ( 2 != sscanf( value, &quot;%d:%d&quot;, &amp;p-&gt;vui.i_sar_width, &amp;p-&gt;vui.i_sar_height ) &amp;&amp;
                    2 != sscanf( value, &quot;%d/%d&quot;, &amp;p-&gt;vui.i_sar_width, &amp;p-&gt;vui.i_sar_height ) );
    }
    OPT(&quot;overscan&quot;)
        b_error |= parse_enum( value, x264_overscan_names, &amp;p-&gt;vui.i_overscan );
    OPT(&quot;videoformat&quot;)
        b_error |= parse_enum( value, x264_vidformat_names, &amp;p-&gt;vui.i_vidformat );
    OPT(&quot;fullrange&quot;)
        b_error |= parse_enum( value, x264_fullrange_names, &amp;p-&gt;vui.b_fullrange );
    OPT(&quot;colorprim&quot;)
        b_error |= parse_enum( value, x264_colorprim_names, &amp;p-&gt;vui.i_colorprim );
    OPT(&quot;transfer&quot;)
        b_error |= parse_enum( value, x264_transfer_names, &amp;p-&gt;vui.i_transfer );
    OPT(&quot;colormatrix&quot;)
        b_error |= parse_enum( value, x264_colmatrix_names, &amp;p-&gt;vui.i_colmatrix );
    OPT(&quot;chromaloc&quot;)
    {
        p-&gt;vui.i_chroma_loc = atoi(value);
        b_error = ( p-&gt;vui.i_chroma_loc &lt; 0 || p-&gt;vui.i_chroma_loc &gt; 5 );
    }
    OPT(&quot;fps&quot;)
    {
        if( sscanf( value, &quot;%u/%u&quot;, &amp;p-&gt;i_fps_num, &amp;p-&gt;i_fps_den ) == 2 )
            ;
        else
        {
            float fps = atof(value);
            if( fps &gt; 0 &amp;&amp; fps &lt;= INT_MAX/1000 )
            {
                p-&gt;i_fps_num = (int)(fps * 1000 + .5);
                p-&gt;i_fps_den = 1000;
            }
            else
            {
                p-&gt;i_fps_num = atoi(value);
                p-&gt;i_fps_den = 1;
            }
        }
    }
    OPT2(&quot;ref&quot;, &quot;frameref&quot;)
        p-&gt;i_frame_reference = atoi(value);
    OPT(&quot;dpb-size&quot;)
        p-&gt;i_dpb_size = atoi(value);
    OPT(&quot;keyint&quot;)
    {
        if( strstr( value, &quot;infinite&quot; ) )
            p-&gt;i_keyint_max = X264_KEYINT_MAX_INFINITE;
        else
            p-&gt;i_keyint_max = atoi(value);
    }
    OPT2(&quot;min-keyint&quot;, &quot;keyint-min&quot;)
    {
        p-&gt;i_keyint_min = atoi(value);
        if( p-&gt;i_keyint_max &lt; p-&gt;i_keyint_min )
            p-&gt;i_keyint_max = p-&gt;i_keyint_min;
    }
    OPT(&quot;scenecut&quot;)
    {
        p-&gt;i_scenecut_threshold = atobool(value);
        if( b_error || p-&gt;i_scenecut_threshold )
        {
            b_error = 0;
            p-&gt;i_scenecut_threshold = atoi(value);
        }
    }
    OPT(&quot;intra-refresh&quot;)
        p-&gt;b_intra_refresh = atobool(value);
    OPT(&quot;bframes&quot;)
        p-&gt;i_bframe = atoi(value);
    OPT(&quot;b-adapt&quot;)
    {
        p-&gt;i_bframe_adaptive = atobool(value);
        if( b_error )
        {
            b_error = 0;
            p-&gt;i_bframe_adaptive = atoi(value);
        }
    }
    OPT(&quot;b-bias&quot;)
        p-&gt;i_bframe_bias = atoi(value);
    OPT(&quot;b-pyramid&quot;)
    {
        b_error |= parse_enum( value, x264_b_pyramid_names, &amp;p-&gt;i_bframe_pyramid );
        if( b_error )
        {
            b_error = 0;
            p-&gt;i_bframe_pyramid = atoi(value);
        }
    }
    OPT(&quot;open-gop&quot;)
        p-&gt;b_open_gop = atobool(value);
    OPT(&quot;nf&quot;)
        p-&gt;b_deblocking_filter = !atobool(value);
    OPT2(&quot;filter&quot;, &quot;deblock&quot;)
    {
        if( 2 == sscanf( value, &quot;%d:%d&quot;, &amp;p-&gt;i_deblocking_filter_alphac0, &amp;p-&gt;i_deblocking_filter_beta ) ||
            2 == sscanf( value, &quot;%d,%d&quot;, &amp;p-&gt;i_deblocking_filter_alphac0, &amp;p-&gt;i_deblocking_filter_beta ) )
        {
            p-&gt;b_deblocking_filter = 1;
        }
        else if( sscanf( value, &quot;%d&quot;, &amp;p-&gt;i_deblocking_filter_alphac0 ) )
        {
            p-&gt;b_deblocking_filter = 1;
            p-&gt;i_deblocking_filter_beta = p-&gt;i_deblocking_filter_alphac0;
        }
        else
            p-&gt;b_deblocking_filter = atobool(value);
    }
    OPT(&quot;slice-max-size&quot;)
        p-&gt;i_slice_max_size = atoi(value);
    OPT(&quot;slice-max-mbs&quot;)
        p-&gt;i_slice_max_mbs = atoi(value);
    OPT(&quot;slice-min-mbs&quot;)
        p-&gt;i_slice_min_mbs = atoi(value);
    OPT(&quot;slices&quot;)
        p-&gt;i_slice_count = atoi(value);
    OPT(&quot;slices-max&quot;)
        p-&gt;i_slice_count_max = atoi(value);
    OPT(&quot;cabac&quot;)
        p-&gt;b_cabac = atobool(value);
    OPT(&quot;cabac-idc&quot;)
        p-&gt;i_cabac_init_idc = atoi(value);
    OPT(&quot;interlaced&quot;)
        p-&gt;b_interlaced = atobool(value);
    OPT(&quot;tff&quot;)
        p-&gt;b_interlaced = p-&gt;b_tff = atobool(value);
    OPT(&quot;bff&quot;)
    {
        p-&gt;b_interlaced = atobool(value);
        p-&gt;b_tff = !p-&gt;b_interlaced;
    }
    OPT(&quot;constrained-intra&quot;)
        p-&gt;b_constrained_intra = atobool(value);
    OPT(&quot;cqm&quot;)
    {
        if( strstr( value, &quot;flat&quot; ) )
            p-&gt;i_cqm_preset = X264_CQM_FLAT;
        else if( strstr( value, &quot;jvt&quot; ) )
            p-&gt;i_cqm_preset = X264_CQM_JVT;
        else
            p-&gt;psz_cqm_file = strdup(value);
    }
    OPT(&quot;cqmfile&quot;)
        p-&gt;psz_cqm_file = strdup(value);
    OPT(&quot;cqm4&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4iy, 16 );
        b_error |= parse_cqm( value, p-&gt;cqm_4py, 16 );
        b_error |= parse_cqm( value, p-&gt;cqm_4ic, 16 );
        b_error |= parse_cqm( value, p-&gt;cqm_4pc, 16 );
    }
    OPT(&quot;cqm8&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_8iy, 64 );
        b_error |= parse_cqm( value, p-&gt;cqm_8py, 64 );
        b_error |= parse_cqm( value, p-&gt;cqm_8ic, 64 );
        b_error |= parse_cqm( value, p-&gt;cqm_8pc, 64 );
    }
    OPT(&quot;cqm4i&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4iy, 16 );
        b_error |= parse_cqm( value, p-&gt;cqm_4ic, 16 );
    }
    OPT(&quot;cqm4p&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4py, 16 );
        b_error |= parse_cqm( value, p-&gt;cqm_4pc, 16 );
    }
    OPT(&quot;cqm4iy&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4iy, 16 );
    }
    OPT(&quot;cqm4ic&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4ic, 16 );
    }
    OPT(&quot;cqm4py&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4py, 16 );
    }
    OPT(&quot;cqm4pc&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_4pc, 16 );
    }
    OPT(&quot;cqm8i&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_8iy, 64 );
        b_error |= parse_cqm( value, p-&gt;cqm_8ic, 64 );
    }
    OPT(&quot;cqm8p&quot;)
    {
        p-&gt;i_cqm_preset = X264_CQM_CUSTOM;
        b_error |= parse_cqm( value, p-&gt;cqm_8py, 64 );
        b_error |= parse_cqm( value, p-&gt;cqm_8pc, 64 );
    }
    OPT(&quot;log&quot;)
        p-&gt;i_log_level = atoi(value);
    OPT(&quot;dump-yuv&quot;)
        p-&gt;psz_dump_yuv = strdup(value);
    OPT2(&quot;analyse&quot;, &quot;partitions&quot;)
    {
        p-&gt;analyse.inter = 0;
        if( strstr( value, &quot;none&quot; ) )  p-&gt;analyse.inter =  0;
        if( strstr( value, &quot;all&quot; ) )   p-&gt;analyse.inter = ~0;

        if( strstr( value, &quot;i4x4&quot; ) )  p-&gt;analyse.inter |= X264_ANALYSE_I4x4;
        if( strstr( value, &quot;i8x8&quot; ) )  p-&gt;analyse.inter |= X264_ANALYSE_I8x8;
        if( strstr( value, &quot;p8x8&quot; ) )  p-&gt;analyse.inter |= X264_ANALYSE_PSUB16x16;
        if( strstr( value, &quot;p4x4&quot; ) )  p-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;
        if( strstr( value, &quot;b8x8&quot; ) )  p-&gt;analyse.inter |= X264_ANALYSE_BSUB16x16;
    }
    OPT(&quot;8x8dct&quot;)
        p-&gt;analyse.b_transform_8x8 = atobool(value);
    OPT2(&quot;weightb&quot;, &quot;weight-b&quot;)
        p-&gt;analyse.b_weighted_bipred = atobool(value);
    OPT(&quot;weightp&quot;)
        p-&gt;analyse.i_weighted_pred = atoi(value);
    OPT2(&quot;direct&quot;, &quot;direct-pred&quot;)
        b_error |= parse_enum( value, x264_direct_pred_names, &amp;p-&gt;analyse.i_direct_mv_pred );
    OPT(&quot;chroma-qp-offset&quot;)
        p-&gt;analyse.i_chroma_qp_offset = atoi(value);
    OPT(&quot;me&quot;)
        b_error |= parse_enum( value, x264_motion_est_names, &amp;p-&gt;analyse.i_me_method );
    OPT2(&quot;merange&quot;, &quot;me-range&quot;)
        p-&gt;analyse.i_me_range = atoi(value);
    OPT2(&quot;mvrange&quot;, &quot;mv-range&quot;)
        p-&gt;analyse.i_mv_range = atoi(value);
    OPT2(&quot;mvrange-thread&quot;, &quot;mv-range-thread&quot;)
        p-&gt;analyse.i_mv_range_thread = atoi(value);
    OPT2(&quot;subme&quot;, &quot;subq&quot;)
        p-&gt;analyse.i_subpel_refine = atoi(value);
    OPT(&quot;psy-rd&quot;)
    {
        if( 2 == sscanf( value, &quot;%f:%f&quot;, &amp;p-&gt;analyse.f_psy_rd, &amp;p-&gt;analyse.f_psy_trellis ) ||
            2 == sscanf( value, &quot;%f,%f&quot;, &amp;p-&gt;analyse.f_psy_rd, &amp;p-&gt;analyse.f_psy_trellis ) ||
            2 == sscanf( value, &quot;%f|%f&quot;, &amp;p-&gt;analyse.f_psy_rd, &amp;p-&gt;analyse.f_psy_trellis ))
        { }
        else if( sscanf( value, &quot;%f&quot;, &amp;p-&gt;analyse.f_psy_rd ) )
        {
            p-&gt;analyse.f_psy_trellis = 0;
        }
        else
        {
            p-&gt;analyse.f_psy_rd = 0;
            p-&gt;analyse.f_psy_trellis = 0;
        }
    }
    OPT(&quot;psy&quot;)
        p-&gt;analyse.b_psy = atobool(value);
    OPT(&quot;chroma-me&quot;)
        p-&gt;analyse.b_chroma_me = atobool(value);
    OPT(&quot;mixed-refs&quot;)
        p-&gt;analyse.b_mixed_references = atobool(value);
    OPT(&quot;trellis&quot;)
        p-&gt;analyse.i_trellis = atoi(value);
    OPT(&quot;fast-pskip&quot;)
        p-&gt;analyse.b_fast_pskip = atobool(value);
    OPT(&quot;dct-decimate&quot;)
        p-&gt;analyse.b_dct_decimate = atobool(value);
    OPT(&quot;deadzone-inter&quot;)
        p-&gt;analyse.i_luma_deadzone[0] = atoi(value);
    OPT(&quot;deadzone-intra&quot;)
        p-&gt;analyse.i_luma_deadzone[1] = atoi(value);
    OPT(&quot;nr&quot;)
        p-&gt;analyse.i_noise_reduction = atoi(value);
    OPT(&quot;bitrate&quot;)
    {
        p-&gt;rc.i_bitrate = atoi(value);
        p-&gt;rc.i_rc_method = X264_RC_ABR;
    }
    OPT2(&quot;qp&quot;, &quot;qp_constant&quot;)
    {
        p-&gt;rc.i_qp_constant = atoi(value);
        p-&gt;rc.i_rc_method = X264_RC_CQP;
    }
    OPT(&quot;crf&quot;)
    {
        p-&gt;rc.f_rf_constant = atof(value);
        p-&gt;rc.i_rc_method = X264_RC_CRF;
    }
    OPT(&quot;crf-max&quot;)
        p-&gt;rc.f_rf_constant_max = atof(value);
    OPT(&quot;rc-lookahead&quot;)
        p-&gt;rc.i_lookahead = atoi(value);
    OPT2(&quot;qpmin&quot;, &quot;qp-min&quot;)
        p-&gt;rc.i_qp_min = atoi(value);
    OPT2(&quot;qpmax&quot;, &quot;qp-max&quot;)
        p-&gt;rc.i_qp_max = atoi(value);
    OPT2(&quot;qpstep&quot;, &quot;qp-step&quot;)
        p-&gt;rc.i_qp_step = atoi(value);
    OPT(&quot;ratetol&quot;)
        p-&gt;rc.f_rate_tolerance = !strncmp(&quot;inf&quot;, value, 3) ? 1e9 : atof(value);
    OPT(&quot;vbv-maxrate&quot;)
        p-&gt;rc.i_vbv_max_bitrate = atoi(value);
    OPT(&quot;vbv-bufsize&quot;)
        p-&gt;rc.i_vbv_buffer_size = atoi(value);
    OPT(&quot;vbv-init&quot;)
        p-&gt;rc.f_vbv_buffer_init = atof(value);
    OPT2(&quot;ipratio&quot;, &quot;ip-factor&quot;)
        p-&gt;rc.f_ip_factor = atof(value);
    OPT2(&quot;pbratio&quot;, &quot;pb-factor&quot;)
        p-&gt;rc.f_pb_factor = atof(value);
    OPT(&quot;aq-mode&quot;)
        p-&gt;rc.i_aq_mode = atoi(value);
    OPT(&quot;aq-strength&quot;)
        p-&gt;rc.f_aq_strength = atof(value);
    OPT(&quot;pass&quot;)
    {
        int pass = x264_clip3( atoi(value), 0, 3 );
        p-&gt;rc.b_stat_write = pass &amp; 1;
        p-&gt;rc.b_stat_read = pass &amp; 2;
    }
    OPT(&quot;stats&quot;)
    {
        p-&gt;rc.psz_stat_in = strdup(value);
        p-&gt;rc.psz_stat_out = strdup(value);
    }
    OPT(&quot;qcomp&quot;)
        p-&gt;rc.f_qcompress = atof(value);
    OPT(&quot;mbtree&quot;)
        p-&gt;rc.b_mb_tree = atobool(value);
    OPT(&quot;qblur&quot;)
        p-&gt;rc.f_qblur = atof(value);
    OPT2(&quot;cplxblur&quot;, &quot;cplx-blur&quot;)
        p-&gt;rc.f_complexity_blur = atof(value);
    OPT(&quot;zones&quot;)
        p-&gt;rc.psz_zones = strdup(value);
    OPT(&quot;crop-rect&quot;)
        b_error |= sscanf( value, &quot;%u,%u,%u,%u&quot;, &amp;p-&gt;crop_rect.i_left, &amp;p-&gt;crop_rect.i_top,
                                                 &amp;p-&gt;crop_rect.i_right, &amp;p-&gt;crop_rect.i_bottom ) != 4;
    OPT(&quot;psnr&quot;)
        p-&gt;analyse.b_psnr = atobool(value);
    OPT(&quot;ssim&quot;)
        p-&gt;analyse.b_ssim = atobool(value);
    OPT(&quot;aud&quot;)
        p-&gt;b_aud = atobool(value);
    OPT(&quot;sps-id&quot;)
        p-&gt;i_sps_id = atoi(value);
    OPT(&quot;global-header&quot;)
        p-&gt;b_repeat_headers = !atobool(value);
    OPT(&quot;repeat-headers&quot;)
        p-&gt;b_repeat_headers = atobool(value);
    OPT(&quot;annexb&quot;)
        p-&gt;b_annexb = atobool(value);
    OPT(&quot;force-cfr&quot;)
        p-&gt;b_vfr_input = !atobool(value);
    OPT(&quot;nal-hrd&quot;)
        b_error |= parse_enum( value, x264_nal_hrd_names, &amp;p-&gt;i_nal_hrd );
    OPT(&quot;filler&quot;)
        p-&gt;rc.b_filler = atobool(value);
    OPT(&quot;pic-struct&quot;)
        p-&gt;b_pic_struct = atobool(value);
    OPT(&quot;fake-interlaced&quot;)
        p-&gt;b_fake_interlaced = atobool(value);
    OPT(&quot;frame-packing&quot;)
        p-&gt;i_frame_packing = atoi(value);
    OPT(&quot;stitchable&quot;)
        p-&gt;b_stitchable = atobool(value);
    OPT(&quot;opencl&quot;)
        p-&gt;b_opencl = atobool( value );
    OPT(&quot;opencl-clbin&quot;)
        p-&gt;psz_clbin_file = strdup( value );
    OPT(&quot;opencl-device&quot;)
        p-&gt;i_opencl_device = atoi( value );
    else
        return X264_PARAM_BAD_NAME;
#undef OPT
#undef OPT2
#undef atobool
#undef atoi
#undef atof

    if( name_buf )
        free( name_buf );

    b_error |= value_was_null &amp;&amp; !name_was_bool;
    return b_error ? X264_PARAM_BAD_VALUE : 0;
}
</pre><br />x264_param_parse()中判断参数的宏OPT()和OPT2()实质上就是strcmp()。由此可见该函数的流程首先是调用strcmp()判断当前输入参数的名称name，然后再调用atoi()，atof()，或者atobool()等将当前输入参数值value转换成相应类型的值并赋值给对应的参数。<br /><br /><h3>x264_param_apply_profile()</h3>x264_param_apply_profile()是一个x264的API。该函数用于设置x264的profile，它的声明如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_13_797672" name="code" class="cpp">/*      (can be NULL, in which case the function will do nothing)
 *
 *      Does NOT guarantee that the given profile will be used: if the restrictions
 *      of &quot;High&quot; are applied to settings that are already Baseline-compatible, the
 *      stream will remain baseline.  In short, it does not increase settings, only
 *      decrease them.
 *
 *      returns 0 on success, negative on failure (e.g. invalid profile name). */
int     x264_param_apply_profile( x264_param_t *, const char *profile );</pre>x264_param_apply_profile()的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_14_1829894" name="code" class="cpp">//设置profile
int x264_param_apply_profile( x264_param_t *param, const char *profile )
{
    if( !profile )
        return 0;
    //字符串到整型
    int p = profile_string_to_int( profile );
    //检查profile设置是否正确
    if( p &lt; 0 )
    {
        x264_log( NULL, X264_LOG_ERROR, &quot;invalid profile: %s\n&quot;, profile );
        return -1;
    }
    if( p &lt; PROFILE_HIGH444_PREDICTIVE &amp;&amp; ((param-&gt;rc.i_rc_method == X264_RC_CQP &amp;&amp; param-&gt;rc.i_qp_constant &lt;= 0) ||
        (param-&gt;rc.i_rc_method == X264_RC_CRF &amp;&amp; (int)(param-&gt;rc.f_rf_constant + QP_BD_OFFSET) &lt;= 0)) )
    {
        x264_log( NULL, X264_LOG_ERROR, &quot;%s profile doesn't support lossless\n&quot;, profile );
        return -1;
    }
    if( p &lt; PROFILE_HIGH444_PREDICTIVE &amp;&amp; (param-&gt;i_csp &amp; X264_CSP_MASK) &gt;= X264_CSP_I444 )
    {
        x264_log( NULL, X264_LOG_ERROR, &quot;%s profile doesn't support 4:4:4\n&quot;, profile );
        return -1;
    }
    if( p &lt; PROFILE_HIGH422 &amp;&amp; (param-&gt;i_csp &amp; X264_CSP_MASK) &gt;= X264_CSP_I422 )
    {
        x264_log( NULL, X264_LOG_ERROR, &quot;%s profile doesn't support 4:2:2\n&quot;, profile );
        return -1;
    }
    if( p &lt; PROFILE_HIGH10 &amp;&amp; BIT_DEPTH &gt; 8 )
    {
        x264_log( NULL, X264_LOG_ERROR, &quot;%s profile doesn't support a bit depth of %d\n&quot;, profile, BIT_DEPTH );
        return -1;
    }
    //根据不同的Profile做设置
    //Baseline基本型
    if( p == PROFILE_BASELINE )
    {
    	//不支持DCT8x8
        param-&gt;analyse.b_transform_8x8 = 0;
        //不使用CABAC
        param-&gt;b_cabac = 0;
        param-&gt;i_cqm_preset = X264_CQM_FLAT;
        param-&gt;psz_cqm_file = NULL;
        //没有B帧
        param-&gt;i_bframe = 0;
        //没有加权
        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_NONE;
        //不支持隔行扫描
        if( param-&gt;b_interlaced )
        {
            x264_log( NULL, X264_LOG_ERROR, &quot;baseline profile doesn't support interlacing\n&quot; );
            return -1;
        }
        if( param-&gt;b_fake_interlaced )
        {
            x264_log( NULL, X264_LOG_ERROR, &quot;baseline profile doesn't support fake interlacing\n&quot; );
            return -1;
        }
    }
    //Main主型
    else if( p == PROFILE_MAIN )
    {
    	//不支持DCT8x8
        param-&gt;analyse.b_transform_8x8 = 0;
        param-&gt;i_cqm_preset = X264_CQM_FLAT;
        param-&gt;psz_cqm_file = NULL;
    }
    return 0;
}
</pre><br />从定义可以看出，x264_param_apply_profile()首先调用了一个函数profile_string_to_int()将输入的profile字符串转换为int类型的profile；然后会检查该profile的设置是否合理；最后会根据profile对x264_param_t中的参数进行相应的设置。<br />该函数中调用的profile_string_to_int()的定义如下。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_15_7529962" name="code" class="cpp">static int profile_string_to_int( const char *str )
{
    if( !strcasecmp( str, &quot;baseline&quot; ) )
        return PROFILE_BASELINE;
    if( !strcasecmp( str, &quot;main&quot; ) )
        return PROFILE_MAIN;
    if( !strcasecmp( str, &quot;high&quot; ) )
        return PROFILE_HIGH;
    if( !strcasecmp( str, &quot;high10&quot; ) )
        return PROFILE_HIGH10;
    if( !strcasecmp( str, &quot;high422&quot; ) )
        return PROFILE_HIGH422;
    if( !strcasecmp( str, &quot;high444&quot; ) )
        return PROFILE_HIGH444_PREDICTIVE;
    return -1;
}</pre>从定义可以看出profile_string_to_int()根据输入的字符串str返回不同的整型变量。<br /><br /><h3>select_output()</h3>select_output()用于设定输出的文件格式。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_16_5181878" name="code" class="cpp">//根据文件名的后缀确定输出的文件格式（raw H264，flv，mp4...）
static int select_output( const char *muxer, char *filename, x264_param_t *param )
{
    //从文件路径字符串中解析出扩展名，存入ext
    //解析的方式就是反向搜索字符“.”
    const char *ext = get_filename_extension( filename );

    //strcasecmp(char *s1, char *s2)用于忽略大小写比较字符串.
    //参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值。

    if( !strcmp( filename, &quot;-&quot; ) || strcasecmp( muxer, &quot;auto&quot; ) )
        ext = muxer;
    //后缀为“mp4”
    if( !strcasecmp( ext, &quot;mp4&quot; ) )
    {
#if HAVE_GPAC || HAVE_LSMASH
        cli_output = mp4_output;
        param-&gt;b_annexb = 0;
        param-&gt;b_repeat_headers = 0;
        if( param-&gt;i_nal_hrd == X264_NAL_HRD_CBR )
        {
            x264_cli_log( &quot;x264&quot;, X264_LOG_WARNING, &quot;cbr nal-hrd is not compatible with mp4\n&quot; );
            param-&gt;i_nal_hrd = X264_NAL_HRD_VBR;
        }
#else
        x264_cli_log( &quot;x264&quot;, X264_LOG_ERROR, &quot;not compiled with MP4 output support\n&quot; );
        return -1;
#endif
    }
    else if( !strcasecmp( ext, &quot;mkv&quot; ) )
    {
    	//设定cli_output_t
        cli_output = mkv_output;
        //不加起始码0x00000001
        param-&gt;b_annexb = 0;
        //不再每个Keyframe前面加SPS和PPS
        param-&gt;b_repeat_headers = 0;
    }
    else if( !strcasecmp( ext, &quot;flv&quot; ) )
    {
        cli_output = flv_output;
        param-&gt;b_annexb = 0;
        param-&gt;b_repeat_headers = 0;
    }
    else
        cli_output = raw_output;//不符合上述后缀，则输出裸流
    return 0;
}
</pre><br />从函数定义可以看出，select_output()首先调用get_filename_extension()从输入文件路径的字符串中提取出了扩展名，然后根据不同的扩展名设定不同的输出格式。其中get_filename_extension()是一个提取扩展名的函数，定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_17_4229234" name="code" class="cpp">//根据“.”确定文件后缀
static inline char *get_filename_extension( char *filename )
{
    char *ext = filename + strlen( filename );
    while( *ext != '.' &amp;&amp; ext &gt; filename )
        ext--;
    ext += *ext == '.';
    return ext;
}</pre>可以看出get_filename_extension()从字符串的末尾开始向前搜索点符号“.”，并且将“.”后面的内容作为提取出来的扩展名。<br /><br /><h3>select_input()</h3>select_input()用于设定输入的文件格式。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_18_8293099" name="code" class="cpp">//设置输入文件的格式（yuv，y4m...）
static int select_input( const char *demuxer, char *used_demuxer, char *filename,
                         hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
{
    int b_auto = !strcasecmp( demuxer, &quot;auto&quot; );
    //从文件路径字符串中解析出扩展名，存入ext
    //解析的方式就是反向搜索字符“.”
    const char *ext = b_auto ? get_filename_extension( filename ) : &quot;&quot;;
    int b_regular = strcmp( filename, &quot;-&quot; );
    if( !b_regular &amp;&amp; b_auto )
        ext = &quot;raw&quot;;
    b_regular = b_regular &amp;&amp; x264_is_regular_file_path( filename );
    if( b_regular )
    {
        FILE *f = x264_fopen( filename, &quot;r&quot; );
        if( f )
        {
            b_regular = x264_is_regular_file( f );
            fclose( f );
        }
    }
    const char *module = b_auto ? ext : demuxer;

    //strcasecmp(char *s1, char *s2)用于忽略大小写比较字符串.
    //参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值。

    if( !strcasecmp( module, &quot;avs&quot; ) || !strcasecmp( ext, &quot;d2v&quot; ) || !strcasecmp( ext, &quot;dga&quot; ) )
    {
#if HAVE_AVS
        cli_input = avs_input;
        module = &quot;avs&quot;;
#else
        x264_cli_log( &quot;x264&quot;, X264_LOG_ERROR, &quot;not compiled with AVS input support\n&quot; );
        return -1;
#endif
    }
    else if( !strcasecmp( module, &quot;y4m&quot; ) )
        cli_input = y4m_input;
    else if( !strcasecmp( module, &quot;raw&quot; ) || !strcasecmp( ext, &quot;yuv&quot; ) )
        cli_input = raw_input;
    else
    {
#if HAVE_FFMS
        if( b_regular &amp;&amp; (b_auto || !strcasecmp( demuxer, &quot;ffms&quot; )) &amp;&amp;
            !ffms_input.open_file( filename, p_handle, info, opt ) )
        {
            module = &quot;ffms&quot;;
            b_auto = 0;
            cli_input = ffms_input;
        }
#endif
#if HAVE_LAVF
        if( (b_auto || !strcasecmp( demuxer, &quot;lavf&quot; )) &amp;&amp;
            !lavf_input.open_file( filename, p_handle, info, opt ) )
        {
            module = &quot;lavf&quot;;
            b_auto = 0;
            cli_input = lavf_input;
        }
#endif
#if HAVE_AVS
        if( b_regular &amp;&amp; (b_auto || !strcasecmp( demuxer, &quot;avs&quot; )) &amp;&amp;
            !avs_input.open_file( filename, p_handle, info, opt ) )
        {
            module = &quot;avs&quot;;
            b_auto = 0;
            cli_input = avs_input;
        }
#endif
        if( b_auto &amp;&amp; !raw_input.open_file( filename, p_handle, info, opt ) )
        {
            module = &quot;raw&quot;;
            b_auto = 0;
            cli_input = raw_input;
        }

        FAIL_IF_ERROR( !(*p_handle), &quot;could not open input file `%s' via any method!\n&quot;, filename )
    }
    strcpy( used_demuxer, module );

    return 0;
}
</pre><br />从源代码中可以看出，select_input()首先调用get_filename_extension()获取输入文件名的扩展名；然后根据扩展名设置不同的输入格式。<br /><br />至此x264命令行程序main()函数调用的parse()函数就分析完毕了。下面分析main()函数调用的另一个函数encode()。<br /><br /><br /><h2>encode()</h2>encode()编码YUV为H.264码流，该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_19_895486" name="code" class="cpp">//编码（在内部有一个循环用于一帧一帧编码）
static int encode( x264_param_t *param, cli_opt_t *opt )
{
    x264_t *h = NULL;
    x264_picture_t pic;
    cli_pic_t cli_pic;
    const cli_pulldown_t *pulldown = NULL; // shut up gcc

    int     i_frame = 0;
    int     i_frame_output = 0;
    int64_t i_end, i_previous = 0, i_start = 0;
    int64_t i_file = 0;
    int     i_frame_size;
    int64_t last_dts = 0;
    int64_t prev_dts = 0;
    int64_t first_dts = 0;
#   define  MAX_PTS_WARNING 3 /* arbitrary */
    int     pts_warning_cnt = 0;
    int64_t largest_pts = -1;
    int64_t second_largest_pts = -1;
    int64_t ticks_per_frame;
    double  duration;
    double  pulldown_pts = 0;
    int     retval = 0;

    opt-&gt;b_progress &amp;= param-&gt;i_log_level &lt; X264_LOG_DEBUG;

    /* set up pulldown */
    if( opt-&gt;i_pulldown &amp;&amp; !param-&gt;b_vfr_input )
    {
        param-&gt;b_pulldown = 1;
        param-&gt;b_pic_struct = 1;
        pulldown = &amp;pulldown_values[opt-&gt;i_pulldown];
        param-&gt;i_timebase_num = param-&gt;i_fps_den;
        FAIL_IF_ERROR2( fmod( param-&gt;i_fps_num * pulldown-&gt;fps_factor, 1 ),
                        &quot;unsupported framerate for chosen pulldown\n&quot; )
        param-&gt;i_timebase_den = param-&gt;i_fps_num * pulldown-&gt;fps_factor;
    }
    //打开编码器
    h = x264_encoder_open( param );
    FAIL_IF_ERROR2( !h, &quot;x264_encoder_open failed\n&quot; );
    //获得参数
    x264_encoder_parameters( h, param );
    //一些不是裸流的封转格式（FLV，MP4等）需要一些参数，例如宽高等等
    //cli_output_t是代表输出媒体文件的结构体
    FAIL_IF_ERROR2( cli_output.set_param( opt-&gt;hout, param ), &quot;can't set outfile param\n&quot; );
    //计时
    i_start = x264_mdate();

    /* ticks/frame = ticks/second / frames/second */
    ticks_per_frame = (int64_t)param-&gt;i_timebase_den * param-&gt;i_fps_den / param-&gt;i_timebase_num / param-&gt;i_fps_num;
    FAIL_IF_ERROR2( ticks_per_frame &lt; 1 &amp;&amp; !param-&gt;b_vfr_input, &quot;ticks_per_frame invalid: %&quot;PRId64&quot;\n&quot;, ticks_per_frame )
    ticks_per_frame = X264_MAX( ticks_per_frame, 1 );

    //如果不是在每个keyframe前面都增加SPS/PPS/SEI的话，就在整个码流前面加SPS/PPS/SEI
    //Header指的就是SPS/PPS/SEI
    if( !param-&gt;b_repeat_headers )
    {
        // Write SPS/PPS/SEI
        x264_nal_t *headers;
        int i_nal;
        //获得文件头（SPS、PPS、SEI）
        FAIL_IF_ERROR2( x264_encoder_headers( h, &amp;headers, &amp;i_nal ) &lt; 0, &quot;x264_encoder_headers failed\n&quot; )
        //把文件头写入输出文件
        FAIL_IF_ERROR2( (i_file = cli_output.write_headers( opt-&gt;hout, headers )) &lt; 0, &quot;error writing headers to output file\n&quot; );
    }

    if( opt-&gt;tcfile_out )
        fprintf( opt-&gt;tcfile_out, &quot;# timecode format v2\n&quot; );

    /* Encode frames */
    //循环进行编码
    for( ; !b_ctrl_c &amp;&amp; (i_frame &lt; param-&gt;i_frame_total || !param-&gt;i_frame_total); i_frame++ )
    {
    	//从输入源中获取1帧YUV数据，存于cli_pic
    	//cli_vid_filter_t可以认为是x264一种“扩展”后的输入源，可以在像素域对图像进行拉伸裁剪等工作。
    	//原本代表输入源的结构体是cli_input_t
        if( filter.get_frame( opt-&gt;hin, &amp;cli_pic, i_frame + opt-&gt;i_seek ) )
            break;
        //初始化x264_picture_t结构体pic
        x264_picture_init( &amp;pic );
        //cli_pic到pic
        convert_cli_to_lib_pic( &amp;pic, &amp;cli_pic );

        if( !param-&gt;b_vfr_input )
            pic.i_pts = i_frame;

        if( opt-&gt;i_pulldown &amp;&amp; !param-&gt;b_vfr_input )
        {
            pic.i_pic_struct = pulldown-&gt;pattern[ i_frame % pulldown-&gt;mod ];
            pic.i_pts = (int64_t)( pulldown_pts + 0.5 );
            pulldown_pts += pulldown_frame_duration[pic.i_pic_struct];
        }
        else if( opt-&gt;timebase_convert_multiplier )
            pic.i_pts = (int64_t)( pic.i_pts * opt-&gt;timebase_convert_multiplier + 0.5 );

        if( pic.i_pts &lt;= largest_pts )
        {
            if( cli_log_level &gt;= X264_LOG_DEBUG || pts_warning_cnt &lt; MAX_PTS_WARNING )
                x264_cli_log( &quot;x264&quot;, X264_LOG_WARNING, &quot;non-strictly-monotonic pts at frame %d (%&quot;PRId64&quot; &lt;= %&quot;PRId64&quot;)\n&quot;,
                             i_frame, pic.i_pts, largest_pts );
            else if( pts_warning_cnt == MAX_PTS_WARNING )
                x264_cli_log( &quot;x264&quot;, X264_LOG_WARNING, &quot;too many nonmonotonic pts warnings, suppressing further ones\n&quot; );
            pts_warning_cnt++;
            pic.i_pts = largest_pts + ticks_per_frame;
        }

        second_largest_pts = largest_pts;
        largest_pts = pic.i_pts;
        if( opt-&gt;tcfile_out )
            fprintf( opt-&gt;tcfile_out, &quot;%.6f\n&quot;, pic.i_pts * ((double)param-&gt;i_timebase_num / param-&gt;i_timebase_den) * 1e3 );

        if( opt-&gt;qpfile )
            parse_qpfile( opt, &amp;pic, i_frame + opt-&gt;i_seek );

        prev_dts = last_dts;
        //编码pic中存储的1帧YUV数据
        i_frame_size = encode_frame( h, opt-&gt;hout, &amp;pic, &amp;last_dts );
        if( i_frame_size &lt; 0 )
        {
            b_ctrl_c = 1; /* lie to exit the loop */
            retval = -1;
        }
        else if( i_frame_size )
        {
            i_file += i_frame_size;
            i_frame_output++;
            if( i_frame_output == 1 )
                first_dts = prev_dts = last_dts;
        }
        //释放处理完的YUV数据
        if( filter.release_frame( opt-&gt;hin, &amp;cli_pic, i_frame + opt-&gt;i_seek ) )
            break;

        /* update status line (up to 1000 times per input file) */
        if( opt-&gt;b_progress &amp;&amp; i_frame_output )
            i_previous = print_status( i_start, i_previous, i_frame_output, param-&gt;i_frame_total, i_file, param, 2 * last_dts - prev_dts - first_dts );
    }
    /* Flush delayed frames */
    //输出编码器中剩余的帧
    //x264_encoder_delayed_frames()返回剩余的帧的个数
    while( !b_ctrl_c &amp;&amp; x264_encoder_delayed_frames( h ) )
    {
        prev_dts = last_dts;
        //编码
        //注意第3个参数为NULL
        i_frame_size = encode_frame( h, opt-&gt;hout, NULL, &amp;last_dts );
        if( i_frame_size &lt; 0 )
        {
            b_ctrl_c = 1; /* lie to exit the loop */
            retval = -1;
        }
        else if( i_frame_size )
        {
            i_file += i_frame_size;
            i_frame_output++;
            if( i_frame_output == 1 )
                first_dts = prev_dts = last_dts;
        }
        //输出一些统计信息
        if( opt-&gt;b_progress &amp;&amp; i_frame_output )
            i_previous = print_status( i_start, i_previous, i_frame_output, param-&gt;i_frame_total, i_file, param, 2 * last_dts - prev_dts - first_dts );
    }
fail:
    if( pts_warning_cnt &gt;= MAX_PTS_WARNING &amp;&amp; cli_log_level &lt; X264_LOG_DEBUG )
        x264_cli_log( &quot;x264&quot;, X264_LOG_WARNING, &quot;%d suppressed nonmonotonic pts warnings\n&quot;, pts_warning_cnt-MAX_PTS_WARNING );

    /* duration algorithm fails when only 1 frame is output */
    if( i_frame_output == 1 )
        duration = (double)param-&gt;i_fps_den / param-&gt;i_fps_num;
    else if( b_ctrl_c )
        duration = (double)(2 * last_dts - prev_dts - first_dts) * param-&gt;i_timebase_num / param-&gt;i_timebase_den;
    else
        duration = (double)(2 * largest_pts - second_largest_pts) * param-&gt;i_timebase_num / param-&gt;i_timebase_den;
    //计时
    i_end = x264_mdate();
    /* Erase progress indicator before printing encoding stats. */
    if( opt-&gt;b_progress )
        fprintf( stderr, &quot;                                                                               \r&quot; );
    //关闭编码器
    if( h )
        x264_encoder_close( h );
    fprintf( stderr, &quot;\n&quot; );

    if( b_ctrl_c )
        fprintf( stderr, &quot;aborted at input frame %d, output frame %d\n&quot;, opt-&gt;i_seek + i_frame, i_frame_output );
    //关闭输出文件
    cli_output.close_file( opt-&gt;hout, largest_pts, second_largest_pts );
    opt-&gt;hout = NULL;

    if( i_frame_output &gt; 0 )
    {
        double fps = (double)i_frame_output * (double)1000000 /
                     (double)( i_end - i_start );

        fprintf( stderr, &quot;encoded %d frames, %.2f fps, %.2f kb/s\n&quot;, i_frame_output, fps,
                 (double) i_file * 8 / ( 1000 * duration ) );
    }

    return retval;
}
</pre><br />从源代码可以梳理出来encode()的流程：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）调用x264_encoder_open()打开H.264编码器。<br />（2）调用x264_encoder_parameters()获得当前的参数集x264_param_t，用于后续步骤中的一些配置。<br />（3）调用输出格式（H.264裸流、FLV、mp4等）对应cli_output_t结构体的set_param()方法，为输出格式的封装器设定参数。其中参数源自于上一步骤得到的x264_param_t。<br />（4）如果不是在每个keyframe前面都增加SPS/PPS/SEI的话，就调用x264_encoder_headers()在整个码流前面加SPS/PPS/SEI。<br />（5）进入一个循环中进行一帧一帧的将YUV编码为H.264：<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用输入格式（YUV、Y4M等）对应的cli_vid_filter_t结构体get_frame()方法，获取一帧YUV数据。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)调用encode_frame()编码该帧YUV数据为H.264数据，并且输出出来。该函数内部调用x264_encoder_encode()完成编码工作，调用输出格式对应cli_output_t结构体的write_frame()完成了输出工作。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)调用输入格式（YUV、Y4M等）对应的cli_vid_filter_t结构体release_frame()方法，释放刚才获取的YUV数据。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">d)调用print_status()输出一些统计信息。</blockquote>（6）编码即将结束的时候，进入另一个循环，输出编码器中缓存的视频帧：<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)不再传递新的YUV数据，直接调用encode_frame()，将编码器中缓存的剩余几帧数据编码输出出来。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)调用print_status()输出一些统计信息。</blockquote>（7）调用x264_encoder_close()关闭H.264编码器。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"></blockquote><br />encode()的流程中涉及到libx264的几个关键的API，在这里暂时不做详细分析（后续文章中再进行补充）：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">x264_encoder_open()：打开H.264编码器。<br />x264_encoder_headers()：输出SPS/PPS/SEI。<br />x264_encoder_encode()：编码一帧数据。<br />x264_encoder_close()：关闭H.264编码器。</blockquote><br />此外上述流程中涉及到两个比较简单的函数：encode_frame()和print_status()。其中encode_frame()用于编码一帧数据，而print_status()用于输出一帧数据编码后的统计信息。下文记录一下这两个函数的定义。<br /><br /><h3>encode_frame()</h3>encode_frame()的定义如下。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_20_6562535" name="code" class="cpp">//编码1帧
static int encode_frame( x264_t *h, hnd_t hout, x264_picture_t *pic, int64_t *last_dts )
{
    x264_picture_t pic_out;
    x264_nal_t *nal;
    int i_nal;
    int i_frame_size = 0;
    //编码API
    //编码x264_picture_t为x264_nal_t
    i_frame_size = x264_encoder_encode( h, &amp;nal, &amp;i_nal, pic, &amp;pic_out );

    FAIL_IF_ERROR( i_frame_size &lt; 0, &quot;x264_encoder_encode failed\n&quot; );

    if( i_frame_size )
    {
    	//通过cli_output_t中的方法输出
    	//输出raw H.264流的话，等同于直接fwrite()
    	//其他封装格式，则还需进行一定的封装
        i_frame_size = cli_output.write_frame( hout, nal[0].p_payload, i_frame_size, &amp;pic_out );
        *last_dts = pic_out.i_dts;
    }

    return i_frame_size;
}
</pre><br />从源代码可以看出，encode_frame()内部调用x264_encoder_encode()完成编码工作，调用输出格式对应cli_output_t结构体的write_frame()完成了输出工作。其中有关cli_output_t结构体的知识将在后文中记录。<br /><br /><h3>print_status()</h3>print_status()的定义如下。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_21_3592004" name="code" class="cpp">//打印一些和时间有关的统计信息
static int64_t print_status( int64_t i_start, int64_t i_previous, int i_frame, int i_frame_total, int64_t i_file, x264_param_t *param, int64_t last_ts )
{
    char buf[200];
    int64_t i_time = x264_mdate();
    if( i_previous &amp;&amp; i_time - i_previous &lt; UPDATE_INTERVAL )
        return i_previous;
    int64_t i_elapsed = i_time - i_start;
    double fps = i_elapsed &gt; 0 ? i_frame * 1000000. / i_elapsed : 0;
    double bitrate;
    if( last_ts )
        bitrate = (double) i_file * 8 / ( (double) last_ts * 1000 * param-&gt;i_timebase_num / param-&gt;i_timebase_den );
    else
        bitrate = (double) i_file * 8 / ( (double) 1000 * param-&gt;i_fps_den / param-&gt;i_fps_num );
    if( i_frame_total )
    {
    	//形成输出的字符串
        int eta = i_elapsed * (i_frame_total - i_frame) / ((int64_t)i_frame * 1000000);
        sprintf( buf, &quot;x264 [%.1f%%] %d/%d frames, %.2f fps, %.2f kb/s, eta %d:%02d:%02d&quot;,
                 100. * i_frame / i_frame_total, i_frame, i_frame_total, fps, bitrate,
                 eta/3600, (eta/60)%60, eta%60 );
    }
    else
        sprintf( buf, &quot;x264 %d frames: %.2f fps, %.2f kb/s&quot;, i_frame, fps, bitrate );
    //输出到stderr
    fprintf( stderr, &quot;%s  \r&quot;, buf+5 );
    //设置到标题栏？
    x264_cli_set_console_title( buf );
    fflush( stderr ); // needed in windows
    return i_time;
}
</pre><br />print_status()的代码不再详细记录，它的输出效果如下图中红框中的文字。<br /><div style="text-align: center;"><img src="https://img-blog.csdn.net/20150508182010247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><p><br /></p><p><br /></p><h2>X264控制台程序中和输入输出相关的结构体</h2>在x264控制台程序中有3个和输入输出相关的结构体：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">cli_output_t：输出格式对应的结构体。输出格式一般为H.264裸流、FLV、MP4等。<br />cli_input_t：输入格式对应的结构体。输入格式一般为纯YUV像素数据，Y4M格式数据等。<br />cli_vid_filter_t：输入格式滤镜结构体。滤镜可以对输入数据做一些简单的处理，例如拉伸、裁剪等等（当然滤镜也可以不作任何处理，直接读取输入数据）。</blockquote>在x264的编码过程中，调用cli_vid_filter_t结构体的get_frame()读取YUV数据，调用cli_output_t的write_frame()写入数据。下面简单分析一下它们之间的关系。<br /><br /><h3>cli_output_t</h3>x264项目中和cli_output_t结构体相关的源代码都位于根目录的output文件夹下。cli_output_t的定义位于output\output.h，如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_22_6227409" name="code" class="cpp">typedef struct
{
    int (*open_file)( char *psz_filename, hnd_t *p_handle, cli_output_opt_t *opt );
    int (*set_param)( hnd_t handle, x264_param_t *p_param );
    int (*write_headers)( hnd_t handle, x264_nal_t *p_nal );
    int (*write_frame)( hnd_t handle, uint8_t *p_nal, int i_size, x264_picture_t *p_picture );
    int (*close_file)( hnd_t handle, int64_t largest_pts, int64_t second_largest_pts );
} cli_output_t;

extern const cli_output_t raw_output;
extern const cli_output_t mkv_output;
extern const cli_output_t mp4_output;
extern const cli_output_t flv_output;
</pre><br />从源代码中可以看出，cli_output_t中一共包含了open_file()，set_param()，write_headers()，write_frame()，close_file()五个接口。在x264中有raw_output，mkv_output，mp4_output，flv_output这几个cli_output_t结构体，分别对应H.264裸流，MKV，MP4，FLV格式。下面举例看两个结构体：raw_output和flv_output。<br /><br /><strong>raw_output（H.264裸流的cli_output_t结构体）</strong><br />raw_output的定义位于output\raw.c，该文件内容如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_23_8622052" name="code" class="cpp">#include &quot;output.h&quot;

static int open_file( char *psz_filename, hnd_t *p_handle, cli_output_opt_t *opt )
{
    if( !strcmp( psz_filename, &quot;-&quot; ) )
        *p_handle = stdout;
    else if( !(*p_handle = x264_fopen( psz_filename, &quot;w+b&quot; )) )
        return -1;

    return 0;
}

static int set_param( hnd_t handle, x264_param_t *p_param )
{
    return 0;
}

static int write_headers( hnd_t handle, x264_nal_t *p_nal )
{
    int size = p_nal[0].i_payload + p_nal[1].i_payload + p_nal[2].i_payload;

    if( fwrite( p_nal[0].p_payload, size, 1, (FILE*)handle ) )
        return size;
    return -1;
}

static int write_frame( hnd_t handle, uint8_t *p_nalu, int i_size, x264_picture_t *p_picture )
{
    if( fwrite( p_nalu, i_size, 1, (FILE*)handle ) )
        return i_size;
    return -1;
}

static int close_file( hnd_t handle, int64_t largest_pts, int64_t second_largest_pts )
{
    if( !handle || handle == stdout )
        return 0;

    return fclose( (FILE*)handle );
}

const cli_output_t raw_output = { open_file, set_param, write_headers, write_frame, close_file };
</pre><br />可以看出raw_output中的函数定义都比较简单，只是封装了fwrite()，fclose()等函数。<br /><br /><strong>flv_output（FLV格式的cli_output_t结构体）</strong><br />flv_output的定义位于output\flv.c，如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_24_4289101" name="code" class="cpp">const cli_output_t flv_output = { open_file, set_param, write_headers, write_frame, close_file };</pre>该文件内容比较多，只举例看一下其中的两个函数：open_file()和write_frame()。<br /><br /><strong>open_file()</strong><br />flv_output 中的open_file()的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_25_5288304" name="code" class="cpp">static int write_header( flv_buffer *c )
{
    flv_put_tag( c, &quot;FLV&quot; ); // Signature
    flv_put_byte( c, 1 );    // Version
    flv_put_byte( c, 1 );    // Video Only
    flv_put_be32( c, 9 );    // DataOffset
    flv_put_be32( c, 0 );    // PreviousTagSize0

    return flv_flush_data( c );
}

static int open_file( char *psz_filename, hnd_t *p_handle, cli_output_opt_t *opt )
{
    *p_handle = NULL;
    flv_hnd_t *p_flv = calloc( 1, sizeof(flv_hnd_t) );
    if( !p_flv )
        return -1;

    p_flv-&gt;b_dts_compress = opt-&gt;use_dts_compress;

    p_flv-&gt;c = flv_create_writer( psz_filename );
    if( !p_flv-&gt;c )
        return -1;

    CHECK( write_header( p_flv-&gt;c ) );
    *p_handle = p_flv;

    return 0;
}</pre>可以看出flv_output 中的open_file()中完成了FLV封装格式文件头的创建。<br /><br /><strong>write_frame()</strong><br />flv_output 中的write_frame()的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_26_3463608" name="code" class="cpp">static int write_frame( hnd_t handle, uint8_t *p_nalu, int i_size, x264_picture_t *p_picture )
{
    flv_hnd_t *p_flv = handle;
    flv_buffer *c = p_flv-&gt;c;

#define convert_timebase_ms( timestamp, timebase ) (int64_t)((timestamp) * (timebase) * 1000 + 0.5)

    if( !p_flv-&gt;i_framenum )
    {
        p_flv-&gt;i_delay_time = p_picture-&gt;i_dts * -1;
        if( !p_flv-&gt;b_dts_compress &amp;&amp; p_flv-&gt;i_delay_time )
            x264_cli_log( &quot;flv&quot;, X264_LOG_INFO, &quot;initial delay %&quot;PRId64&quot; ms\n&quot;,
                          convert_timebase_ms( p_picture-&gt;i_pts + p_flv-&gt;i_delay_time, p_flv-&gt;d_timebase ) );
    }

    int64_t dts;
    int64_t cts;
    int64_t offset;

    if( p_flv-&gt;b_dts_compress )
    {
        if( p_flv-&gt;i_framenum == 1 )
            p_flv-&gt;i_init_delta = convert_timebase_ms( p_picture-&gt;i_dts + p_flv-&gt;i_delay_time, p_flv-&gt;d_timebase );
        dts = p_flv-&gt;i_framenum &gt; p_flv-&gt;i_delay_frames
            ? convert_timebase_ms( p_picture-&gt;i_dts, p_flv-&gt;d_timebase )
            : p_flv-&gt;i_framenum * p_flv-&gt;i_init_delta / (p_flv-&gt;i_delay_frames + 1);
        cts = convert_timebase_ms( p_picture-&gt;i_pts, p_flv-&gt;d_timebase );
    }
    else
    {
        dts = convert_timebase_ms( p_picture-&gt;i_dts + p_flv-&gt;i_delay_time, p_flv-&gt;d_timebase );
        cts = convert_timebase_ms( p_picture-&gt;i_pts + p_flv-&gt;i_delay_time, p_flv-&gt;d_timebase );
    }
    offset = cts - dts;

    if( p_flv-&gt;i_framenum )
    {
        if( p_flv-&gt;i_prev_dts == dts )
            x264_cli_log( &quot;flv&quot;, X264_LOG_WARNING, &quot;duplicate DTS %&quot;PRId64&quot; generated by rounding\n&quot;
                          &quot;               decoding framerate cannot exceed 1000fps\n&quot;, dts );
        if( p_flv-&gt;i_prev_cts == cts )
            x264_cli_log( &quot;flv&quot;, X264_LOG_WARNING, &quot;duplicate CTS %&quot;PRId64&quot; generated by rounding\n&quot;
                          &quot;               composition framerate cannot exceed 1000fps\n&quot;, cts );
    }
    p_flv-&gt;i_prev_dts = dts;
    p_flv-&gt;i_prev_cts = cts;

    // A new frame - write packet header
    flv_put_byte( c, FLV_TAG_TYPE_VIDEO );
    flv_put_be24( c, 0 ); // calculated later
    flv_put_be24( c, dts );
    flv_put_byte( c, dts &gt;&gt; 24 );
    flv_put_be24( c, 0 );

    p_flv-&gt;start = c-&gt;d_cur;
    flv_put_byte( c, p_picture-&gt;b_keyframe ? FLV_FRAME_KEY : FLV_FRAME_INTER );
    flv_put_byte( c, 1 ); // AVC NALU
    flv_put_be24( c, offset );

    if( p_flv-&gt;sei )
    {
        flv_append_data( c, p_flv-&gt;sei, p_flv-&gt;sei_len );
        free( p_flv-&gt;sei );
        p_flv-&gt;sei = NULL;
    }
    flv_append_data( c, p_nalu, i_size );

    unsigned length = c-&gt;d_cur - p_flv-&gt;start;
    flv_rewrite_amf_be24( c, length, p_flv-&gt;start - 10 );
    flv_put_be32( c, 11 + length ); // Last tag size
    CHECK( flv_flush_data( c ) );

    p_flv-&gt;i_framenum++;

    return i_size;
}
</pre><br />flv_output 中的可以看出write_frame()中完成了FLV封装格式中一个Tag单元的创建。<br /><br /><h3>cli_input_t</h3>x264项目中和cli_input_t结构体相关的源代码都位于根目录的input文件夹下。cli_input_t的定义位于input\input.h，如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_27_9479320" name="code" class="cpp">typedef struct
{
    int (*open_file)( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt );
    int (*picture_alloc)( cli_pic_t *pic, int csp, int width, int height );
    int (*read_frame)( cli_pic_t *pic, hnd_t handle, int i_frame );
    int (*release_frame)( cli_pic_t *pic, hnd_t handle );
    void (*picture_clean)( cli_pic_t *pic );
    int (*close_file)( hnd_t handle );
} cli_input_t;

extern const cli_input_t raw_input;
extern const cli_input_t y4m_input;
extern const cli_input_t avs_input;
extern const cli_input_t lavf_input;
extern const cli_input_t ffms_input;
</pre><br />从源代码中可以看出，cli_input_t中一共包含了open_file()，picture_alloc()，read_frame()，release_frame()，picture_clean()，close_file()六个接口。在x264中有raw_input，y4m_input，avs_input，lavf_input，ffms_input这几个cli_output_t结构体，分别对应H.264裸流，Y4M，AVS，LAVF，FFMS格式（后几种没有接触过）。下面举例看两个结构体：raw_input和y4m_input。<br /><br /><strong>raw_input（纯YUV像素数据的cli_input_t结构体）</strong><br />raw_input的定义位于input\raw.c，该文件内容如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_28_4066574" name="code" class="cpp">#include &quot;input.h&quot;
#define FAIL_IF_ERROR( cond, ... ) FAIL_IF_ERR( cond, &quot;raw&quot;, __VA_ARGS__ )

typedef struct
{
    FILE *fh;
    int next_frame;
    uint64_t plane_size[4];
    uint64_t frame_size;
    int bit_depth;
} raw_hnd_t;

//打开raw YUV格式文件
static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
{
    raw_hnd_t *h = calloc( 1, sizeof(raw_hnd_t) );
    if( !h )
        return -1;

    if( !opt-&gt;resolution )
    {
    	//如果没有设置分辨率
    	//尝试从文件名中解析分辨率
        /* try to parse the file name */
        for( char *p = psz_filename; *p; p++ )
            if( *p &gt;= '0' &amp;&amp; *p &lt;= '9' &amp;&amp; sscanf( p, &quot;%dx%d&quot;, &amp;info-&gt;width, &amp;info-&gt;height ) == 2 )
                break;
    }
    else
        sscanf( opt-&gt;resolution, &quot;%dx%d&quot;, &amp;info-&gt;width, &amp;info-&gt;height );
    //没有分辨率信息的话，会弹出错误信息
    FAIL_IF_ERROR( !info-&gt;width || !info-&gt;height, &quot;raw input requires a resolution.\n&quot; )
    //设置颜色空间
    if( opt-&gt;colorspace )
    {
        for( info-&gt;csp = X264_CSP_CLI_MAX-1; info-&gt;csp &gt; X264_CSP_NONE; info-&gt;csp-- )
        {
            if( x264_cli_csps[info-&gt;csp].name &amp;&amp; !strcasecmp( x264_cli_csps[info-&gt;csp].name, opt-&gt;colorspace ) )
                break;
        }
        FAIL_IF_ERROR( info-&gt;csp == X264_CSP_NONE, &quot;unsupported colorspace `%s'\n&quot;, opt-&gt;colorspace );
    }
    else /* default */
        info-&gt;csp = X264_CSP_I420;//默认为YUV420P
    //颜色位深
    h-&gt;bit_depth = opt-&gt;bit_depth;
    FAIL_IF_ERROR( h-&gt;bit_depth &lt; 8 || h-&gt;bit_depth &gt; 16, &quot;unsupported bit depth `%d'\n&quot;, h-&gt;bit_depth );
    if( h-&gt;bit_depth &gt; 8 )
        info-&gt;csp |= X264_CSP_HIGH_DEPTH;

    if( !strcmp( psz_filename, &quot;-&quot; ) )
        h-&gt;fh = stdin;  //从管道输入
    else
        h-&gt;fh = x264_fopen( psz_filename, &quot;rb&quot; );  //打开文件
    if( h-&gt;fh == NULL )
        return -1;

    info-&gt;thread_safe = 1;
    info-&gt;num_frames  = 0;
    info-&gt;vfr         = 0;

    const x264_cli_csp_t *csp = x264_cli_get_csp( info-&gt;csp );
    for( int i = 0; i &lt; csp-&gt;planes; i++ )
    {
        h-&gt;plane_size[i] = x264_cli_pic_plane_size( info-&gt;csp, info-&gt;width, info-&gt;height, i );
        h-&gt;frame_size += h-&gt;plane_size[i];
        /* x264_cli_pic_plane_size returns the size in bytes, we need the value in pixels from here on */
        h-&gt;plane_size[i] /= x264_cli_csp_depth_factor( info-&gt;csp );
    }

    if( x264_is_regular_file( h-&gt;fh ) )
    {
        fseek( h-&gt;fh, 0, SEEK_END );
        uint64_t size = ftell( h-&gt;fh );
        fseek( h-&gt;fh, 0, SEEK_SET );
        info-&gt;num_frames = size / h-&gt;frame_size;
    }

    *p_handle = h;
    return 0;
}

//读取一帧数据-内部
static int read_frame_internal( cli_pic_t *pic, raw_hnd_t *h, int bit_depth_uc )
{
    int error = 0;
    int pixel_depth = x264_cli_csp_depth_factor( pic-&gt;img.csp );
    //一个分量一个分量读
    for( int i = 0; i &lt; pic-&gt;img.planes &amp;&amp; !error; i++ )
    {
    	//fread()读取
        error |= fread( pic-&gt;img.plane[i], pixel_depth, h-&gt;plane_size[i], h-&gt;fh ) != h-&gt;plane_size[i];
        if( bit_depth_uc )
        {
            /* upconvert non 16bit high depth planes to 16bit using the same
             * algorithm as used in the depth filter. */
            uint16_t *plane = (uint16_t*)pic-&gt;img.plane[i];
            uint64_t pixel_count = h-&gt;plane_size[i];
            int lshift = 16 - h-&gt;bit_depth;
            for( uint64_t j = 0; j &lt; pixel_count; j++ )
                plane[j] = plane[j] &lt;&lt; lshift;
        }
    }
    return error;
}
//读取一帧数据
static int read_frame( cli_pic_t *pic, hnd_t handle, int i_frame )
{
    raw_hnd_t *h = handle;

    if( i_frame &gt; h-&gt;next_frame )
    {
        if( x264_is_regular_file( h-&gt;fh ) )
            fseek( h-&gt;fh, i_frame * h-&gt;frame_size, SEEK_SET );  //fseek()。偏移量=帧序号*帧大小。
        else
            while( i_frame &gt; h-&gt;next_frame )
            {
            	//读取一帧数据-内部
                if( read_frame_internal( pic, h, 0 ) )
                    return -1;
                h-&gt;next_frame++;
            }
    }

    if( read_frame_internal( pic, h, h-&gt;bit_depth &amp; 7 ) )
        return -1;

    h-&gt;next_frame = i_frame+1;
    return 0;
}

//关闭文件
static int close_file( hnd_t handle )
{
    raw_hnd_t *h = handle;
    if( !h || !h-&gt;fh )
        return 0;
    //fclose()关闭文件
    fclose( h-&gt;fh );
    free( h );
    return 0;
}
//raw格式对应的数组
const cli_input_t raw_input = { open_file, x264_cli_pic_alloc, read_frame, NULL, x264_cli_pic_clean, close_file };
</pre><br /><p>从源代码中可以看出，raw_input 中的open_file()函数在打开YUV像素数据的时候，会首先判断是否设置了宽和高（YUV是纯像素数据，没有宽和高信息），如果没有设置，则会尝试从文件路径中解析宽和高信息。如果成功完成上述步骤，open_file()就会调用x264_fopen()打开输入文件。其他的函数在源代码中都写了注释，就不再重复记录了。</p><p><br /></p><strong>y4m_input（Y4M格式的cli_input_t结构体）</strong><br />y4m_input的定义位于input\y4m.c，如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_29_3321673" name="code" class="cpp">const cli_input_t y4m_input = { open_file, x264_cli_pic_alloc, read_frame, NULL, x264_cli_pic_clean, close_file };</pre>该文件内容较多，不再进行详细分析。在这里看一个打开文件的函数open_file()。该函数的定义如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_30_4811244" name="code" class="cpp">typedef struct
{
    FILE *fh;
    int next_frame;
    int seq_header_len;
    int frame_header_len;
    uint64_t frame_size;
    uint64_t plane_size[3];
    int bit_depth;
} y4m_hnd_t;

#define Y4M_MAGIC &quot;YUV4MPEG2&quot;
#define MAX_YUV4_HEADER 80
#define Y4M_FRAME_MAGIC &quot;FRAME&quot;
#define MAX_FRAME_HEADER 80

static int parse_csp_and_depth( char *csp_name, int *bit_depth )
{
    int csp    = X264_CSP_MAX;

    /* Set colorspace from known variants */
    if( !strncmp( &quot;420&quot;, csp_name, 3 ) )
        csp = X264_CSP_I420;
    else if( !strncmp( &quot;422&quot;, csp_name, 3 ) )
        csp = X264_CSP_I422;
    else if( !strncmp( &quot;444&quot;, csp_name, 3 ) &amp;&amp; strncmp( &quot;444alpha&quot;, csp_name, 8 ) ) // only accept alphaless 4:4:4
        csp = X264_CSP_I444;

    /* Set high bit depth from known extensions */
    if( sscanf( csp_name, &quot;%*d%*[pP]%d&quot;, bit_depth ) != 1 )
        *bit_depth = 8;

    return csp;
}

static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
{
    y4m_hnd_t *h = malloc( sizeof(y4m_hnd_t) );
    int i;
    uint32_t n, d;
    char header[MAX_YUV4_HEADER+10];
    char *tokend, *header_end;
    int colorspace = X264_CSP_NONE;
    int alt_colorspace = X264_CSP_NONE;
    int alt_bit_depth  = 8;
    if( !h )
        return -1;

    h-&gt;next_frame = 0;
    info-&gt;vfr = 0;

    if( !strcmp( psz_filename, &quot;-&quot; ) )
        h-&gt;fh = stdin;
    else
        h-&gt;fh = x264_fopen(psz_filename, &quot;rb&quot;);
    if( h-&gt;fh == NULL )
        return -1;

    h-&gt;frame_header_len = strlen( Y4M_FRAME_MAGIC )+1;

    /* Read header */
    //解析Y4M格式的文件头
    for( i = 0; i &lt; MAX_YUV4_HEADER; i++ )
    {
        header[i] = fgetc( h-&gt;fh );
        if( header[i] == '\n' )
        {
            /* Add a space after last option. Makes parsing &quot;444&quot; vs
               &quot;444alpha&quot; easier. */
            header[i+1] = 0x20;
            header[i+2] = 0;
            break;
        }
    }
    if( i == MAX_YUV4_HEADER || strncmp( header, Y4M_MAGIC, strlen( Y4M_MAGIC ) ) )
        return -1;

    /* Scan properties */
    header_end = &amp;header[i+1]; /* Include space */
    h-&gt;seq_header_len = i+1;
    for( char *tokstart = &amp;header[strlen( Y4M_MAGIC )+1]; tokstart &lt; header_end; tokstart++ )
    {
        if( *tokstart == 0x20 )
            continue;
        switch( *tokstart++ )
        {
            case 'W': /* Width. Required. */
                info-&gt;width = strtol( tokstart, &amp;tokend, 10 );
                tokstart=tokend;
                break;
            case 'H': /* Height. Required. */
                info-&gt;height = strtol( tokstart, &amp;tokend, 10 );
                tokstart=tokend;
                break;
            case 'C': /* Color space */
                colorspace = parse_csp_and_depth( tokstart, &amp;h-&gt;bit_depth );
                tokstart = strchr( tokstart, 0x20 );
                break;
            case 'I': /* Interlace type */
                switch( *tokstart++ )
                {
                    case 't':
                        info-&gt;interlaced = 1;
                        info-&gt;tff = 1;
                        break;
                    case 'b':
                        info-&gt;interlaced = 1;
                        info-&gt;tff = 0;
                        break;
                    case 'm':
                        info-&gt;interlaced = 1;
                        break;
                    //case '?':
                    //case 'p':
                    default:
                        break;
                }
                break;
            case 'F': /* Frame rate - 0:0 if unknown */
                if( sscanf( tokstart, &quot;%u:%u&quot;, &amp;n, &amp;d ) == 2 &amp;&amp; n &amp;&amp; d )
                {
                    x264_reduce_fraction( &amp;n, &amp;d );
                    info-&gt;fps_num = n;
                    info-&gt;fps_den = d;
                }
                tokstart = strchr( tokstart, 0x20 );
                break;
            case 'A': /* Pixel aspect - 0:0 if unknown */
                /* Don't override the aspect ratio if sar has been explicitly set on the commandline. */
                if( sscanf( tokstart, &quot;%u:%u&quot;, &amp;n, &amp;d ) == 2 &amp;&amp; n &amp;&amp; d )
                {
                    x264_reduce_fraction( &amp;n, &amp;d );
                    info-&gt;sar_width  = n;
                    info-&gt;sar_height = d;
                }
                tokstart = strchr( tokstart, 0x20 );
                break;
            case 'X': /* Vendor extensions */
                if( !strncmp( &quot;YSCSS=&quot;, tokstart, 6 ) )
                {
                    /* Older nonstandard pixel format representation */
                    tokstart += 6;
                    alt_colorspace = parse_csp_and_depth( tokstart, &amp;alt_bit_depth );
                }
                tokstart = strchr( tokstart, 0x20 );
                break;
        }
    }

    if( colorspace == X264_CSP_NONE )
    {
        colorspace   = alt_colorspace;
        h-&gt;bit_depth = alt_bit_depth;
    }

    // default to 8bit 4:2:0 if nothing is specified
    if( colorspace == X264_CSP_NONE )
    {
        colorspace    = X264_CSP_I420;
        h-&gt;bit_depth  = 8;
    }

    FAIL_IF_ERROR( colorspace &lt;= X264_CSP_NONE || colorspace &gt;= X264_CSP_MAX, &quot;colorspace unhandled\n&quot; )
    FAIL_IF_ERROR( h-&gt;bit_depth &lt; 8 || h-&gt;bit_depth &gt; 16, &quot;unsupported bit depth `%d'\n&quot;, h-&gt;bit_depth );

    info-&gt;thread_safe = 1;
    info-&gt;num_frames  = 0;
    info-&gt;csp         = colorspace;
    h-&gt;frame_size     = h-&gt;frame_header_len;

    if( h-&gt;bit_depth &gt; 8 )
        info-&gt;csp |= X264_CSP_HIGH_DEPTH;

    const x264_cli_csp_t *csp = x264_cli_get_csp( info-&gt;csp );

    for( i = 0; i &lt; csp-&gt;planes; i++ )
    {
        h-&gt;plane_size[i] = x264_cli_pic_plane_size( info-&gt;csp, info-&gt;width, info-&gt;height, i );
        h-&gt;frame_size += h-&gt;plane_size[i];
        /* x264_cli_pic_plane_size returns the size in bytes, we need the value in pixels from here on */
        h-&gt;plane_size[i] /= x264_cli_csp_depth_factor( info-&gt;csp );
    }

    /* Most common case: frame_header = &quot;FRAME&quot; */
    if( x264_is_regular_file( h-&gt;fh ) )
    {
        uint64_t init_pos = ftell( h-&gt;fh );
        fseek( h-&gt;fh, 0, SEEK_END );
        uint64_t i_size = ftell( h-&gt;fh );
        fseek( h-&gt;fh, init_pos, SEEK_SET );
        info-&gt;num_frames = (i_size - h-&gt;seq_header_len) / h-&gt;frame_size;
    }

    *p_handle = h;
    return 0;
}
</pre><br />从源代码可以看出，y4m_input中的open_file()完成了Y4M文件的打开和文件头解析的功能。<br /><br /><h3>cli_vid_filter_t</h3>x264项目中和cli_vid_filter_t结构体相关的源代码都位于根目录的filters文件夹下。cli_vid_filter_t的定义位于filters\video\video.h，如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_31_9365478" name="code" class="cpp">struct cli_vid_filter_t
{
    /* name of the filter */
    const char *name;
    /* help: a short message on what the filter does and how to use it.
     * this should only be implemented by filters directly accessible by the user */
    void (*help)( int longhelp );
    /* init: initializes the filter given the input clip properties and parameter to adjust them as necessary
     * with the given options provided by the user.
     * returns 0 on success, nonzero on error. */
    int (*init)( hnd_t *handle, cli_vid_filter_t *filter, video_info_t *info, x264_param_t *param, char *opt_string );
    /* get_frame: given the storage for the output frame and desired frame number, generate the frame accordingly.
     * the image data returned by get_frame should be treated as const and not be altered.
     * returns 0 on success, nonzero on error. */
    int (*get_frame)( hnd_t handle, cli_pic_t *output, int frame );
    /* release_frame: frame is done being used and is signaled for cleanup.
     * returns 0 on succeess, nonzero on error. */
    int (*release_frame)( hnd_t handle, cli_pic_t *pic, int frame );
    /* free: run filter cleanup procedures. */
    void (*free)( hnd_t handle );
    /* next registered filter, unused by filters themselves */
    cli_vid_filter_t *next;
};
</pre><br />从源代码中可以看出，cli_vid_filter_t中一共包含了help()，init()，get_frame()，release_frame()，free()几个接口。下面举例看两个Filter结构体：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">source_filter：不作任何处理。<br />resize_filter：拉伸。</blockquote><br /><strong>source_filter（没有功能的cli_vid_filter_t结构体）</strong><br />source_filter的定义位于filters\video\source.c，该文件内容如下所示。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_32_8445853" name="code" class="cpp">#include &quot;video.h&quot;

/* This filter converts the demuxer API into the filtering API for video frames.
 * Backseeking is prohibited here as not all demuxers are capable of doing so. */

typedef struct
{
    cli_pic_t pic;
    hnd_t hin;
    int cur_frame;
} source_hnd_t;

cli_vid_filter_t source_filter;

static int init( hnd_t *handle, cli_vid_filter_t *filter, video_info_t *info, x264_param_t *param, char *opt_string )
{
    source_hnd_t *h = calloc( 1, sizeof(source_hnd_t) );
    if( !h )
        return -1;
    h-&gt;cur_frame = -1;

    if( cli_input.picture_alloc( &amp;h-&gt;pic, info-&gt;csp, info-&gt;width, info-&gt;height ) )
        return -1;

    h-&gt;hin = *handle;
    *handle = h;
    *filter = source_filter;

    return 0;
}

static int get_frame( hnd_t handle, cli_pic_t *output, int frame )
{
    source_hnd_t *h = handle;
    /* do not allow requesting of frames from before the current position */
    if( frame &lt;= h-&gt;cur_frame || cli_input.read_frame( &amp;h-&gt;pic, h-&gt;hin, frame ) )
        return -1;
    h-&gt;cur_frame = frame;
    *output = h-&gt;pic;
    return 0;
}

static int release_frame( hnd_t handle, cli_pic_t *pic, int frame )
{
    source_hnd_t *h = handle;
    if( cli_input.release_frame &amp;&amp; cli_input.release_frame( &amp;h-&gt;pic, h-&gt;hin ) )
        return -1;
    return 0;
}

static void free_filter( hnd_t handle )
{
    source_hnd_t *h = handle;
    cli_input.picture_clean( &amp;h-&gt;pic );
    cli_input.close_file( h-&gt;hin );
    free( h );
}

cli_vid_filter_t source_filter = { &quot;source&quot;, NULL, init, get_frame, release_frame, free_filter, NULL };
</pre><br />从源代码中可以看出，source_filter的get_frame()直接调用了cli_input_t的read_frame()；而它的release_frame()也是直接调用了cli_input_t的release_frame()。简而言之，source_filter相当于是一个cli_input_t。<br /><br /><strong>resize_filter（拉伸功能对应的cli_vid_filter_t结构体）</strong><br />resize_filter的定义位于filters\video\resize.c，该结构体定义如下。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_33_6031730" name="code" class="cpp">cli_vid_filter_t resize_filter = { NAME, help, init, get_frame, release_frame, free_filter, NULL };</pre>由于resize_filter涉及到的代码比较多，在这里仅看一下它的get_frame()的定义。<br /><pre code_snippet_id="662196" snippet_file_name="blog_20150508_34_8110728" name="code" class="cpp">static int get_frame( hnd_t handle, cli_pic_t *output, int frame )
{
    resizer_hnd_t *h = handle;
    if( h-&gt;prev_filter.get_frame( h-&gt;prev_hnd, output, frame ) )
        return -1;
    if( h-&gt;variable_input &amp;&amp; check_resizer( h, output ) )
        return -1;
    h-&gt;working = 1;
    if( h-&gt;pre_swap_chroma )
        XCHG( uint8_t*, output-&gt;img.plane[1], output-&gt;img.plane[2] );
    if( h-&gt;ctx )
    {
        sws_scale( h-&gt;ctx, (const uint8_t* const*)output-&gt;img.plane, output-&gt;img.stride,
                   0, output-&gt;img.height, h-&gt;buffer.img.plane, h-&gt;buffer.img.stride );
        output-&gt;img = h-&gt;buffer.img; /* copy img data */
    }
    else
        output-&gt;img.csp = h-&gt;dst_csp;
    if( h-&gt;post_swap_chroma )
        XCHG( uint8_t*, output-&gt;img.plane[1], output-&gt;img.plane[2] );

    return 0;
}
</pre><br />可以看出resize_filter中调用了libswscale类库中的sws_scale()对图像完成了拉伸工作。<br /><span style="font-family:FangSong_GB2312;">注：拉伸滤镜需要libswscale类库的支持。</span><br /><br /><br />至此cli_output_t，cli_input_t，cli_vid_filter_t这3个在x264中与输入输出有关的结构体的源代码就分析完毕了。有关x264命令行工具的源代码分析工作也就做完了。下一篇文章开始对libx264内部的源代码进行分析。<br /><br /><br /><br /><span style="color:#990000;"><strong>雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</strong></span><br /><br /><br /><br /><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/45583217		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=x264&t=blog" target="_blank">x264						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=H.264&t=blog" target="_blank">H.264						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=视频编码&t=blog" target="_blank">视频编码						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=源代码&t=blog" target="_blank">源代码						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=YUV&t=blog" target="_blank">YUV						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/2619503"  target="_blank">x264						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/osmedia.html" target="_blank">开源多媒体项目源代码分析</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45583217#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/scg881008/article/details/7191599" target="_blank" strategy="BlogCommendFromBaidu_0">
				<em>X264</em>使用介绍  命令行设置			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/scg881008/article/details/7191599" target="_blank" >
				2011-06-10 18:27:43|  分类： H264|字号 订阅






命令行界面的<em>x264</em>

我们下载到的<em>x264</em>.exe是一个<em>命令行工具</em>，不需要安装，随便放在哪里都...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/scg881008" title="scg881008" target="_blank">
					<img src="https://avatar.csdn.net/B/B/C/3_scg881008.jpg" alt="scg881008" class="avatar-pic">
					<span class="name">scg881008</span>
				</a>
			</p>
			<p>
				<span class="date">2012-01-10 17:19:59</span>
			</p>
			<p>
				<span class="read-num">阅读数：9164</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/xiaojun111111/article/details/50765036" target="_blank" strategy="BlogCommendFromBaidu_1">
				<em>x264</em>命令行参数解释			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/xiaojun111111/article/details/50765036" target="_blank" >
				词汇翻译：
macroblock：宏区块。是一种图像压缩的术语。
宏区块是运动预测的基本单位，一张完整的图像（frame）通常会被切割成几个宏区块。h.264 的宏区块大小是可变的，常用 16x16 ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/xiaojun111111" title="xiaojun111111" target="_blank">
					<img src="https://avatar.csdn.net/1/B/8/3_xiaojun111111.jpg" alt="xiaojun111111" class="avatar-pic">
					<span class="name">xiaojun111111</span>
				</a>
			</p>
			<p>
				<span class="date">2016-02-29 13:55:01</span>
			</p>
			<p>
				<span class="read-num">阅读数：1816</span>
			</p>
		</div>
	</div>
								<div class="recommend-item-box recommend-ad-box" id="ad1"></div>
				<script>
				  var width = $("div.recommend-box").outerWidth() - 48;
					NEWS_FEED({
						w: width,
						h : 90,
						showid : 'GNKXx7',
						placeholderId: "ad1",
						inject : 'define',
						define : {
							imagePosition : 'right',
							imageBorderRadius : 0,
							imageWidth: 120,
							imageHeight: 90,
							imageFill : 'clip',
							displayImage : true,
							displayTitle : true,
							titleFontSize: 20,
							titleFontColor: '#333',
							titleFontFamily : 'Microsoft Yahei',
							titleFontWeight: 'bold',
							titlePaddingTop : 0,
							titlePaddingRight : 0,
							titlePaddingBottom : 10,
							titlePaddingLeft : 0,
							displayDesc : true,
							descFontSize: 14,
							descFontColor: '#6b6b6b',
							descFontFamily : 'Microsoft Yahei',
							paddingTop : 0,
							paddingRight : 0,
							paddingBottom : 0,
							paddingLeft : 0,
							backgroundColor: '#fff',
							hoverColor: '#ca0c16'
						}
					})
				</script>

			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/heihei36/article/details/8004902" target="_blank" strategy="BlogCommendFromBaidu_2">
				<em>x264</em>命令行格式转化方法			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/heihei36/article/details/8004902" target="_blank" >
				输入命令：<em>x264</em> -o xxx.mkv xxx.yuv 352x288
提示错误：
raw [error]: raw input requires a resolution.
<em>x264</em> [er...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/heihei36" title="heihei36" target="_blank">
					<img src="https://avatar.csdn.net/3/1/B/3_heihei36.jpg" alt="heihei36" class="avatar-pic">
					<span class="name">heihei36</span>
				</a>
			</p>
			<p>
				<span class="date">2012-09-21 16:29:27</span>
			</p>
			<p>
				<span class="read-num">阅读数：1452</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/Qingxinguayu/article/details/1642435" target="_blank" strategy="BlogCommendFromBaidu_3">
				<em>x264</em>命令行参数解释 			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/Qingxinguayu/article/details/1642435" target="_blank" >
				本文对应的是<em>x264</em>命令行模式，VFW方式也用相同的参数，不过是图形界面，可以自己找对应的英文。    使用格式：<em>x264</em> 默认选项 -o 输出文件 输入文件 [长x宽]输入支持格式：RAW/y4m/...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/Qingxinguayu" title="Qingxinguayu" target="_blank">
					<img src="https://avatar.csdn.net/6/9/0/3_qingxinguayu.jpg" alt="Qingxinguayu" class="avatar-pic">
					<span class="name">Qingxinguayu</span>
				</a>
			</p>
			<p>
				<span class="date">2007-06-07 15:00:00</span>
			</p>
			<p>
				<span class="read-num">阅读数：1713</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/szfhy/article/details/65443946" target="_blank" strategy="BlogCommendFromBaidu_4">
				<em>x264</em>命令行解析			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/szfhy/article/details/65443946" target="_blank" >
				./<em>x264</em> 
--bitrate 1000      //设置bitrate为1000Kbps
--fps 30                //设置fps为30
-I 30        ...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/szfhy" title="szfhy" target="_blank">
					<img src="https://avatar.csdn.net/E/D/5/3_szfhy.jpg" alt="szfhy" class="avatar-pic">
					<span class="name">szfhy</span>
				</a>
			</p>
			<p>
				<span class="date">2017-03-23 15:10:43</span>
			</p>
			<p>
				<span class="read-num">阅读数：3606</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/DiffenYu/article/details/8246991" target="_blank" strategy="BlogCommendFromBaidu_6">
				<em>x264</em>.exe下载使用			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/DiffenYu/article/details/8246991" target="_blank" >
				为了看看<em>x264</em>.exe编出的.264文件，网上找了下，在http://<em>x264</em>.nl/上有针对32bit和64bit的<em>x264</em>encoder,decoder的镜像，还有各种gui版本
    对于...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/DiffenYu" title="DiffenYu" target="_blank">
					<img src="https://avatar.csdn.net/7/0/D/3_diffenyu.jpg" alt="DiffenYu" class="avatar-pic">
					<span class="name">DiffenYu</span>
				</a>
			</p>
			<p>
				<span class="date">2012-12-01 20:00:31</span>
			</p>
			<p>
				<span class="read-num">阅读数：2211</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/xiaojun111111/article/details/52091676" target="_blank" strategy="BlogCommendFromBaidu_7">
				<em>x264</em> 参数详解【很强大、很细致，不再为不懂啥意思很烦恼】			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/xiaojun111111/article/details/52091676" target="_blank" >
				主要是最下面部分，<em>x264</em>参数介绍（二、<em>分析</em>和视频可用性信息）




【 翻译 】<em>x264</em>参数介绍（一、帧类型和码率控制）

2010年10月2日
评论 发表评论


翻译自：...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/xiaojun111111" title="xiaojun111111" target="_blank">
					<img src="https://avatar.csdn.net/1/B/8/3_xiaojun111111.jpg" alt="xiaojun111111" class="avatar-pic">
					<span class="name">xiaojun111111</span>
				</a>
			</p>
			<p>
				<span class="date">2016-08-02 10:10:23</span>
			</p>
			<p>
				<span class="read-num">阅读数：3754</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/12720135" target="_blank" strategy="BlogCommendFromBaidu_9">
				<em>x264</em>编码指南——码率控制			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/12720135" target="_blank" >
				<em>x264</em>是一个 H.264/MPEG4 AVC 编码器，本指南将指导新手如何创建高质量的H.264视频。

    对于普通用户通常有两种码率控制模式：crf（Constant Rate Factor...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2013-10-14 23:20:00</span>
			</p>
			<p>
				<span class="read-num">阅读数：22839</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/lutao614/article/details/22056837" target="_blank" strategy="BlogCommendFromBaidu_10">
				H264和<em>X264</em>究竟有什么区别?			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/lutao614/article/details/22056837" target="_blank" >
				转载自：http://blog.sina.com.cn/s/blog_7995e07901014tyd.html
先<em>简单</em>说一下，mkv和avi的格式只是封装容器，里面封装的是视频流+音频流。容器不会影...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/lutao614" title="lutao614" target="_blank">
					<img src="https://avatar.csdn.net/9/1/9/3_lutao614.jpg" alt="lutao614" class="avatar-pic">
					<span class="name">lutao614</span>
				</a>
			</p>
			<p>
				<span class="date">2014-03-25 13:48:19</span>
			</p>
			<p>
				<span class="read-num">阅读数：7657</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/chenchong_219/article/details/37996385" target="_blank" strategy="BlogCommendFromBaidu_11">
				<em>X264</em>编码			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/chenchong_219/article/details/37996385" target="_blank" >
				前面讲到了关于NAL打包成RTP后进行发送，那么这些NAL应该怎么得到呢？当然如果有现成的H264数据就可以直接用了，但是一般我们的摄像头采集的数据都不是H264格式的，那就需要编码。而且在我们这个项...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/chenchong_219" title="chenchong_219" target="_blank">
					<img src="https://avatar.csdn.net/0/E/3/3_chenchong_219.jpg" alt="chenchong_219" class="avatar-pic">
					<span class="name">chenchong_219</span>
				</a>
			</p>
			<p>
				<span class="date">2014-07-20 20:45:38</span>
			</p>
			<p>
				<span class="read-num">阅读数：9806</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45583217" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421173">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>9</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "x264源代码简单分析：x264命令行工具（x264.exe）";
    var ChannelId = 16;
    var articleId = "45583217";
    var commentscount = 1;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/45583217";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "x264%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80opengl";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"x264源代码简单分析：x264命令行工具（x264.exe）");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=x264%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80opengl"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>