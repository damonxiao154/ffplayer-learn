<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://blog.csdn.net/leixiaohua1020/article/details/45143075"/> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <meta name="description" content="本文分析FFmpeg的H.264解码器的宏块解码（Decode）部分的源代码。FFmpeg的H.264解码器调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第2个步骤。由于宏块解码部分的内容比较多，因此将本部分内容拆分成两篇文章：一篇文章记录帧内预测宏块（Intra）的宏块解码，另一篇文章记录帧间预测宏块（" />
    <meta name="keywords" content="FFmpeg,宏块" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <script src="https://csdnimg.cn/release/phoenix/vendor/tingyun/tingyun-rum-blog@js"></script>

    <link href="https://csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
    <title>FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra） - CSDN博客</title>
    
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

    <script type="text/javascript">
        var username = "leixiaohua1020";
        var blog_address = "https://blog.csdn.net/leixiaohua1020";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var isShowAds = true;
        var isOwner = false;
        var loginUrl = "https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45143075"
        var blogUrl = "https://blog.csdn.net/";
        var curSkin = "skin3-template";
    </script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm@js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min@js" type="text/javascript"></script>
    <script src="https://csdnimg.cn/rabbit/exposure-click/main-1.0.6@js"></script>
    <!-- 新版上报 -->
    <script src="//g.csdnimg.cn/track/1.0.0/track@js" type="text/javascript"></script>
    <!-- 新版上报end -->
            <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
    <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body>    
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    
    <script src="https://csdnimg.cn/public/sandalstrap/1.3/fonts/csdnc/csdnc@js"></script><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging.css">
<script type="text/javascript" src="//static.mediav.com/js/mvf_news_feed@js"></script>

<header style="display: none;">
	<div class="container d-flex clearfix">
		<div class="title-box">
			<h2 class="title-blog">
				<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅(leixiaohua1020)的专栏</a>
			</h2>
			<p class="description">一个广院工科生的视音频技术笔记</p>
		</div>
		<div class="opt-box d-flex justify-content-end">
			<a class="btn btn-sm" href="https://blog.csdn.net/leixiaohua1020/rss/list">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#csdnc-rss"></use>
					</svg>RSS订阅</a>
					</div>
	</div>
</header><script src="https://dup.baidustatic.com/js/ds@js"></script>
<div class="container clearfix pt0" id="mainBox">
    <main style="width: 100%;">
        <div class="blog-content-box">
	<div class="article-title-box">
			<span class="article-type type-1 float-left">原</span>		<h1 class="title-article">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</h1>
	</div>
	<div class="article-info-box">
		<div class="article-bar-top d-flex">
												<span class="time">2015年04月20日 14:55:51</span>
			<div class="float-right">
				<span class="read-count" style="display:none;">阅读数：14566</span>
											</div>
		</div>
	</div>
	<article>
		<div id="article_content" class="article_content_dummy clearfix csdn-tracking-statistics" data-pid="blog"  data-mod=popu_307  data-dsm = "post" >
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" />
            <div class="htmledit_views">
                <p><span style="white-space:pre"></span></p><p>=====================================================</p><p>H.264源代码分析文章列表：</p><p>【编码 - x264】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45536607" rel="nofollow">x264源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45583217" rel="nofollow">x264源代码简单分析：x264命令行工具（x264.exe）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45644367" rel="nofollow">x264源代码简单分析：编码器主干部分-1</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45719905" rel="nofollow">x264源代码简单分析：编码器主干部分-2</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45790195" rel="nofollow">x264源代码简单分析：x264_slice_write()</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45870269" rel="nofollow">x264源代码简单分析：滤波（Filter）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45917757" rel="nofollow">x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45936267" rel="nofollow">x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45938927" rel="nofollow">x264源代码简单分析：宏块编码（Encode）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45944811" rel="nofollow">x264源代码简单分析：熵编码（Entropy Encoding）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45960409" rel="nofollow">FFmpeg与libx264接口源代码简单分析</a></p><p>【解码 - libavcodec H.264 解码器】</p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/44864509" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：概述</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45001033" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45042755" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：解码器主干部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45114453" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45143075" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45195291" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）</a></p><p><a target=_blank href="http://blog.csdn.net/leixiaohua1020/article/details/45224579" rel="nofollow">FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分</a></p><p>=====================================================</p><br /><p><span style="white-space:pre">	</span>本文分析FFmpeg的H.264解码器的宏块解码（Decode）部分的源代码。FFmpeg的H.264解码器调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第2个步骤。由于宏块解码部分的内容比较多，因此将本部分内容拆分成两篇文章：一篇文章记录帧内预测宏块（Intra）的宏块解码，另一篇文章记录帧间预测宏块（Inter）的宏块解码。</p><br /><br /><h2>函数调用关系图</h2><p>宏块解码（Decode）部分的源代码在整个H.264解码器中的位置如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201504/04/1428080288_9350.jpg" rel="nofollow"><img src="https://img-blog.csdn.net/20150420030629845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></a><br /></p><p style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1806347" rel="nofollow">单击查看更清晰的图片</a></p><p style="text-align: center;"><br /></p><p>宏块解码（Decode）部分的源代码的调用关系如下图所示。</p><p style="text-align: center;"><a target=_blank target="_blank" href="http://img.my.csdn.net/uploads/201504/20/1429512935_3970.jpg" rel="nofollow"><img src="https://img-blog.csdn.net/20150420030647021" alt="" /></a><br /></p><p style="text-align: center;"><span style="text-align: center;"><a target=_blank target="_blank" href="https://my.csdn.net/leixiaohua1020/album/detail/1807095" rel="nofollow">单击查看更清晰的图片</a></span><br /></p><p style="text-align: center;"><span style="text-align: center;"><br /></span></p><span style="white-space:pre">	</span>宏块解码函数（Decode）通过帧内预测、帧间预测、DCT反变换等方法解码压缩数据。解码函数是ff_h264_hl_decode_mb()。其中跟宏块类型的不同，会调用几个不同的函数，最常见的就是调用hl_decode_mb_simple_8()。<br /><span style="white-space:pre">	</span>hl_decode_mb_simple_8()的定义是无法在源代码中直接找到的，这是因为它实际代码的函数名称是使用宏的方式写的。hl_decode_mb_simple_8()的源代码实际上就是FUNC(hl_decode_mb)()函数的源代码。<br /><span style="white-space:pre">	</span>从函数调用图中可以看出，FUNC(hl_decode_mb)()根据宏块类型的不同作不同的处理：如果帧内预测宏块（INTRA），就会调用hl_decode_mb_predict_luma()进行帧内预测；如果是帧间预测宏块（INTER），就会调用FUNC(hl_motion_422)()或者FUNC(hl_motion_420)()进行四分之一像素运动补偿。<br /><span style="white-space:pre">	</span>经过帧内预测或者帧间预测步骤之后，就得到了预测数据。随后FUNC(hl_decode_mb)()会调用hl_decode_mb_idct_luma()等几个函数对残差数据进行DCT反变换工作，并将变换后的数据叠加到预测数据上，形成解码后的图像数据。<br /><span style="white-space:pre">	</span>由于帧内预测宏块和帧间预测宏块的解码工作都比较复杂，因此分成两篇文章记录这两部分的源代码。本文记录帧内预测宏块解码时候的源代码。<br /><span style="white-space:pre">	</span>下面首先回顾一下decode_slice()函数。<br /><p><br /></p><p><br /></p><h2>decode_slice()</h2>decode_slice()用于解码H.264的Slice。该函数完成了“熵解码”、“宏块解码”、“环路滤波”的功能。它的定义位于libavcodec\h264_slice.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_1_7054551" name="code" class="cpp">//解码slice
//三个主要步骤：
//1.熵解码（CAVLC/CABAC）
//2.宏块解码
//3.环路滤波
//此外还包含了错误隐藏代码
static int decode_slice(struct AVCodecContext *avctx, void *arg)
{
    H264Context *h = *(void **)arg;
    int lf_x_start = h-&gt;mb_x;

    h-&gt;mb_skip_run = -1;

    av_assert0(h-&gt;block_offset[15] == (4 * ((scan8[15] - scan8[0]) &amp; 7) &lt;&lt; h-&gt;pixel_shift) + 4 * h-&gt;linesize * ((scan8[15] - scan8[0]) &gt;&gt; 3));

    h-&gt;is_complex = FRAME_MBAFF(h) || h-&gt;picture_structure != PICT_FRAME ||
                    avctx-&gt;codec_id != AV_CODEC_ID_H264 ||
                    (CONFIG_GRAY &amp;&amp; (h-&gt;flags &amp; CODEC_FLAG_GRAY));

    if (!(h-&gt;avctx-&gt;active_thread_type &amp; FF_THREAD_SLICE) &amp;&amp; h-&gt;picture_structure == PICT_FRAME &amp;&amp; h-&gt;er.error_status_table) {
        const int start_i  = av_clip(h-&gt;resync_mb_x + h-&gt;resync_mb_y * h-&gt;mb_width, 0, h-&gt;mb_num - 1);
        if (start_i) {
            int prev_status = h-&gt;er.error_status_table[h-&gt;er.mb_index2xy[start_i - 1]];
            prev_status &amp;= ~ VP_START;
            if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END))
                h-&gt;er.error_occurred = 1;
        }
    }
    //CABAC情况
    if (h-&gt;pps.cabac) {
        /* realign */
        align_get_bits(&amp;h-&gt;gb);

        /* init cabac */
        //初始化CABAC解码器
        ff_init_cabac_decoder(&amp;h-&gt;cabac,
                              h-&gt;gb.buffer + get_bits_count(&amp;h-&gt;gb) / 8,
                              (get_bits_left(&amp;h-&gt;gb) + 7) / 8);

        ff_h264_init_cabac_states(h);
        //循环处理每个宏块
        for (;;) {
            // START_TIMER
        	//解码CABAC数据
            int ret = ff_h264_decode_mb_cabac(h);
            int eos;
            // STOP_TIMER(&quot;decode_mb_cabac&quot;)
            //解码宏块
            if (ret &gt;= 0)
                ff_h264_hl_decode_mb(h);

            // FIXME optimal? or let mb_decode decode 16x32 ?
            //宏块级帧场自适应。很少接触
            if (ret &gt;= 0 &amp;&amp; FRAME_MBAFF(h)) {
                h-&gt;mb_y++;

                ret = ff_h264_decode_mb_cabac(h);
                //解码宏块
                if (ret &gt;= 0)
                    ff_h264_hl_decode_mb(h);
                h-&gt;mb_y--;
            }
            eos = get_cabac_terminate(&amp;h-&gt;cabac);

            if ((h-&gt;workaround_bugs &amp; FF_BUG_TRUNCATED) &amp;&amp;
                h-&gt;cabac.bytestream &gt; h-&gt;cabac.bytestream_end + 2) {
            	//错误隐藏
                er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y, h-&gt;mb_x - 1,
                             h-&gt;mb_y, ER_MB_END);
                if (h-&gt;mb_x &gt;= lf_x_start)
                    loop_filter(h, lf_x_start, h-&gt;mb_x + 1);
                return 0;
            }
            if (h-&gt;cabac.bytestream &gt; h-&gt;cabac.bytestream_end + 2 )
                av_log(h-&gt;avctx, AV_LOG_DEBUG, &quot;bytestream overread %&quot;PTRDIFF_SPECIFIER&quot;\n&quot;, h-&gt;cabac.bytestream_end - h-&gt;cabac.bytestream);
            if (ret &lt; 0 || h-&gt;cabac.bytestream &gt; h-&gt;cabac.bytestream_end + 4) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       &quot;error while decoding MB %d %d, bytestream %&quot;PTRDIFF_SPECIFIER&quot;\n&quot;,
                       h-&gt;mb_x, h-&gt;mb_y,
                       h-&gt;cabac.bytestream_end - h-&gt;cabac.bytestream);
                er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y, h-&gt;mb_x,
                             h-&gt;mb_y, ER_MB_ERROR);
                return AVERROR_INVALIDDATA;
            }
            //mb_x自增
            //如果自增后超过了一行的mb个数
            if (++h-&gt;mb_x &gt;= h-&gt;mb_width) {
            	//环路滤波
                loop_filter(h, lf_x_start, h-&gt;mb_x);
                h-&gt;mb_x = lf_x_start = 0;
                decode_finish_row(h);
                //mb_y自增（处理下一行）
                ++h-&gt;mb_y;
                //宏块级帧场自适应，暂不考虑
                if (FIELD_OR_MBAFF_PICTURE(h)) {
                    ++h-&gt;mb_y;
                    if (FRAME_MBAFF(h) &amp;&amp; h-&gt;mb_y &lt; h-&gt;mb_height)
                        predict_field_decoding_flag(h);
                }
            }
            //如果mb_y超过了mb的行数
            if (eos || h-&gt;mb_y &gt;= h-&gt;mb_height) {
                tprintf(h-&gt;avctx, &quot;slice end %d %d\n&quot;,
                        get_bits_count(&amp;h-&gt;gb), h-&gt;gb.size_in_bits);
                er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y, h-&gt;mb_x - 1,
                             h-&gt;mb_y, ER_MB_END);
                if (h-&gt;mb_x &gt; lf_x_start)
                    loop_filter(h, lf_x_start, h-&gt;mb_x);
                return 0;
            }
        }
    } else {
    	//CAVLC情况
    	//循环处理每个宏块
        for (;;) {
        	//解码宏块的CAVLC
            int ret = ff_h264_decode_mb_cavlc(h);
            //解码宏块
            if (ret &gt;= 0)
                ff_h264_hl_decode_mb(h);

            // FIXME optimal? or let mb_decode decode 16x32 ?
            if (ret &gt;= 0 &amp;&amp; FRAME_MBAFF(h)) {
                h-&gt;mb_y++;
                ret = ff_h264_decode_mb_cavlc(h);

                if (ret &gt;= 0)
                    ff_h264_hl_decode_mb(h);
                h-&gt;mb_y--;
            }

            if (ret &lt; 0) {
                av_log(h-&gt;avctx, AV_LOG_ERROR,
                       &quot;error while decoding MB %d %d\n&quot;, h-&gt;mb_x, h-&gt;mb_y);
                er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y, h-&gt;mb_x,
                             h-&gt;mb_y, ER_MB_ERROR);
                return ret;
            }

            if (++h-&gt;mb_x &gt;= h-&gt;mb_width) {
            	//环路滤波
                loop_filter(h, lf_x_start, h-&gt;mb_x);
                h-&gt;mb_x = lf_x_start = 0;
                decode_finish_row(h);
                ++h-&gt;mb_y;
                if (FIELD_OR_MBAFF_PICTURE(h)) {
                    ++h-&gt;mb_y;
                    if (FRAME_MBAFF(h) &amp;&amp; h-&gt;mb_y &lt; h-&gt;mb_height)
                        predict_field_decoding_flag(h);
                }
                if (h-&gt;mb_y &gt;= h-&gt;mb_height) {
                    tprintf(h-&gt;avctx, &quot;slice end %d %d\n&quot;,
                            get_bits_count(&amp;h-&gt;gb), h-&gt;gb.size_in_bits);

                    if (   get_bits_left(&amp;h-&gt;gb) == 0
                        || get_bits_left(&amp;h-&gt;gb) &gt; 0 &amp;&amp; !(h-&gt;avctx-&gt;err_recognition &amp; AV_EF_AGGRESSIVE)) {
                    	//错误隐藏
                        er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y,
                                     h-&gt;mb_x - 1, h-&gt;mb_y, ER_MB_END);

                        return 0;
                    } else {
                        er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y,
                                     h-&gt;mb_x, h-&gt;mb_y, ER_MB_END);

                        return AVERROR_INVALIDDATA;
                    }
                }
            }

            if (get_bits_left(&amp;h-&gt;gb) &lt;= 0 &amp;&amp; h-&gt;mb_skip_run &lt;= 0) {
                tprintf(h-&gt;avctx, &quot;slice end %d %d\n&quot;,
                        get_bits_count(&amp;h-&gt;gb), h-&gt;gb.size_in_bits);

                if (get_bits_left(&amp;h-&gt;gb) == 0) {
                    er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y,
                                 h-&gt;mb_x - 1, h-&gt;mb_y, ER_MB_END);
                    if (h-&gt;mb_x &gt; lf_x_start)
                        loop_filter(h, lf_x_start, h-&gt;mb_x);

                    return 0;
                } else {
                    er_add_slice(h, h-&gt;resync_mb_x, h-&gt;resync_mb_y, h-&gt;mb_x,
                                 h-&gt;mb_y, ER_MB_ERROR);

                    return AVERROR_INVALIDDATA;
                }
            }
        }
    }
}
</pre><br />重复记录一下decode_slice()的流程：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）判断H.264码流是CABAC编码还是CAVLC编码，进入不同的处理循环。<br />（2）如果是CABAC编码，首先调用ff_init_cabac_decoder()初始化CABAC解码器。然后进入一个循环，依次对每个宏块进行以下处理：<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用ff_h264_decode_mb_cabac()进行CABAC熵解码</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)调用ff_h264_hl_decode_mb()进行宏块解码</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)解码一行宏块之后调用loop_filter()进行环路滤波</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">d)此外还有可能调用er_add_slice()进行错误隐藏处理</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（3）如果是CABAC编码，直接进入一个循环，依次对每个宏块进行以下处理：<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用ff_h264_decode_mb_cavlc()进行CAVLC熵解码</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)调用ff_h264_hl_decode_mb()进行宏块解码</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)解码一行宏块之后调用loop_filter()进行环路滤波</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">d)此外还有可能调用er_add_slice()进行错误隐藏处理</blockquote></blockquote>可以看出，宏块解码函数是ff_h264_hl_decode_mb()。下面看一下这个函数。<br /><p><br /></p><p><br /></p><h2>ff_h264_hl_decode_mb()</h2>ff_h264_hl_decode_mb()完成了宏块解码的工作。“宏块解码”就是根据前一步骤“熵解码”得到的宏块类型、运动矢量、参考帧、DCT残差数据等信息恢复图像数据的过程。该函数的定义位于libavcodec\h264_mb.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_2_1019358" name="code" class="cpp">//解码宏块
void ff_h264_hl_decode_mb(H264Context *h)
{
	//宏块序号 mb_xy = mb_x + mb_y*mb_stride
    const int mb_xy   = h-&gt;mb_xy;
    //宏块类型
    const int mb_type = h-&gt;cur_pic.mb_type[mb_xy];
    //比较少见，PCM类型
    int is_complex    = CONFIG_SMALL || h-&gt;is_complex ||
                        IS_INTRA_PCM(mb_type) || h-&gt;qscale == 0;
    //YUV444
    if (CHROMA444(h)) {
        if (is_complex || h-&gt;pixel_shift)
            hl_decode_mb_444_complex(h);
        else
            hl_decode_mb_444_simple_8(h);
    } else if (is_complex) {
        hl_decode_mb_complex(h);   //PCM类型？
    } else if (h-&gt;pixel_shift) {
        hl_decode_mb_simple_16(h); //色彩深度为16

    } else
        hl_decode_mb_simple_8(h);  //色彩深度为8
}
</pre><br />可以看出ff_h264_hl_decode_mb()的定义很简单：通过系统的参数（例如颜色位深是不是8bit，YUV采样格式是不是4：4：4等）判断该调用哪一个函数作为解码函数。由于最普遍的情况是解码8bit的YUV420P格式的H.264数据，因此一般情况下会调用hl_decode_mb_simple_8()。这里有一点需要注意：如果我们直接查找hl_decode_mb_simple_8()的定义，会发现这个函数是找不到的。这个函数的定义实际上就是FUNC(hl_decode_mb)()函数。FUNC(hl_decode_mb)()函数名称中的宏“FUNC()”展开后就是hl_decode_mb_simple_8()。那么我们看一下FUNC(hl_decode_mb)()函数。<br /><br /><h2>FUNC(hl_decode_mb)()&nbsp;</h2>FUNC(hl_decode_mb)()的定义位于libavcodec\h264_mb_template.c。下面看一下FUNC(hl_decode_mb)()函数的定义。<br /><span style="font-family:FangSong_GB2312;">PS：在这里需要注意，FFmpeg H.264解码器中名称中包含“_template”的C语言文件中的函数都是使用类似于“FUNC(name)()”的方式书写的，这样做的目的大概是为了适配各种各样的功能。例如在处理16bit的H.264码流的时候，FUNC(hl_decode_mb)()可以展开为hl_decode_mb_simple_16()函数；同理，FUNC(hl_decode_mb)()在其他条件下也可以展开为hl_decode_mb_complex()函数。</span><br /><br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_3_5639631" name="code" class="cpp">//hl是什么意思？high level？
/*
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 * 宏块解码
 * 帧内宏块：帧内预测-&gt;残差DCT反变换
 * 帧间宏块：帧间预测（运动补偿）-&gt;残差DCT反变换
 *
 */
static av_noinline void FUNC(hl_decode_mb)(H264Context *h)
{
	//序号：x（行）和y（列）
    const int mb_x    = h-&gt;mb_x;
    const int mb_y    = h-&gt;mb_y;
    //宏块序号 mb_xy = mb_x + mb_y*mb_stride
    const int mb_xy   = h-&gt;mb_xy;
    //宏块类型
    const int mb_type = h-&gt;cur_pic.mb_type[mb_xy];
    //这三个变量存储最后处理完成的像素值
    uint8_t *dest_y, *dest_cb, *dest_cr;
    int linesize, uvlinesize /*dct_offset*/;
    int i, j;
    int *block_offset = &amp;h-&gt;block_offset[0];
    const int transform_bypass = !SIMPLE &amp;&amp; (h-&gt;qscale == 0 &amp;&amp; h-&gt;sps.transform_bypass);
    /* is_h264 should always be true if SVQ3 is disabled. */
    const int is_h264 = !CONFIG_SVQ3_DECODER || SIMPLE || h-&gt;avctx-&gt;codec_id == AV_CODEC_ID_H264;
    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);
    const int block_h   = 16 &gt;&gt; h-&gt;chroma_y_shift;
    const int chroma422 = CHROMA422(h);
    //存储Y，U，V像素的位置：dest_y，dest_cb，dest_cr
    //分别对应AVFrame的data[0]，data[1]，data[2]
    dest_y  = h-&gt;cur_pic.f.data[0] + ((mb_x &lt;&lt; PIXEL_SHIFT)     + mb_y * h-&gt;linesize)  * 16;
    dest_cb = h-&gt;cur_pic.f.data[1] +  (mb_x &lt;&lt; PIXEL_SHIFT) * 8 + mb_y * h-&gt;uvlinesize * block_h;
    dest_cr = h-&gt;cur_pic.f.data[2] +  (mb_x &lt;&lt; PIXEL_SHIFT) * 8 + mb_y * h-&gt;uvlinesize * block_h;

    h-&gt;vdsp.prefetch(dest_y  + (h-&gt;mb_x &amp; 3) * 4 * h-&gt;linesize   + (64 &lt;&lt; PIXEL_SHIFT), h-&gt;linesize,       4);
    h-&gt;vdsp.prefetch(dest_cb + (h-&gt;mb_x &amp; 7)     * h-&gt;uvlinesize + (64 &lt;&lt; PIXEL_SHIFT), dest_cr - dest_cb, 2);

    h-&gt;list_counts[mb_xy] = h-&gt;list_count;

    //系统中包含了
    //#define SIMPLE 1
    //不会执行？
    if (!SIMPLE &amp;&amp; MB_FIELD(h)) {
        linesize     = h-&gt;mb_linesize = h-&gt;linesize * 2;
        uvlinesize   = h-&gt;mb_uvlinesize = h-&gt;uvlinesize * 2;
        block_offset = &amp;h-&gt;block_offset[48];
        if (mb_y &amp; 1) { // FIXME move out of this function?
            dest_y  -= h-&gt;linesize * 15;
            dest_cb -= h-&gt;uvlinesize * (block_h - 1);
            dest_cr -= h-&gt;uvlinesize * (block_h - 1);
        }
        if (FRAME_MBAFF(h)) {
            int list;
            for (list = 0; list &lt; h-&gt;list_count; list++) {
                if (!USES_LIST(mb_type, list))
                    continue;
                if (IS_16X16(mb_type)) {
                    int8_t *ref = &amp;h-&gt;ref_cache[list][scan8[0]];
                    fill_rectangle(ref, 4, 4, 8, (16 + *ref) ^ (h-&gt;mb_y &amp; 1), 1);
                } else {
                    for (i = 0; i &lt; 16; i += 4) {
                        int ref = h-&gt;ref_cache[list][scan8[i]];
                        if (ref &gt;= 0)
                            fill_rectangle(&amp;h-&gt;ref_cache[list][scan8[i]], 2, 2,
                                           8, (16 + ref) ^ (h-&gt;mb_y &amp; 1), 1);
                    }
                }
            }
        }
    } else {
        linesize   = h-&gt;mb_linesize   = h-&gt;linesize;
        uvlinesize = h-&gt;mb_uvlinesize = h-&gt;uvlinesize;
        // dct_offset = s-&gt;linesize * 16;
    }
    //系统中包含了
    //#define SIMPLE 1
    //不会执行？
    if (!SIMPLE &amp;&amp; IS_INTRA_PCM(mb_type)) {
        const int bit_depth = h-&gt;sps.bit_depth_luma;
        if (PIXEL_SHIFT) {
            int j;
            GetBitContext gb;
            init_get_bits(&amp;gb, h-&gt;intra_pcm_ptr,
                          ff_h264_mb_sizes[h-&gt;sps.chroma_format_idc] * bit_depth);

            for (i = 0; i &lt; 16; i++) {
                uint16_t *tmp_y = (uint16_t *)(dest_y + i * linesize);
                for (j = 0; j &lt; 16; j++)
                    tmp_y[j] = get_bits(&amp;gb, bit_depth);
            }
            if (SIMPLE || !CONFIG_GRAY || !(h-&gt;flags &amp; CODEC_FLAG_GRAY)) {
                if (!h-&gt;sps.chroma_format_idc) {
                    for (i = 0; i &lt; block_h; i++) {
                        uint16_t *tmp_cb = (uint16_t *)(dest_cb + i * uvlinesize);
                        uint16_t *tmp_cr = (uint16_t *)(dest_cr + i * uvlinesize);
                        for (j = 0; j &lt; 8; j++) {
                            tmp_cb[j] = tmp_cr[j] = 1 &lt;&lt; (bit_depth - 1);
                        }
                    }
                } else {
                    for (i = 0; i &lt; block_h; i++) {
                        uint16_t *tmp_cb = (uint16_t *)(dest_cb + i * uvlinesize);
                        for (j = 0; j &lt; 8; j++)
                            tmp_cb[j] = get_bits(&amp;gb, bit_depth);
                    }
                    for (i = 0; i &lt; block_h; i++) {
                        uint16_t *tmp_cr = (uint16_t *)(dest_cr + i * uvlinesize);
                        for (j = 0; j &lt; 8; j++)
                            tmp_cr[j] = get_bits(&amp;gb, bit_depth);
                    }
                }
            }
        } else {
            for (i = 0; i &lt; 16; i++)
                memcpy(dest_y + i * linesize, h-&gt;intra_pcm_ptr + i * 16, 16);
            if (SIMPLE || !CONFIG_GRAY || !(h-&gt;flags &amp; CODEC_FLAG_GRAY)) {
                if (!h-&gt;sps.chroma_format_idc) {
                    for (i = 0; i &lt; 8; i++) {
                        memset(dest_cb + i * uvlinesize, 1 &lt;&lt; (bit_depth - 1), 8);
                        memset(dest_cr + i * uvlinesize, 1 &lt;&lt; (bit_depth - 1), 8);
                    }
                } else {
                    const uint8_t *src_cb = h-&gt;intra_pcm_ptr + 256;
                    const uint8_t *src_cr = h-&gt;intra_pcm_ptr + 256 + block_h * 8;
                    for (i = 0; i &lt; block_h; i++) {
                        memcpy(dest_cb + i * uvlinesize, src_cb + i * 8, 8);
                        memcpy(dest_cr + i * uvlinesize, src_cr + i * 8, 8);
                    }
                }
            }
        }
    } else {
    	//Intra类型
    	//Intra4x4或者Intra16x16

        if (IS_INTRA(mb_type)) {
            if (h-&gt;deblocking_filter)
                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize,
                               uvlinesize, 1, 0, SIMPLE, PIXEL_SHIFT);

            if (SIMPLE || !CONFIG_GRAY || !(h-&gt;flags &amp; CODEC_FLAG_GRAY)) {
                h-&gt;hpc.pred8x8[h-&gt;chroma_pred_mode](dest_cb, uvlinesize);
                h-&gt;hpc.pred8x8[h-&gt;chroma_pred_mode](dest_cr, uvlinesize);
            }
            //帧内预测-亮度
            hl_decode_mb_predict_luma(h, mb_type, is_h264, SIMPLE,
                                      transform_bypass, PIXEL_SHIFT,
                                      block_offset, linesize, dest_y, 0);

            if (h-&gt;deblocking_filter)
                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize,
                               uvlinesize, 0, 0, SIMPLE, PIXEL_SHIFT);
        } else if (is_h264) {
        	//Inter类型

            //运动补偿
            if (chroma422) {
                FUNC(hl_motion_422)(h, dest_y, dest_cb, dest_cr,
                              h-&gt;qpel_put, h-&gt;h264chroma.put_h264_chroma_pixels_tab,
                              h-&gt;qpel_avg, h-&gt;h264chroma.avg_h264_chroma_pixels_tab,
                              h-&gt;h264dsp.weight_h264_pixels_tab,
                              h-&gt;h264dsp.biweight_h264_pixels_tab);
            } else {
            	//“*_put”处理单向预测，“*_avg”处理双向预测，“weight”处理加权预测
            	//h-&gt;qpel_put[16]包含了单向预测的四分之一像素运动补偿所有样点处理的函数
            	//两个像素之间横向的点（内插点和原始的点）有4个，纵向的点有4个，组合起来一共16个
            	//h-&gt;qpel_avg[16]情况也类似
                FUNC(hl_motion_420)(h, dest_y, dest_cb, dest_cr,
                              h-&gt;qpel_put, h-&gt;h264chroma.put_h264_chroma_pixels_tab,
                              h-&gt;qpel_avg, h-&gt;h264chroma.avg_h264_chroma_pixels_tab,
                              h-&gt;h264dsp.weight_h264_pixels_tab,
                              h-&gt;h264dsp.biweight_h264_pixels_tab);
            }
        }
        //亮度的IDCT
        hl_decode_mb_idct_luma(h, mb_type, is_h264, SIMPLE, transform_bypass,
                               PIXEL_SHIFT, block_offset, linesize, dest_y, 0);
        //色度的IDCT（没有写在一个单独的函数中）
        if ((SIMPLE || !CONFIG_GRAY || !(h-&gt;flags &amp; CODEC_FLAG_GRAY)) &amp;&amp;
            (h-&gt;cbp &amp; 0x30)) {
            uint8_t *dest[2] = { dest_cb, dest_cr };
            //transform_bypass=0，不考虑
            if (transform_bypass) {
                if (IS_INTRA(mb_type) &amp;&amp; h-&gt;sps.profile_idc == 244 &amp;&amp;
                    (h-&gt;chroma_pred_mode == VERT_PRED8x8 ||
                     h-&gt;chroma_pred_mode == HOR_PRED8x8)) {
                    h-&gt;hpc.pred8x8_add[h-&gt;chroma_pred_mode](dest[0],
                                                            block_offset + 16,
                                                            h-&gt;mb + (16 * 16 * 1 &lt;&lt; PIXEL_SHIFT),
                                                            uvlinesize);
                    h-&gt;hpc.pred8x8_add[h-&gt;chroma_pred_mode](dest[1],
                                                            block_offset + 32,
                                                            h-&gt;mb + (16 * 16 * 2 &lt;&lt; PIXEL_SHIFT),
                                                            uvlinesize);
                } else {
                    idct_add = h-&gt;h264dsp.h264_add_pixels4_clear;
                    for (j = 1; j &lt; 3; j++) {
                        for (i = j * 16; i &lt; j * 16 + 4; i++)
                            if (h-&gt;non_zero_count_cache[scan8[i]] ||
                                dctcoef_get(h-&gt;mb, PIXEL_SHIFT, i * 16))
                                idct_add(dest[j - 1] + block_offset[i],
                                         h-&gt;mb + (i * 16 &lt;&lt; PIXEL_SHIFT),
                                         uvlinesize);
                        if (chroma422) {
                            for (i = j * 16 + 4; i &lt; j * 16 + 8; i++)
                                if (h-&gt;non_zero_count_cache[scan8[i + 4]] ||
                                    dctcoef_get(h-&gt;mb, PIXEL_SHIFT, i * 16))
                                    idct_add(dest[j - 1] + block_offset[i + 4],
                                             h-&gt;mb + (i * 16 &lt;&lt; PIXEL_SHIFT),
                                             uvlinesize);
                        }
                    }
                }
            } else {
                if (is_h264) {
                    int qp[2];
                    if (chroma422) {
                        qp[0] = h-&gt;chroma_qp[0] + 3;
                        qp[1] = h-&gt;chroma_qp[1] + 3;
                    } else {
                        qp[0] = h-&gt;chroma_qp[0];
                        qp[1] = h-&gt;chroma_qp[1];
                    }
                    //色度的IDCT

                    //直流分量的hadamard变换
                    if (h-&gt;non_zero_count_cache[scan8[CHROMA_DC_BLOCK_INDEX + 0]])
                        h-&gt;h264dsp.h264_chroma_dc_dequant_idct(h-&gt;mb + (16 * 16 * 1 &lt;&lt; PIXEL_SHIFT),
                                                               h-&gt;dequant4_coeff[IS_INTRA(mb_type) ? 1 : 4][qp[0]][0]);
                    if (h-&gt;non_zero_count_cache[scan8[CHROMA_DC_BLOCK_INDEX + 1]])
                        h-&gt;h264dsp.h264_chroma_dc_dequant_idct(h-&gt;mb + (16 * 16 * 2 &lt;&lt; PIXEL_SHIFT),
                                                               h-&gt;dequant4_coeff[IS_INTRA(mb_type) ? 2 : 5][qp[1]][0]);
                    //IDCT
                    //最后的“8”代表内部循环处理8次（U,V各4次）
                    h-&gt;h264dsp.h264_idct_add8(dest, block_offset,
                                              h-&gt;mb, uvlinesize,
                                              h-&gt;non_zero_count_cache);
                } else if (CONFIG_SVQ3_DECODER) {
                    h-&gt;h264dsp.h264_chroma_dc_dequant_idct(h-&gt;mb + 16 * 16 * 1,
                                                           h-&gt;dequant4_coeff[IS_INTRA(mb_type) ? 1 : 4][h-&gt;chroma_qp[0]][0]);
                    h-&gt;h264dsp.h264_chroma_dc_dequant_idct(h-&gt;mb + 16 * 16 * 2,
                                                           h-&gt;dequant4_coeff[IS_INTRA(mb_type) ? 2 : 5][h-&gt;chroma_qp[1]][0]);
                    for (j = 1; j &lt; 3; j++) {
                        for (i = j * 16; i &lt; j * 16 + 4; i++)
                            if (h-&gt;non_zero_count_cache[scan8[i]] || h-&gt;mb[i * 16]) {
                                uint8_t *const ptr = dest[j - 1] + block_offset[i];
                                ff_svq3_add_idct_c(ptr, h-&gt;mb + i * 16,
                                                   uvlinesize,
                                                   ff_h264_chroma_qp[0][h-&gt;qscale + 12] - 12, 2);
                            }
                    }
                }
            }
        }
    }
}
</pre><br />下面简单梳理一下FUNC(hl_decode_mb)的流程（在这里只考虑亮度分量的解码，色度分量的解码过程是类似的）：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）预测<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)如果是帧内预测宏块（Intra），调用hl_decode_mb_predict_luma()进行帧内预测，得到预测数据。</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)如果不是帧内预测宏块（Inter），调用FUNC(hl_motion_420)()或者FUNC(hl_motion_422)()进行帧间预测（即运动补偿），得到预测数据。</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（2）残差叠加<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)调用hl_decode_mb_idct_luma()对DCT残差数据进行DCT反变换，获得残差像素数据并且叠加到之前得到的预测数据上，得到最后的图像数据。</blockquote></blockquote><p><span style="font-family:FangSong_GB2312;">PS：该流程中有一个重要的贯穿始终的内存指针dest_y，其指向的内存中存储了解码后的亮度数据。</span></p><p><br /></p>本文将会分析上述流程中的帧内预测和残差叠加两个部分。下面先看一下帧内预测函数hl_decode_mb_predict_luma()。<br /><br /><h2>hl_decode_mb_predict_luma()</h2>hl_decode_mb_predict_luma()对帧内宏块进行帧内预测，它的定义位于libavcodec\h264_mb.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_4_9703496" name="code" class="cpp">//帧内预测-亮度
//分成2种情况：Intra4x4和Intra16x16
static av_always_inline void hl_decode_mb_predict_luma(H264Context *h,
                                                       int mb_type, int is_h264,
                                                       int simple,
                                                       int transform_bypass,
                                                       int pixel_shift,
                                                       int *block_offset,
                                                       int linesize,
                                                       uint8_t *dest_y, int p)
{
	//用于DCT反变换
    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);
    void (*idct_dc_add)(uint8_t *dst, int16_t *block, int stride);
    int i;
    int qscale = p == 0 ? h-&gt;qscale : h-&gt;chroma_qp[p - 1];
    //外部调用时候p=0
    block_offset += 16 * p;
    if (IS_INTRA4x4(mb_type)) {
    	//Intra4x4帧内预测

        if (IS_8x8DCT(mb_type)) {
        	//如果使用了8x8的DCT，先不研究
            if (transform_bypass) {
                idct_dc_add =
                idct_add    = h-&gt;h264dsp.h264_add_pixels8_clear;
            } else {
                idct_dc_add = h-&gt;h264dsp.h264_idct8_dc_add;
                idct_add    = h-&gt;h264dsp.h264_idct8_add;
            }
            for (i = 0; i &lt; 16; i += 4) {
                uint8_t *const ptr = dest_y + block_offset[i];
                const int dir      = h-&gt;intra4x4_pred_mode_cache[scan8[i]];
                if (transform_bypass &amp;&amp; h-&gt;sps.profile_idc == 244 &amp;&amp; dir &lt;= 1) {
                    if (h-&gt;x264_build != -1) {
                        h-&gt;hpc.pred8x8l_add[dir](ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift), linesize);
                    } else
                        h-&gt;hpc.pred8x8l_filter_add[dir](ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift),
                                                        (h-&gt; topleft_samples_available &lt;&lt; i) &amp; 0x8000,
                                                        (h-&gt;topright_samples_available &lt;&lt; i) &amp; 0x4000, linesize);
                } else {
                    const int nnz = h-&gt;non_zero_count_cache[scan8[i + p * 16]];
                    h-&gt;hpc.pred8x8l[dir](ptr, (h-&gt;topleft_samples_available &lt;&lt; i) &amp; 0x8000,
                                         (h-&gt;topright_samples_available &lt;&lt; i) &amp; 0x4000, linesize);
                    if (nnz) {
                        if (nnz == 1 &amp;&amp; dctcoef_get(h-&gt;mb, pixel_shift, i * 16 + p * 256))
                            idct_dc_add(ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift), linesize);
                        else
                            idct_add(ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift), linesize);
                    }
                }
            }
        } else {
        	/*
    		 * Intra4x4帧内预测：16x16 宏块被划分为16个4x4子块
    		 *
    		 * +----+----+----+----+
    		 * |    |    |    |    |
    		 * +----+----+----+----+
    		 * |    |    |    |    |
    		 * +----+----+----+----+
    		 * |    |    |    |    |
    		 * +----+----+----+----+
    		 * |    |    |    |    |
    		 * +----+----+----+----+
    		 *
    		 */
        	//4x4的IDCT
        	//transform_bypass=0，不考虑
            if (transform_bypass) {
                idct_dc_add  =
                idct_add     = h-&gt;h264dsp.h264_add_pixels4_clear;
            } else {
            	//常见情况
                idct_dc_add = h-&gt;h264dsp.h264_idct_dc_add;
                idct_add    = h-&gt;h264dsp.h264_idct_add;
            }
            //循环4x4=16个DCT块
            for (i = 0; i &lt; 16; i++) {
            	//ptr指向输出的像素数据
                uint8_t *const ptr = dest_y + block_offset[i];
                //dir存储了帧内预测模式
                const int dir      = h-&gt;intra4x4_pred_mode_cache[scan8[i]];

                if (transform_bypass &amp;&amp; h-&gt;sps.profile_idc == 244 &amp;&amp; dir &lt;= 1) {
                    h-&gt;hpc.pred4x4_add[dir](ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift), linesize);
                } else {
                    uint8_t *topright;
                    int nnz, tr;
                    uint64_t tr_high;
                    //这2种模式特殊的处理？
                    if (dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED) {
                        const int topright_avail = (h-&gt;topright_samples_available &lt;&lt; i) &amp; 0x8000;
                        av_assert2(h-&gt;mb_y || linesize &lt;= block_offset[i]);
                        if (!topright_avail) {
                            if (pixel_shift) {
                                tr_high  = ((uint16_t *)ptr)[3 - linesize / 2] * 0x0001000100010001ULL;
                                topright = (uint8_t *)&amp;tr_high;
                            } else {
                                tr       = ptr[3 - linesize] * 0x01010101u;
                                topright = (uint8_t *)&amp;tr;
                            }
                        } else
                            topright = ptr + (4 &lt;&lt; pixel_shift) - linesize;
                    } else
                        topright = NULL;
                    //汇编函数：4x4帧内预测（9种方式：Vertical，Horizontal，DC，Plane等等。。。）
                    h-&gt;hpc.pred4x4[dir](ptr, topright, linesize);
                    //每个4x4块的非0系数个数的缓存
                    nnz = h-&gt;non_zero_count_cache[scan8[i + p * 16]];
                    //有非0系数的时候才处理
                    //h-&gt;mb中存储了DCT系数
                    //输出存储在ptr
                    if (nnz) {
                        if (is_h264) {
                            if (nnz == 1 &amp;&amp; dctcoef_get(h-&gt;mb, pixel_shift, i * 16 + p * 256))
                                idct_dc_add(ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift), linesize);//特殊：AC系数全为0时候调用
                            else
                                idct_add(ptr, h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift), linesize);//4x4DCT反变换
                        } else if (CONFIG_SVQ3_DECODER)
                            ff_svq3_add_idct_c(ptr, h-&gt;mb + i * 16 + p * 256, linesize, qscale, 0);
                    }
                }
            }
        }
    } else {
    	/*
    	 * Intra16x16帧内预测
    	 *
    	 * +--------+--------+
    	 * |                 |
    	 * |                 |
    	 * |                 |
    	 * +        +        +
    	 * |                 |
    	 * |                 |
    	 * |                 |
    	 * +--------+--------+
    	 *
    	 */
    	//汇编函数：16x16帧内预测（4种方式：Vertical，Horizontal，DC，Plane）
        h-&gt;hpc.pred16x16[h-&gt;intra16x16_pred_mode](dest_y, linesize);
        if (is_h264) {
            if (h-&gt;non_zero_count_cache[scan8[LUMA_DC_BLOCK_INDEX + p]]) {
            	//有非0系数的时候才处理
            	//Hadamard反变换
                //h-&gt;mb中存储了DCT系数
            	//h-&gt;mb_luma_dc中存储了16个DCT的直流分量
                if (!transform_bypass)
                    h-&gt;h264dsp.h264_luma_dc_dequant_idct(h-&gt;mb + (p * 256 &lt;&lt; pixel_shift),
                                                         h-&gt;mb_luma_dc[p],
                                                         h-&gt;dequant4_coeff[p][qscale][0]);
                //注：此处仅仅进行了Hadamard反变换，并未进行DCT反变换
                //Intra16x16在解码过程中的DCT反变换并不是在这里进行，而是在后面进行
                else {
                    static const uint8_t dc_mapping[16] = {
                         0 * 16,  1 * 16,  4 * 16,  5 * 16,
                         2 * 16,  3 * 16,  6 * 16,  7 * 16,
                         8 * 16,  9 * 16, 12 * 16, 13 * 16,
                        10 * 16, 11 * 16, 14 * 16, 15 * 16
                    };
                    for (i = 0; i &lt; 16; i++)
                        dctcoef_set(h-&gt;mb + (p * 256 &lt;&lt; pixel_shift),
                                    pixel_shift, dc_mapping[i],
                                    dctcoef_get(h-&gt;mb_luma_dc[p],
                                                pixel_shift, i));
                }
            }
        } else if (CONFIG_SVQ3_DECODER)
            ff_svq3_luma_dc_dequant_idct_c(h-&gt;mb + p * 256,
                                           h-&gt;mb_luma_dc[p], qscale);
    }
}
</pre><br />下面根据原代码梳理一下hl_decode_mb_predict_luma()的主干：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）如果宏块是4x4帧内预测类型（Intra4x4），作如下处理：<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)循环遍历16个4x4的块，并作如下处理：</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">i.从intra4x4_pred_mode_cache中读取4x4帧内预测方法</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ii.根据帧内预测方法调用H264PredContext中的汇编函数pred4x4()进行帧内预测</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">iii.调用H264DSPContext中的汇编函数h264_idct_add()对DCT残差数据进行4x4DCT反变换；如果DCT系数中不包含AC系数的话，则调用汇编函数h264_idct_dc_add()对残差数据进行4x4DCT反变换（速度更快）。</blockquote></blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（2）如果宏块是16x16帧内预测类型（Intra4x4），作如下处理：<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)通过intra16x16_pred_mode获得16x16帧内预测方法</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)根据帧内预测方法调用H264PredContext中的汇编函数pred16x16 ()进行帧内预测</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">c)调用H264DSPContext中的汇编函数h264_luma_dc_dequant_idct ()对16个小块的DC系数进行Hadamard反变换</blockquote></blockquote><span style="white-space:pre">	</span>在这里需要注意，帧内4x4的宏块在执行完hl_decode_mb_predict_luma()之后实际上已经完成了“帧内预测+DCT反变换”的流程（解码完成）；而帧内16x16的宏块在执行完hl_decode_mb_predict_luma()之后仅仅完成了“帧内预测+Hadamard反变换”的流程，而并未进行“DCT反变换”的步骤，这一步骤需要在后续步骤中完成。<br /><span style="white-space:pre">	</span>下文记录上述流程中涉及到的汇编函数（此处暂不记录DCT反变换的函数，在后文中再进行叙述）：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">4x4帧内预测汇编函数：H264PredContext -&gt; pred4x4[dir]()<br />16x16帧内预测汇编函数：H264PredContext -&gt; pred16x16[dir]()<br />Hadamard反变换汇编函数：H264DSPContext-&gt;h264_luma_dc_dequant_idct()</blockquote><br /><h3>帧内预测小知识</h3>帧内预测根据宏块左边和上边的边界像素值推算宏块内部的像素值，帧内预测的效果如下图所示。其中左边的图为图像原始画面，右边的图为经过帧内预测后没有叠加残差的画面。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420031313255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>H.264中有两种帧内预测模式：16x16亮度帧内预测模式和4x4亮度帧内预测模式。其中16x16帧内预测模式一共有4种，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420031326999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>这4种模式列表如下。<br /><div style="text-align: center;"><table border="1" cellspacing="0" cellpadding="0" width="500" align="center"> <tbody><tr>  <td valign="top"><p>模式</p></td>  <td valign="top"><p>描述</p></td> </tr> <tr>  <td valign="top"><p>Vertical</p></td>  <td valign="top"><p>由上边像素推出相应像素值</p></td> </tr> <tr>  <td valign="top"><p>Horizontal</p></td>  <td valign="top"><p>由左边像素推出相应像素值</p></td> </tr> <tr>  <td valign="top"><p>DC</p></td>  <td valign="top"><p>由上边和左边像素平均值推出相应像素值</p></td> </tr> <tr>  <td valign="top"><p>Plane</p></td>  <td valign="top"><p>由上边和左边像素推出相应像素值</p></td> </tr></tbody></table></div><br />4x4帧内预测模式一共有9种，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420031708932?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><p>从图中可以看出，这9种模式中前4种和16x16帧内预测方法是一样的。后面增加了几种独特的方向——箭头不再位于“口”中，而是位于“日”中。</p><p><br /></p><h3>帧内预测汇编函数的初始化</h3><span style="white-space:pre">	</span>FFmpeg H.264解码器中4x4帧内预测函数指针位于H264PredContext的pred4x4[]数组中，其中每一个元素指向一种4x4帧内预测模式。而16x16帧内预测函数指针位于H264PredContext的pred16x16[]数组中，其中每一个元素指向一种16x16帧内预测模式。<br /><span style="white-space:pre">	</span>在FFmpeg H.264解码器初始化的时候，会调用ff_h264_pred_init()根据系统的配置对H264PredContext中的这些帧内预测函数指针进行赋值。下面简单看一下ff_h264_pred_init()的定义。<br /><br /><h3>ff_h264_pred_init()</h3>ff_h264_pred_init()的定义位于libavcodec\h264pred.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_5_5959973" name="code" class="cpp">/**
 * Set the intra prediction function pointers.
 */
//初始化帧内预测相关的汇编函数
av_cold void ff_h264_pred_init(H264PredContext *h, int codec_id,
                               const int bit_depth,
                               int chroma_format_idc)
{
#undef FUNC
#undef FUNCC
#define FUNC(a, depth) a ## _ ## depth
#define FUNCC(a, depth) a ## _ ## depth ## _c
#define FUNCD(a) a ## _c
//好长的宏定义...（这种很长的宏定义在H.264解码器中似乎很普遍！）
//该宏用于给帧内预测模块的函数指针赋值
//注意参数为颜色位深度
#define H264_PRED(depth) \
    if(codec_id != AV_CODEC_ID_RV40){\
        if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {\
            h-&gt;pred4x4[VERT_PRED       ]= FUNCD(pred4x4_vertical_vp8);\
            h-&gt;pred4x4[HOR_PRED        ]= FUNCD(pred4x4_horizontal_vp8);\
        } else {\
            h-&gt;pred4x4[VERT_PRED       ]= FUNCC(pred4x4_vertical          , depth);\
            h-&gt;pred4x4[HOR_PRED        ]= FUNCC(pred4x4_horizontal        , depth);\
        }\
        h-&gt;pred4x4[DC_PRED             ]= FUNCC(pred4x4_dc                , depth);\
        if(codec_id == AV_CODEC_ID_SVQ3)\
            h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= FUNCD(pred4x4_down_left_svq3);\
        else\
            h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= FUNCC(pred4x4_down_left     , depth);\
        h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED]= FUNCC(pred4x4_down_right        , depth);\
        h-&gt;pred4x4[VERT_RIGHT_PRED     ]= FUNCC(pred4x4_vertical_right    , depth);\
        h-&gt;pred4x4[HOR_DOWN_PRED       ]= FUNCC(pred4x4_horizontal_down   , depth);\
        if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {\
            h-&gt;pred4x4[VERT_LEFT_PRED  ]= FUNCD(pred4x4_vertical_left_vp8);\
        } else\
            h-&gt;pred4x4[VERT_LEFT_PRED  ]= FUNCC(pred4x4_vertical_left     , depth);\
        h-&gt;pred4x4[HOR_UP_PRED         ]= FUNCC(pred4x4_horizontal_up     , depth);\
        if (codec_id != AV_CODEC_ID_VP7 &amp;&amp; codec_id != AV_CODEC_ID_VP8) {\
            h-&gt;pred4x4[LEFT_DC_PRED    ]= FUNCC(pred4x4_left_dc           , depth);\
            h-&gt;pred4x4[TOP_DC_PRED     ]= FUNCC(pred4x4_top_dc            , depth);\
        } else {\
            h-&gt;pred4x4[TM_VP8_PRED     ]= FUNCD(pred4x4_tm_vp8);\
            h-&gt;pred4x4[DC_127_PRED     ]= FUNCC(pred4x4_127_dc            , depth);\
            h-&gt;pred4x4[DC_129_PRED     ]= FUNCC(pred4x4_129_dc            , depth);\
            h-&gt;pred4x4[VERT_VP8_PRED   ]= FUNCC(pred4x4_vertical          , depth);\
            h-&gt;pred4x4[HOR_VP8_PRED    ]= FUNCC(pred4x4_horizontal        , depth);\
        }\
        if (codec_id != AV_CODEC_ID_VP8)\
            h-&gt;pred4x4[DC_128_PRED     ]= FUNCC(pred4x4_128_dc            , depth);\
    }else{\
        h-&gt;pred4x4[VERT_PRED           ]= FUNCC(pred4x4_vertical          , depth);\
        h-&gt;pred4x4[HOR_PRED            ]= FUNCC(pred4x4_horizontal        , depth);\
        h-&gt;pred4x4[DC_PRED             ]= FUNCC(pred4x4_dc                , depth);\
        h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= FUNCD(pred4x4_down_left_rv40);\
        h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED]= FUNCC(pred4x4_down_right        , depth);\
        h-&gt;pred4x4[VERT_RIGHT_PRED     ]= FUNCC(pred4x4_vertical_right    , depth);\
        h-&gt;pred4x4[HOR_DOWN_PRED       ]= FUNCC(pred4x4_horizontal_down   , depth);\
        h-&gt;pred4x4[VERT_LEFT_PRED      ]= FUNCD(pred4x4_vertical_left_rv40);\
        h-&gt;pred4x4[HOR_UP_PRED         ]= FUNCD(pred4x4_horizontal_up_rv40);\
        h-&gt;pred4x4[LEFT_DC_PRED        ]= FUNCC(pred4x4_left_dc           , depth);\
        h-&gt;pred4x4[TOP_DC_PRED         ]= FUNCC(pred4x4_top_dc            , depth);\
        h-&gt;pred4x4[DC_128_PRED         ]= FUNCC(pred4x4_128_dc            , depth);\
        h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED_RV40_NODOWN]= FUNCD(pred4x4_down_left_rv40_nodown);\
        h-&gt;pred4x4[HOR_UP_PRED_RV40_NODOWN]= FUNCD(pred4x4_horizontal_up_rv40_nodown);\
        h-&gt;pred4x4[VERT_LEFT_PRED_RV40_NODOWN]= FUNCD(pred4x4_vertical_left_rv40_nodown);\
    }\
\
    h-&gt;pred8x8l[VERT_PRED           ]= FUNCC(pred8x8l_vertical            , depth);\
    h-&gt;pred8x8l[HOR_PRED            ]= FUNCC(pred8x8l_horizontal          , depth);\
    h-&gt;pred8x8l[DC_PRED             ]= FUNCC(pred8x8l_dc                  , depth);\
    h-&gt;pred8x8l[DIAG_DOWN_LEFT_PRED ]= FUNCC(pred8x8l_down_left           , depth);\
    h-&gt;pred8x8l[DIAG_DOWN_RIGHT_PRED]= FUNCC(pred8x8l_down_right          , depth);\
    h-&gt;pred8x8l[VERT_RIGHT_PRED     ]= FUNCC(pred8x8l_vertical_right      , depth);\
    h-&gt;pred8x8l[HOR_DOWN_PRED       ]= FUNCC(pred8x8l_horizontal_down     , depth);\
    h-&gt;pred8x8l[VERT_LEFT_PRED      ]= FUNCC(pred8x8l_vertical_left       , depth);\
    h-&gt;pred8x8l[HOR_UP_PRED         ]= FUNCC(pred8x8l_horizontal_up       , depth);\
    h-&gt;pred8x8l[LEFT_DC_PRED        ]= FUNCC(pred8x8l_left_dc             , depth);\
    h-&gt;pred8x8l[TOP_DC_PRED         ]= FUNCC(pred8x8l_top_dc              , depth);\
    h-&gt;pred8x8l[DC_128_PRED         ]= FUNCC(pred8x8l_128_dc              , depth);\
\
    if (chroma_format_idc &lt;= 1) {\
        h-&gt;pred8x8[VERT_PRED8x8   ]= FUNCC(pred8x8_vertical               , depth);\
        h-&gt;pred8x8[HOR_PRED8x8    ]= FUNCC(pred8x8_horizontal             , depth);\
    } else {\
        h-&gt;pred8x8[VERT_PRED8x8   ]= FUNCC(pred8x16_vertical              , depth);\
        h-&gt;pred8x8[HOR_PRED8x8    ]= FUNCC(pred8x16_horizontal            , depth);\
    }\
    if (codec_id != AV_CODEC_ID_VP7 &amp;&amp; codec_id != AV_CODEC_ID_VP8) {\
        if (chroma_format_idc &lt;= 1) {\
            h-&gt;pred8x8[PLANE_PRED8x8]= FUNCC(pred8x8_plane                , depth);\
        } else {\
            h-&gt;pred8x8[PLANE_PRED8x8]= FUNCC(pred8x16_plane               , depth);\
        }\
    } else\
        h-&gt;pred8x8[PLANE_PRED8x8]= FUNCD(pred8x8_tm_vp8);\
    if (codec_id != AV_CODEC_ID_RV40 &amp;&amp; codec_id != AV_CODEC_ID_VP7 &amp;&amp; \
        codec_id != AV_CODEC_ID_VP8) {\
        if (chroma_format_idc &lt;= 1) {\
            h-&gt;pred8x8[DC_PRED8x8     ]= FUNCC(pred8x8_dc                     , depth);\
            h-&gt;pred8x8[LEFT_DC_PRED8x8]= FUNCC(pred8x8_left_dc                , depth);\
            h-&gt;pred8x8[TOP_DC_PRED8x8 ]= FUNCC(pred8x8_top_dc                 , depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_L0T_PRED8x8 ]= FUNC(pred8x8_mad_cow_dc_l0t, depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_0LT_PRED8x8 ]= FUNC(pred8x8_mad_cow_dc_0lt, depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_L00_PRED8x8 ]= FUNC(pred8x8_mad_cow_dc_l00, depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_0L0_PRED8x8 ]= FUNC(pred8x8_mad_cow_dc_0l0, depth);\
        } else {\
            h-&gt;pred8x8[DC_PRED8x8     ]= FUNCC(pred8x16_dc                    , depth);\
            h-&gt;pred8x8[LEFT_DC_PRED8x8]= FUNCC(pred8x16_left_dc               , depth);\
            h-&gt;pred8x8[TOP_DC_PRED8x8 ]= FUNCC(pred8x16_top_dc                , depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_L0T_PRED8x8 ]= FUNC(pred8x16_mad_cow_dc_l0t, depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_0LT_PRED8x8 ]= FUNC(pred8x16_mad_cow_dc_0lt, depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_L00_PRED8x8 ]= FUNC(pred8x16_mad_cow_dc_l00, depth);\
            h-&gt;pred8x8[ALZHEIMER_DC_0L0_PRED8x8 ]= FUNC(pred8x16_mad_cow_dc_0l0, depth);\
        }\
    }else{\
        h-&gt;pred8x8[DC_PRED8x8     ]= FUNCD(pred8x8_dc_rv40);\
        h-&gt;pred8x8[LEFT_DC_PRED8x8]= FUNCD(pred8x8_left_dc_rv40);\
        h-&gt;pred8x8[TOP_DC_PRED8x8 ]= FUNCD(pred8x8_top_dc_rv40);\
        if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {\
            h-&gt;pred8x8[DC_127_PRED8x8]= FUNCC(pred8x8_127_dc              , depth);\
            h-&gt;pred8x8[DC_129_PRED8x8]= FUNCC(pred8x8_129_dc              , depth);\
        }\
    }\
    if (chroma_format_idc &lt;= 1) {\
        h-&gt;pred8x8[DC_128_PRED8x8 ]= FUNCC(pred8x8_128_dc                 , depth);\
    } else {\
        h-&gt;pred8x8[DC_128_PRED8x8 ]= FUNCC(pred8x16_128_dc                , depth);\
    }\
\
    h-&gt;pred16x16[DC_PRED8x8     ]= FUNCC(pred16x16_dc                     , depth);\
    h-&gt;pred16x16[VERT_PRED8x8   ]= FUNCC(pred16x16_vertical               , depth);\
    h-&gt;pred16x16[HOR_PRED8x8    ]= FUNCC(pred16x16_horizontal             , depth);\
    switch(codec_id){\
    case AV_CODEC_ID_SVQ3:\
       h-&gt;pred16x16[PLANE_PRED8x8  ]= FUNCD(pred16x16_plane_svq3);\
       break;\
    case AV_CODEC_ID_RV40:\
       h-&gt;pred16x16[PLANE_PRED8x8  ]= FUNCD(pred16x16_plane_rv40);\
       break;\
    case AV_CODEC_ID_VP7:\
    case AV_CODEC_ID_VP8:\
       h-&gt;pred16x16[PLANE_PRED8x8  ]= FUNCD(pred16x16_tm_vp8);\
       h-&gt;pred16x16[DC_127_PRED8x8]= FUNCC(pred16x16_127_dc               , depth);\
       h-&gt;pred16x16[DC_129_PRED8x8]= FUNCC(pred16x16_129_dc               , depth);\
       break;\
    default:\
       h-&gt;pred16x16[PLANE_PRED8x8  ]= FUNCC(pred16x16_plane               , depth);\
       break;\
    }\
    h-&gt;pred16x16[LEFT_DC_PRED8x8]= FUNCC(pred16x16_left_dc                , depth);\
    h-&gt;pred16x16[TOP_DC_PRED8x8 ]= FUNCC(pred16x16_top_dc                 , depth);\
    h-&gt;pred16x16[DC_128_PRED8x8 ]= FUNCC(pred16x16_128_dc                 , depth);\
\
    /* special lossless h/v prediction for h264 */ \
    h-&gt;pred4x4_add  [VERT_PRED   ]= FUNCC(pred4x4_vertical_add            , depth);\
    h-&gt;pred4x4_add  [ HOR_PRED   ]= FUNCC(pred4x4_horizontal_add          , depth);\
    h-&gt;pred8x8l_add [VERT_PRED   ]= FUNCC(pred8x8l_vertical_add           , depth);\
    h-&gt;pred8x8l_add [ HOR_PRED   ]= FUNCC(pred8x8l_horizontal_add         , depth);\
    h-&gt;pred8x8l_filter_add [VERT_PRED   ]= FUNCC(pred8x8l_vertical_filter_add           , depth);\
    h-&gt;pred8x8l_filter_add [ HOR_PRED   ]= FUNCC(pred8x8l_horizontal_filter_add         , depth);\
    if (chroma_format_idc &lt;= 1) {\
    h-&gt;pred8x8_add  [VERT_PRED8x8]= FUNCC(pred8x8_vertical_add            , depth);\
    h-&gt;pred8x8_add  [ HOR_PRED8x8]= FUNCC(pred8x8_horizontal_add          , depth);\
    } else {\
        h-&gt;pred8x8_add  [VERT_PRED8x8]= FUNCC(pred8x16_vertical_add            , depth);\
        h-&gt;pred8x8_add  [ HOR_PRED8x8]= FUNCC(pred8x16_horizontal_add          , depth);\
    }\
    h-&gt;pred16x16_add[VERT_PRED8x8]= FUNCC(pred16x16_vertical_add          , depth);\
    h-&gt;pred16x16_add[ HOR_PRED8x8]= FUNCC(pred16x16_horizontal_add        , depth);\
    //注意这里使用了前面那个很长的宏定义
	//根据颜色位深的不同，初始化不同的函数
    //颜色位深默认值为8，所以一般情况下调用H264_PRED(8)
    switch (bit_depth) {
        case 9:
            H264_PRED(9)
            break;
        case 10:
            H264_PRED(10)
            break;
        case 12:
            H264_PRED(12)
            break;
        case 14:
            H264_PRED(14)
            break;
        default:
            av_assert0(bit_depth&lt;=8);
            H264_PRED(8)
            break;
    }


    //如果支持汇编优化，则会调用相应的汇编优化函数
    //neon这些的
    if (ARCH_ARM) ff_h264_pred_init_arm(h, codec_id, bit_depth, chroma_format_idc);
    //mmx这些的
    if (ARCH_X86) ff_h264_pred_init_x86(h, codec_id, bit_depth, chroma_format_idc);
}
</pre><br /><span style="white-space:pre">	</span>从源代码可以看出，ff_h264_pred_init()函数中包含一个名为“H264_PRED(depth)”的很长的宏定义。该宏定义中包含了C语言版本的帧内预测函数的初始化代码。ff_h264_pred_init()会根据系统的颜色位深bit_depth初始化相应的C语言版本的帧内预测函数。在函数的末尾则包含了汇编函数的初始化函数：如果系统是ARM架构的，则会调用ff_h264_pred_init_arm()初始化ARM平台下经过汇编优化的帧内预测函数；如果系统是X86架构的，则会调用ff_h264_pred_init_x86()初始化X86平台下经过汇编优化的帧内预测函数。<br />下面看一下C语言版本的帧内预测函数。<br /><br /><h3>C语言版本帧内预测函数</h3>“H264_PRED(depth)”宏用于初始化C语言版本的帧内预测函数。其中“depth”表示颜色位深。以最常见的8bit位深为例，展开“H264_PRED(8)”宏定义之后的代码如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_6_8071990" name="code" class="cpp">if(codec_id != AV_CODEC_ID_RV40){
	if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
		h-&gt;pred4x4[0       ]= pred4x4_vertical_vp8_c;
		h-&gt;pred4x4[1        ]= pred4x4_horizontal_vp8_c;
	} else {
		//帧内4x4的Vertical预测方式
		h-&gt;pred4x4[0       ]= pred4x4_vertical_8_c;
		//帧内4x4的Horizontal预测方式
		h-&gt;pred4x4[1        ]= pred4x4_horizontal_8_c;
	}
	//帧内4x4的DC预测方式
	h-&gt;pred4x4[2             ]= pred4x4_dc_8_c;
	if(codec_id == AV_CODEC_ID_SVQ3)
		h-&gt;pred4x4[3 ]= pred4x4_down_left_svq3_c;
	else
		h-&gt;pred4x4[3 ]= pred4x4_down_left_8_c;
	h-&gt;pred4x4[4]= pred4x4_down_right_8_c;
	h-&gt;pred4x4[5     ]= pred4x4_vertical_right_8_c;
	h-&gt;pred4x4[6       ]= pred4x4_horizontal_down_8_c;
	if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
		h-&gt;pred4x4[7  ]= pred4x4_vertical_left_vp8_c;
	} else
		h-&gt;pred4x4[7  ]= pred4x4_vertical_left_8_c;
	h-&gt;pred4x4[8         ]= pred4x4_horizontal_up_8_c;
	if (codec_id != AV_CODEC_ID_VP7 &amp;&amp; codec_id != AV_CODEC_ID_VP8) {
		h-&gt;pred4x4[9    ]= pred4x4_left_dc_8_c;
		h-&gt;pred4x4[10     ]= pred4x4_top_dc_8_c;
	} else {
		h-&gt;pred4x4[9     ]= pred4x4_tm_vp8_c;
		h-&gt;pred4x4[12     ]= pred4x4_127_dc_8_c;
		h-&gt;pred4x4[13     ]= pred4x4_129_dc_8_c;
		h-&gt;pred4x4[10   ]= pred4x4_vertical_8_c;
		h-&gt;pred4x4[14    ]= pred4x4_horizontal_8_c;
	}
	if (codec_id != AV_CODEC_ID_VP8)
		h-&gt;pred4x4[11     ]= pred4x4_128_dc_8_c;
}else{
	h-&gt;pred4x4[0           ]= pred4x4_vertical_8_c;
	h-&gt;pred4x4[1            ]= pred4x4_horizontal_8_c;
	h-&gt;pred4x4[2             ]= pred4x4_dc_8_c;
	h-&gt;pred4x4[3 ]= pred4x4_down_left_rv40_c;
	h-&gt;pred4x4[4]= pred4x4_down_right_8_c;
	h-&gt;pred4x4[5     ]= pred4x4_vertical_right_8_c;
	h-&gt;pred4x4[6       ]= pred4x4_horizontal_down_8_c;
	h-&gt;pred4x4[7      ]= pred4x4_vertical_left_rv40_c;
	h-&gt;pred4x4[8         ]= pred4x4_horizontal_up_rv40_c;
	h-&gt;pred4x4[9        ]= pred4x4_left_dc_8_c;
	h-&gt;pred4x4[10         ]= pred4x4_top_dc_8_c;
	h-&gt;pred4x4[11         ]= pred4x4_128_dc_8_c;
	h-&gt;pred4x4[12]= pred4x4_down_left_rv40_nodown_c;
	h-&gt;pred4x4[13]= pred4x4_horizontal_up_rv40_nodown_c;
	h-&gt;pred4x4[14]= pred4x4_vertical_left_rv40_nodown_c;
}

h-&gt;pred8x8l[0           ]= pred8x8l_vertical_8_c;
h-&gt;pred8x8l[1            ]= pred8x8l_horizontal_8_c;
h-&gt;pred8x8l[2             ]= pred8x8l_dc_8_c;
h-&gt;pred8x8l[3 ]= pred8x8l_down_left_8_c;
h-&gt;pred8x8l[4]= pred8x8l_down_right_8_c;
h-&gt;pred8x8l[5     ]= pred8x8l_vertical_right_8_c;
h-&gt;pred8x8l[6       ]= pred8x8l_horizontal_down_8_c;
h-&gt;pred8x8l[7      ]= pred8x8l_vertical_left_8_c;
h-&gt;pred8x8l[8         ]= pred8x8l_horizontal_up_8_c;
h-&gt;pred8x8l[9        ]= pred8x8l_left_dc_8_c;
h-&gt;pred8x8l[10         ]= pred8x8l_top_dc_8_c;
h-&gt;pred8x8l[11         ]= pred8x8l_128_dc_8_c;

if (chroma_format_idc &lt;= 1) {
	h-&gt;pred8x8[2   ]= pred8x8_vertical_8_c;
	h-&gt;pred8x8[1    ]= pred8x8_horizontal_8_c;
} else {
	h-&gt;pred8x8[2   ]= pred8x16_vertical_8_c;
	h-&gt;pred8x8[1    ]= pred8x16_horizontal_8_c;
}
if (codec_id != AV_CODEC_ID_VP7 &amp;&amp; codec_id != AV_CODEC_ID_VP8) {
	if (chroma_format_idc &lt;= 1) {
		h-&gt;pred8x8[3]= pred8x8_plane_8_c;
	} else {
		h-&gt;pred8x8[3]= pred8x16_plane_8_c;
	}
} else
	h-&gt;pred8x8[3]= pred8x8_tm_vp8_c;
if (codec_id != AV_CODEC_ID_RV40 &amp;&amp; codec_id != AV_CODEC_ID_VP7 &amp;&amp; 
	codec_id != AV_CODEC_ID_VP8) {
	if (chroma_format_idc &lt;= 1) {
		h-&gt;pred8x8[0     ]= pred8x8_dc_8_c;
		h-&gt;pred8x8[4]= pred8x8_left_dc_8_c;
		h-&gt;pred8x8[5 ]= pred8x8_top_dc_8_c;
		h-&gt;pred8x8[7 ]= pred8x8_mad_cow_dc_l0t_8;
		h-&gt;pred8x8[8 ]= pred8x8_mad_cow_dc_0lt_8;
		h-&gt;pred8x8[9 ]= pred8x8_mad_cow_dc_l00_8;
		h-&gt;pred8x8[10 ]= pred8x8_mad_cow_dc_0l0_8;
	} else {
		h-&gt;pred8x8[0     ]= pred8x16_dc_8_c;
		h-&gt;pred8x8[4]= pred8x16_left_dc_8_c;
		h-&gt;pred8x8[5 ]= pred8x16_top_dc_8_c;
		h-&gt;pred8x8[7 ]= pred8x16_mad_cow_dc_l0t_8;
		h-&gt;pred8x8[8 ]= pred8x16_mad_cow_dc_0lt_8;
		h-&gt;pred8x8[9 ]= pred8x16_mad_cow_dc_l00_8;
		h-&gt;pred8x8[10 ]= pred8x16_mad_cow_dc_0l0_8;
	}
}else{
	h-&gt;pred8x8[0     ]= pred8x8_dc_rv40_c;
	h-&gt;pred8x8[4]= pred8x8_left_dc_rv40_c;
	h-&gt;pred8x8[5 ]= pred8x8_top_dc_rv40_c;
	if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
		h-&gt;pred8x8[7]= pred8x8_127_dc_8_c;
		h-&gt;pred8x8[8]= pred8x8_129_dc_8_c;
	}
}
if (chroma_format_idc &lt;= 1) {
	h-&gt;pred8x8[6 ]= pred8x8_128_dc_8_c;
} else {
	h-&gt;pred8x8[6 ]= pred8x16_128_dc_8_c;
}

h-&gt;pred16x16[0     ]= pred16x16_dc_8_c;
h-&gt;pred16x16[2   ]= pred16x16_vertical_8_c;
h-&gt;pred16x16[1    ]= pred16x16_horizontal_8_c;
switch(codec_id){
case AV_CODEC_ID_SVQ3:
   h-&gt;pred16x16[3  ]= pred16x16_plane_svq3_c;
   break;
case AV_CODEC_ID_RV40:
   h-&gt;pred16x16[3  ]= pred16x16_plane_rv40_c;
   break;
case AV_CODEC_ID_VP7:
case AV_CODEC_ID_VP8:
   h-&gt;pred16x16[3  ]= pred16x16_tm_vp8_c;
   h-&gt;pred16x16[7]= pred16x16_127_dc_8_c;
   h-&gt;pred16x16[8]= pred16x16_129_dc_8_c;
   break;
default:
   h-&gt;pred16x16[3  ]= pred16x16_plane_8_c;
   break;
}
h-&gt;pred16x16[4]= pred16x16_left_dc_8_c;
h-&gt;pred16x16[5 ]= pred16x16_top_dc_8_c;
h-&gt;pred16x16[6 ]= pred16x16_128_dc_8_c;

/* special lossless h/v prediction for h264 */ 
h-&gt;pred4x4_add  [0   ]= pred4x4_vertical_add_8_c;
h-&gt;pred4x4_add  [ 1   ]= pred4x4_horizontal_add_8_c;
h-&gt;pred8x8l_add [0   ]= pred8x8l_vertical_add_8_c;
h-&gt;pred8x8l_add [ 1   ]= pred8x8l_horizontal_add_8_c;
h-&gt;pred8x8l_filter_add [0   ]= pred8x8l_vertical_filter_add_8_c;
h-&gt;pred8x8l_filter_add [ 1   ]= pred8x8l_horizontal_filter_add_8_c;
if (chroma_format_idc &lt;= 1) {
h-&gt;pred8x8_add  [2]= pred8x8_vertical_add_8_c;
h-&gt;pred8x8_add  [ 1]= pred8x8_horizontal_add_8_c;
} else {
	h-&gt;pred8x8_add  [2]= pred8x16_vertical_add_8_c;
	h-&gt;pred8x8_add  [ 1]= pred8x16_horizontal_add_8_c;
}
h-&gt;pred16x16_add[2]= pred16x16_vertical_add_8_c;
h-&gt;pred16x16_add[ 1]= pred16x16_horizontal_add_8_c;
</pre><br />可以看出在H264_PRED(8)展开后的代码中，帧内预测模块的函数指针都被赋值以xxxx_8_c()的函数。例如pred4x4[0]（帧内4x4的模式0）被赋值以pred4x4_vertical_8_c()；pred4x4[1]（帧内4x4的模式1）被赋值以pred4x4_horizontal_8_c()；pred4x4[2]（帧内4x4的模式2）被赋值以pred4x4_cd_8_c()，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_7_6562939" name="code" class="cpp">//帧内4x4的Vertical预测方式
h-&gt;pred4x4[0]= pred4x4_vertical_8_c;
//帧内4x4的Horizontal预测方式
h-&gt;pred4x4[1]= pred4x4_horizontal_8_c;
//帧内4x4的DC预测方式
h-&gt;pred4x4[2]= pred4x4_dc_8_c;</pre><br /><p>下面看一下这些4x4帧内预测函数的代码。</p><p><br /></p><h3>4x4帧内预测汇编函数：H264PredContext -&gt; pred4x4[dir]()</h3>4x4帧内预测函数指针位于H264PredContext的pred4x4[]数组中。pred4x4[]数组中每一个元素指向一种帧内预测模式。上文中提到的3个帧内预测函数实现的帧内预测功能如下图所示。<br /><div style="text-align: center;"><img src="https://img-blog.csdn.net/20150420031926408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>下面分别看看上文提到的3个4x4帧内预测函数。<br /><br /><h3>pred4x4_vertical_8_c()</h3>pred4x4_vertical_8_c()实现了4x4块Vertical模式的帧内预测，该函数的定义位于libavcodec\h264pred_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_8_2753376" name="code" class="cpp">/* 帧内预测
 *
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 * 参数：
 * _src：输入数据
 * _stride：一行像素的大小
 *
 */
//垂直预测
//由上边像素推出像素值
static void FUNCC(pred4x4_vertical)(uint8_t *_src, const uint8_t *topright,
                                    ptrdiff_t _stride)
{
    pixel *src = (pixel*)_src;
    int stride = _stride&gt;&gt;(sizeof(pixel)-1);

    /*
     * Vertical预测方式
     *   |X1 X2 X3 X4
     * --+-----------
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *
     */

    //pixel4代表4个像素值。1个像素值占用8bit，4个像素值占用32bit。
    const pixel4 a= AV_RN4PA(src-stride);
    /* 宏定义展开后：
     * const uint32_t a=(((const av_alias32*)(src-stride))-&gt;u32);
     * 注：av_alias32是一个union类型的变量，存储4byte数据。
     * -stride代表了上一行对应位置的像素
     * 即a取的是上1行像素的值。
     */
    AV_WN4PA(src+0*stride, a);
    AV_WN4PA(src+1*stride, a);
    AV_WN4PA(src+2*stride, a);
    AV_WN4PA(src+3*stride, a);

    /* 宏定义展开后：
     * (((av_alias32*)(src+0*stride))-&gt;u32 = (a));
     * (((av_alias32*)(src+1*stride))-&gt;u32 = (a));
     * (((av_alias32*)(src+2*stride))-&gt;u32 = (a));
     * (((av_alias32*)(src+3*stride))-&gt;u32 = (a));
     * 即把a的值赋给下面4行。
     */

}
</pre><br />从源代码可以看出，pred4x4_vertical_8_c()首先取了当前4x4块上一行的4个像素存入a变量，然后将a变量的值分别赋值给了当前块的4行。在这一有一点要注意：stride代表了一行像素的大小，“src+stride”代表了位于src正下方的像素。<br /><br /><h3>pred4x4_horizontal_8_c()</h3>pred4x4_horizontal_8_c()实现了4x4块Horizontal模式的帧内预测，该函数的定义位于libavcodec\h264pred_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_9_1767712" name="code" class="cpp">//水平预测
//由左边像素推出像素值
static void FUNCC(pred4x4_horizontal)(uint8_t *_src, const uint8_t *topright,
                                      ptrdiff_t _stride)
{
    pixel *src = (pixel*)_src;
    int stride = _stride&gt;&gt;(sizeof(pixel)-1);

    /*
     * Horizontal预测方式
     *   |
     * --+-----------
     * X5|X5 X5 X5 X5
     * X6|X6 X6 X6 X6
     * X7|X7 X7 X7 X7
     * X8|X8 X8 X8 X8
     *
     */

    AV_WN4PA(src+0*stride, PIXEL_SPLAT_X4(src[-1+0*stride]));
    AV_WN4PA(src+1*stride, PIXEL_SPLAT_X4(src[-1+1*stride]));
    AV_WN4PA(src+2*stride, PIXEL_SPLAT_X4(src[-1+2*stride]));
    AV_WN4PA(src+3*stride, PIXEL_SPLAT_X4(src[-1+3*stride]));
    /* 宏定义展开后：
     * (((av_alias32*)(src+0*stride))-&gt;u32 = (((src[-1+0*stride])*0x01010101U)));
     * (((av_alias32*)(src+1*stride))-&gt;u32 = (((src[-1+1*stride])*0x01010101U)));
     * (((av_alias32*)(src+2*stride))-&gt;u32 = (((src[-1+2*stride])*0x01010101U)));
     * (((av_alias32*)(src+3*stride))-&gt;u32 = (((src[-1+3*stride])*0x01010101U)));
     *
     * PIXEL_SPLAT_X4()的作用应该是把最后一个像素（最后8位）拷贝给前面3个像素（前24位）
     * 即把0x0100009F变成0x9F9F9F9F
     * 推导：
     * 前提是x占8bit（对应1个像素）
     * y=x*0x01010101
     *  =x*(0x00000001+0x00000100+0x00010000+0x01000000)
     *  =x&lt;&lt;0+x&lt;&lt;8+x&lt;&lt;16+x&lt;&lt;24
     *
     * 每行把src[-1]中像素值例如0x02赋值给src[0]开始的4个像素中，形成0x02020202
     */
}
</pre><br />从源代码可以看出，pred4x4_horizontal_8_c()将4x4块每行像素左边的一个像素拷贝了4份之后赋值给了当前行。其中PIXEL_SPLAT_X4()宏的定义如下：<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_10_9735271" name="code" class="cpp">#   define PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</pre>经过研究后发现该宏用于将32bit数据的最后8位复制3份分别赋值到原数据的8-16位、16-24位以及24-32位，即将低位8bit数据“复制”3份到高位上。详细的推导过程已经写在了代码注释中，就不再重复了。<br /><br /><h3>pred4x4_dc_8_c()</h3>pred4x4_dc_8_c()实现了4x4块DC模式的帧内预测，该函数的定义位于libavcodec\h264pred_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_11_5991748" name="code" class="cpp">//DC预测
//由左边和上边像素平均值推出像素值
static void FUNCC(pred4x4_dc)(uint8_t *_src, const uint8_t *topright,
                              ptrdiff_t _stride)
{
    pixel *src = (pixel*)_src;
    int stride = _stride&gt;&gt;(sizeof(pixel)-1);
    /*
     * DC预测方式
     *   |X1 X2 X3 X4
     * --+-----------
     * X5|
     * X6|     Y
     * X7|
     * X8|
     *
     * Y=(X1+X2+X3+X4+X5+X6+X7+X8)/8
     */
    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]
                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) &gt;&gt;3;
    const pixel4 a = PIXEL_SPLAT_X4(dc);

    AV_WN4PA(src+0*stride, a);
    AV_WN4PA(src+1*stride, a);
    AV_WN4PA(src+2*stride, a);
    AV_WN4PA(src+3*stride, a);
    /* 宏定义展开后：
     * (((av_alias32*)(src+0*stride))-&gt;u32 = (a))
     * (((av_alias32*)(src+1*stride))-&gt;u32 = (a))
     * (((av_alias32*)(src+2*stride))-&gt;u32 = (a))
     * (((av_alias32*)(src+3*stride))-&gt;u32 = (a))
     */
}
</pre><br />从源代码可以看出，pred4x4_dc_8_c()将4x4块左边和上边8个点的像素值相加后取了平均值，然后赋值到该4x4块中的所有像素点上。<br /><p>分析完4x4帧内预测模式的C语言函数之后，我们再看一下16x16帧内预测模式的C语言函数。</p><p><br /></p><h3>16x16帧内预测汇编函数：H264PredContext -&gt; pred16x16[dir] ()</h3>16x16帧内预测模式一共有4种。它们的效果和4x4帧内预测是类似的，如下所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420032405546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><h3>pred16x16_vertical_8_c()</h3>下面举例看一个16x16帧内预测Vertical模式的C语言函数pred16x16_vertical_8_c()，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_12_579002" name="code" class="cpp">//垂直预测
//由上面的函数推出像素值
static void FUNCC(pred16x16_vertical)(uint8_t *_src, ptrdiff_t _stride)
{
    /*
     * Vertical预测方式
     *   |X1 X2 X3 X4
     * --+-----------
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *   |X1 X2 X3 X4
     *
     */
    int i;
    pixel *src = (pixel*)_src;
    int stride = _stride&gt;&gt;(sizeof(pixel)-1);
    //pixel4实际上就是uint32_t，存储4个像素的值（每个像素8bit）
    //src-stride表示取上面一行像素的值
    //在这里取了16个像素的值，分别存入a，b，c，d四个变量
    const pixel4 a = AV_RN4PA(((pixel4*)(src-stride))+0);
    const pixel4 b = AV_RN4PA(((pixel4*)(src-stride))+1);
    const pixel4 c = AV_RN4PA(((pixel4*)(src-stride))+2);
    const pixel4 d = AV_RN4PA(((pixel4*)(src-stride))+3);
    //循环16行
    for(i=0; i&lt;16; i++){
    	//分别赋值每行（每次赋值4个像素，赋值4次）
        AV_WN4PA(((pixel4*)(src+i*stride))+0, a);
        AV_WN4PA(((pixel4*)(src+i*stride))+1, b);
        AV_WN4PA(((pixel4*)(src+i*stride))+2, c);
        AV_WN4PA(((pixel4*)(src+i*stride))+3, d);
    }
}
</pre><br />可以看出pred16x16_vertical_8_c()首先取了16x16块上面的一行像素（16个像素），然后循环16次分别赋值给了宏块的16行。<br /><br /><h3>Hadamard反变换汇编函数：H264DSPContext-&gt;h264_luma_dc_dequant_idct()</h3><p>在记录Hadamard反变换的源代码之前，先简单记录Hadamard变换的原理。</p><p><br /></p><h3>Hadamard变换小知识</h3><p>在H.264标准中，如果当前处理的图像宏块是色度块或帧内 16x16模式的亮度块，则需要在DCT变换后将其中各图像块的DCT变换系数矩阵W 中的DC系数按对应图像块顺序排序，组成新的矩阵Wd，再对Wd进行Hadamard 变换及量化。Hadamard变换的公式如下所示。</p><p style="text-align: center;"><img src="https://img-blog.csdn.net/20150420032419236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p>Hadamard变换的取值方法如图所示。16x16的亮度块中有16 个4x4 图像亮度块（16个大方块），每个4x4亮度块都包含了一个DC系数（每个大方块左上角的小方块）。在编码的过程中，需要将00，01，02…等一共16个系数组成一个4x4的矩阵再次进行Hadamard变换。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420032557757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>因此在解码帧内16x16亮度块的时候，需要在DCT反变换前先对DC系数进行Hadamard反变换。Hadamard反变换的公式如下所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420032616165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>可以将该矩阵乘法改造成为2次一维变换，例如先对量化矩阵的每行进行一维变换，然后对经行变换所得数据块的每列再应用一维变换。而一维变换又可以采用蝶形快速算法，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420032629877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>图中r=1的时候即Hadamard反变换（r=1/2是逆整数DCT 变换，后文再详细叙述）。<br /><br /><h3>Hadamard反变换的C语言版本函数</h3><p>FFmpeg H.264解码器中Hadamard反变换的函数指针是H264DSPContext的h264_luma_dc_dequant_idct()。在初始化的时候，其指向ff_h264_chroma_dc_dequant_idct_8_c()函数。下面看一下该函数的定义。</p><p><br /></p><h3>ff_h264_chroma_dc_dequant_idct_8_c()</h3>ff_h264_chroma_dc_dequant_idct_8_c()完成了Hadamard反变换，其定义位于libavcodec\h264idct_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_13_5199274" name="code" class="cpp">/**
 * IDCT transforms the 16 dc values and dequantizes them.
 * @param qmul quantization parameter
 */
//DCT直流系数的Hadamard反变换-亮度
//16x16宏块中一共有16个4x4的图像块，因此包含了16个DCT直流系数
//
void FUNCC(ff_h264_luma_dc_dequant_idct)(int16_t *_output, int16_t *_input, int qmul){
#define stride 16
    int i;
    int temp[16];
    static const uint8_t x_offset[4]={0, 2*stride, 8*stride, 10*stride};
    dctcoef *input = (dctcoef*)_input;
    dctcoef *output = (dctcoef*)_output;

    for(i=0; i&lt;4; i++){
        const int z0= input[4*i+0] + input[4*i+1];
        const int z1= input[4*i+0] - input[4*i+1];
        const int z2= input[4*i+2] - input[4*i+3];
        const int z3= input[4*i+2] + input[4*i+3];

        temp[4*i+0]= z0+z3;
        temp[4*i+1]= z0-z3;
        temp[4*i+2]= z1-z2;
        temp[4*i+3]= z1+z2;
    }

    for(i=0; i&lt;4; i++){
        const int offset= x_offset[i];
        const int z0= temp[4*0+i] + temp[4*2+i];
        const int z1= temp[4*0+i] - temp[4*2+i];
        const int z2= temp[4*1+i] - temp[4*3+i];
        const int z3= temp[4*1+i] + temp[4*3+i];

        output[stride* 0+offset]= ((((z0 + z3)*qmul + 128 ) &gt;&gt; 8));
        output[stride* 1+offset]= ((((z1 + z2)*qmul + 128 ) &gt;&gt; 8));
        output[stride* 4+offset]= ((((z1 - z2)*qmul + 128 ) &gt;&gt; 8));
        output[stride* 5+offset]= ((((z0 - z3)*qmul + 128 ) &gt;&gt; 8));
    }
#undef stride
}
</pre><br />从源代码可以看出，ff_h264_chroma_dc_dequant_idct_8_c()实现了Hadamard反变换的蝶形算法。<br /><br /><h3>Intel汇编语言版本帧内预测函数：基于MMX指令集和SSE指令集</h3><p>前文记录的都是C语言版本的帧内预测函数，作为对比，在此记录2个Intel汇编语言版本帧内预测函数ff_pred16x16_vertical_8_mmx()和ff_pred16x16_vertical_8_sse()。在记录该函数之前首先回顾一下前文中提到的帧内预测初始化函数ff_h264_pred_init()。该函数的末尾进行了一个判断：如果支持ARM架构，则会调用ff_h264_pred_init_arm()初始化ARM平台的汇编函数；如果支持X86架构，则会调用ff_h264_pred_init_x86()初始化X86平台的汇编函数。在这里以X86平台为例，看一下X86平台帧内预测初始化函数ff_h264_pred_init_x86()。</p><p><br /></p><h3>ff_h264_pred_init_x86()</h3>ff_h264_pred_init_x86()的定义位于libavcodec\x86\h264_intrapred_init.c（注意位于libavcodec的子文件夹x86下），如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_14_2884210" name="code" class="cpp">av_cold void ff_h264_pred_init_x86(H264PredContext *h, int codec_id,
                                   const int bit_depth,
                                   const int chroma_format_idc)
{
    int cpu_flags = av_get_cpu_flags();

    if (bit_depth == 8) {
        if (EXTERNAL_MMX(cpu_flags)) {
            h-&gt;pred16x16[VERT_PRED8x8         ] = ff_pred16x16_vertical_8_mmx;
            h-&gt;pred16x16[HOR_PRED8x8          ] = ff_pred16x16_horizontal_8_mmx;
            if (chroma_format_idc &lt;= 1) {
                h-&gt;pred8x8  [VERT_PRED8x8     ] = ff_pred8x8_vertical_8_mmx;
                h-&gt;pred8x8  [HOR_PRED8x8      ] = ff_pred8x8_horizontal_8_mmx;
            }
            if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
                h-&gt;pred16x16[PLANE_PRED8x8    ] = ff_pred16x16_tm_vp8_8_mmx;
                h-&gt;pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_mmx;
                h-&gt;pred4x4  [TM_VP8_PRED      ] = ff_pred4x4_tm_vp8_8_mmx;
            } else {
                if (chroma_format_idc &lt;= 1)
                    h-&gt;pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_mmx;
                if (codec_id == AV_CODEC_ID_SVQ3) {
                    if (cpu_flags &amp; AV_CPU_FLAG_CMOV)
                        h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_svq3_8_mmx;
                } else if (codec_id == AV_CODEC_ID_RV40) {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_rv40_8_mmx;
                } else {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_h264_8_mmx;
                }
            }
        }

        if (EXTERNAL_MMXEXT(cpu_flags)) {
            h-&gt;pred16x16[HOR_PRED8x8            ] = ff_pred16x16_horizontal_8_mmxext;
            h-&gt;pred16x16[DC_PRED8x8             ] = ff_pred16x16_dc_8_mmxext;
            if (chroma_format_idc &lt;= 1)
                h-&gt;pred8x8[HOR_PRED8x8          ] = ff_pred8x8_horizontal_8_mmxext;
            h-&gt;pred8x8l [TOP_DC_PRED            ] = ff_pred8x8l_top_dc_8_mmxext;
            h-&gt;pred8x8l [DC_PRED                ] = ff_pred8x8l_dc_8_mmxext;
            h-&gt;pred8x8l [HOR_PRED               ] = ff_pred8x8l_horizontal_8_mmxext;
            h-&gt;pred8x8l [VERT_PRED              ] = ff_pred8x8l_vertical_8_mmxext;
            h-&gt;pred8x8l [DIAG_DOWN_RIGHT_PRED   ] = ff_pred8x8l_down_right_8_mmxext;
            h-&gt;pred8x8l [VERT_RIGHT_PRED        ] = ff_pred8x8l_vertical_right_8_mmxext;
            h-&gt;pred8x8l [HOR_UP_PRED            ] = ff_pred8x8l_horizontal_up_8_mmxext;
            h-&gt;pred8x8l [DIAG_DOWN_LEFT_PRED    ] = ff_pred8x8l_down_left_8_mmxext;
            h-&gt;pred8x8l [HOR_DOWN_PRED          ] = ff_pred8x8l_horizontal_down_8_mmxext;
            h-&gt;pred4x4  [DIAG_DOWN_RIGHT_PRED   ] = ff_pred4x4_down_right_8_mmxext;
            h-&gt;pred4x4  [VERT_RIGHT_PRED        ] = ff_pred4x4_vertical_right_8_mmxext;
            h-&gt;pred4x4  [HOR_DOWN_PRED          ] = ff_pred4x4_horizontal_down_8_mmxext;
            h-&gt;pred4x4  [DC_PRED                ] = ff_pred4x4_dc_8_mmxext;
            if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8 ||
                codec_id == AV_CODEC_ID_H264) {
                h-&gt;pred4x4  [DIAG_DOWN_LEFT_PRED] = ff_pred4x4_down_left_8_mmxext;
            }
            if (codec_id == AV_CODEC_ID_SVQ3 || codec_id == AV_CODEC_ID_H264) {
                h-&gt;pred4x4  [VERT_LEFT_PRED     ] = ff_pred4x4_vertical_left_8_mmxext;
            }
            if (codec_id != AV_CODEC_ID_RV40) {
                h-&gt;pred4x4  [HOR_UP_PRED        ] = ff_pred4x4_horizontal_up_8_mmxext;
            }
            if (codec_id == AV_CODEC_ID_SVQ3 || codec_id == AV_CODEC_ID_H264) {
                if (chroma_format_idc &lt;= 1) {
                    h-&gt;pred8x8[TOP_DC_PRED8x8   ] = ff_pred8x8_top_dc_8_mmxext;
                    h-&gt;pred8x8[DC_PRED8x8       ] = ff_pred8x8_dc_8_mmxext;
                }
            }
            if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
                h-&gt;pred16x16[PLANE_PRED8x8      ] = ff_pred16x16_tm_vp8_8_mmxext;
                h-&gt;pred8x8  [DC_PRED8x8         ] = ff_pred8x8_dc_rv40_8_mmxext;
                h-&gt;pred8x8  [PLANE_PRED8x8      ] = ff_pred8x8_tm_vp8_8_mmxext;
                h-&gt;pred4x4  [TM_VP8_PRED        ] = ff_pred4x4_tm_vp8_8_mmxext;
                h-&gt;pred4x4  [VERT_PRED          ] = ff_pred4x4_vertical_vp8_8_mmxext;
            } else {
                if (chroma_format_idc &lt;= 1)
                    h-&gt;pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_mmxext;
                if (codec_id == AV_CODEC_ID_SVQ3) {
                    h-&gt;pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_svq3_8_mmxext;
                } else if (codec_id == AV_CODEC_ID_RV40) {
                    h-&gt;pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_rv40_8_mmxext;
                } else {
                    h-&gt;pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_h264_8_mmxext;
                }
            }
        }

        if (EXTERNAL_SSE(cpu_flags)) {
            h-&gt;pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_8_sse;
        }

        if (EXTERNAL_SSE2(cpu_flags)) {
            h-&gt;pred16x16[DC_PRED8x8           ] = ff_pred16x16_dc_8_sse2;
            h-&gt;pred8x8l [DIAG_DOWN_LEFT_PRED  ] = ff_pred8x8l_down_left_8_sse2;
            h-&gt;pred8x8l [DIAG_DOWN_RIGHT_PRED ] = ff_pred8x8l_down_right_8_sse2;
            h-&gt;pred8x8l [VERT_RIGHT_PRED      ] = ff_pred8x8l_vertical_right_8_sse2;
            h-&gt;pred8x8l [VERT_LEFT_PRED       ] = ff_pred8x8l_vertical_left_8_sse2;
            h-&gt;pred8x8l [HOR_DOWN_PRED        ] = ff_pred8x8l_horizontal_down_8_sse2;
            if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
                h-&gt;pred16x16[PLANE_PRED8x8    ] = ff_pred16x16_tm_vp8_8_sse2;
                h-&gt;pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_sse2;
            } else {
                if (chroma_format_idc &lt;= 1)
                    h-&gt;pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_sse2;
                if (codec_id == AV_CODEC_ID_SVQ3) {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_svq3_8_sse2;
                } else if (codec_id == AV_CODEC_ID_RV40) {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_rv40_8_sse2;
                } else {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_h264_8_sse2;
                }
            }
        }

        if (EXTERNAL_SSSE3(cpu_flags)) {
            h-&gt;pred16x16[HOR_PRED8x8          ] = ff_pred16x16_horizontal_8_ssse3;
            h-&gt;pred16x16[DC_PRED8x8           ] = ff_pred16x16_dc_8_ssse3;
            if (chroma_format_idc &lt;= 1)
                h-&gt;pred8x8  [HOR_PRED8x8      ] = ff_pred8x8_horizontal_8_ssse3;
            h-&gt;pred8x8l [TOP_DC_PRED          ] = ff_pred8x8l_top_dc_8_ssse3;
            h-&gt;pred8x8l [DC_PRED              ] = ff_pred8x8l_dc_8_ssse3;
            h-&gt;pred8x8l [HOR_PRED             ] = ff_pred8x8l_horizontal_8_ssse3;
            h-&gt;pred8x8l [VERT_PRED            ] = ff_pred8x8l_vertical_8_ssse3;
            h-&gt;pred8x8l [DIAG_DOWN_LEFT_PRED  ] = ff_pred8x8l_down_left_8_ssse3;
            h-&gt;pred8x8l [DIAG_DOWN_RIGHT_PRED ] = ff_pred8x8l_down_right_8_ssse3;
            h-&gt;pred8x8l [VERT_RIGHT_PRED      ] = ff_pred8x8l_vertical_right_8_ssse3;
            h-&gt;pred8x8l [VERT_LEFT_PRED       ] = ff_pred8x8l_vertical_left_8_ssse3;
            h-&gt;pred8x8l [HOR_UP_PRED          ] = ff_pred8x8l_horizontal_up_8_ssse3;
            h-&gt;pred8x8l [HOR_DOWN_PRED        ] = ff_pred8x8l_horizontal_down_8_ssse3;
            if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
                h-&gt;pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_ssse3;
                h-&gt;pred4x4  [TM_VP8_PRED      ] = ff_pred4x4_tm_vp8_8_ssse3;
            } else {
                if (chroma_format_idc &lt;= 1)
                    h-&gt;pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_ssse3;
                if (codec_id == AV_CODEC_ID_SVQ3) {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_svq3_8_ssse3;
                } else if (codec_id == AV_CODEC_ID_RV40) {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_rv40_8_ssse3;
                } else {
                    h-&gt;pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_h264_8_ssse3;
                }
            }
        }
    } else if (bit_depth == 10) {
        if (EXTERNAL_MMXEXT(cpu_flags)) {
            h-&gt;pred4x4[DC_PRED             ] = ff_pred4x4_dc_10_mmxext;
            h-&gt;pred4x4[HOR_UP_PRED         ] = ff_pred4x4_horizontal_up_10_mmxext;

            if (chroma_format_idc &lt;= 1)
                h-&gt;pred8x8[DC_PRED8x8      ] = ff_pred8x8_dc_10_mmxext;

            h-&gt;pred8x8l[DC_128_PRED        ] = ff_pred8x8l_128_dc_10_mmxext;

            h-&gt;pred16x16[DC_PRED8x8        ] = ff_pred16x16_dc_10_mmxext;
            h-&gt;pred16x16[TOP_DC_PRED8x8    ] = ff_pred16x16_top_dc_10_mmxext;
            h-&gt;pred16x16[DC_128_PRED8x8    ] = ff_pred16x16_128_dc_10_mmxext;
            h-&gt;pred16x16[LEFT_DC_PRED8x8   ] = ff_pred16x16_left_dc_10_mmxext;
            h-&gt;pred16x16[VERT_PRED8x8      ] = ff_pred16x16_vertical_10_mmxext;
            h-&gt;pred16x16[HOR_PRED8x8       ] = ff_pred16x16_horizontal_10_mmxext;
        }
        if (EXTERNAL_SSE2(cpu_flags)) {
            h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ] = ff_pred4x4_down_left_10_sse2;
            h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED] = ff_pred4x4_down_right_10_sse2;
            h-&gt;pred4x4[VERT_LEFT_PRED      ] = ff_pred4x4_vertical_left_10_sse2;
            h-&gt;pred4x4[VERT_RIGHT_PRED     ] = ff_pred4x4_vertical_right_10_sse2;
            h-&gt;pred4x4[HOR_DOWN_PRED       ] = ff_pred4x4_horizontal_down_10_sse2;

            if (chroma_format_idc &lt;= 1) {
                h-&gt;pred8x8[DC_PRED8x8      ] = ff_pred8x8_dc_10_sse2;
                h-&gt;pred8x8[TOP_DC_PRED8x8  ] = ff_pred8x8_top_dc_10_sse2;
                h-&gt;pred8x8[PLANE_PRED8x8   ] = ff_pred8x8_plane_10_sse2;
                h-&gt;pred8x8[VERT_PRED8x8    ] = ff_pred8x8_vertical_10_sse2;
                h-&gt;pred8x8[HOR_PRED8x8     ] = ff_pred8x8_horizontal_10_sse2;
            }

            h-&gt;pred8x8l[VERT_PRED           ] = ff_pred8x8l_vertical_10_sse2;
            h-&gt;pred8x8l[HOR_PRED            ] = ff_pred8x8l_horizontal_10_sse2;
            h-&gt;pred8x8l[DC_PRED             ] = ff_pred8x8l_dc_10_sse2;
            h-&gt;pred8x8l[DC_128_PRED         ] = ff_pred8x8l_128_dc_10_sse2;
            h-&gt;pred8x8l[TOP_DC_PRED         ] = ff_pred8x8l_top_dc_10_sse2;
            h-&gt;pred8x8l[DIAG_DOWN_LEFT_PRED ] = ff_pred8x8l_down_left_10_sse2;
            h-&gt;pred8x8l[DIAG_DOWN_RIGHT_PRED] = ff_pred8x8l_down_right_10_sse2;
            h-&gt;pred8x8l[VERT_RIGHT_PRED     ] = ff_pred8x8l_vertical_right_10_sse2;
            h-&gt;pred8x8l[HOR_UP_PRED         ] = ff_pred8x8l_horizontal_up_10_sse2;

            h-&gt;pred16x16[DC_PRED8x8        ] = ff_pred16x16_dc_10_sse2;
            h-&gt;pred16x16[TOP_DC_PRED8x8    ] = ff_pred16x16_top_dc_10_sse2;
            h-&gt;pred16x16[DC_128_PRED8x8    ] = ff_pred16x16_128_dc_10_sse2;
            h-&gt;pred16x16[LEFT_DC_PRED8x8   ] = ff_pred16x16_left_dc_10_sse2;
            h-&gt;pred16x16[VERT_PRED8x8      ] = ff_pred16x16_vertical_10_sse2;
            h-&gt;pred16x16[HOR_PRED8x8       ] = ff_pred16x16_horizontal_10_sse2;
        }
        if (EXTERNAL_SSSE3(cpu_flags)) {
            h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED] = ff_pred4x4_down_right_10_ssse3;
            h-&gt;pred4x4[VERT_RIGHT_PRED     ] = ff_pred4x4_vertical_right_10_ssse3;
            h-&gt;pred4x4[HOR_DOWN_PRED       ] = ff_pred4x4_horizontal_down_10_ssse3;

            h-&gt;pred8x8l[HOR_PRED            ] = ff_pred8x8l_horizontal_10_ssse3;
            h-&gt;pred8x8l[DIAG_DOWN_LEFT_PRED ] = ff_pred8x8l_down_left_10_ssse3;
            h-&gt;pred8x8l[DIAG_DOWN_RIGHT_PRED] = ff_pred8x8l_down_right_10_ssse3;
            h-&gt;pred8x8l[VERT_RIGHT_PRED     ] = ff_pred8x8l_vertical_right_10_ssse3;
            h-&gt;pred8x8l[HOR_UP_PRED         ] = ff_pred8x8l_horizontal_up_10_ssse3;
        }
        if (EXTERNAL_AVX(cpu_flags)) {
            h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ] = ff_pred4x4_down_left_10_avx;
            h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED] = ff_pred4x4_down_right_10_avx;
            h-&gt;pred4x4[VERT_LEFT_PRED      ] = ff_pred4x4_vertical_left_10_avx;
            h-&gt;pred4x4[VERT_RIGHT_PRED     ] = ff_pred4x4_vertical_right_10_avx;
            h-&gt;pred4x4[HOR_DOWN_PRED       ] = ff_pred4x4_horizontal_down_10_avx;

            h-&gt;pred8x8l[VERT_PRED           ] = ff_pred8x8l_vertical_10_avx;
            h-&gt;pred8x8l[HOR_PRED            ] = ff_pred8x8l_horizontal_10_avx;
            h-&gt;pred8x8l[DC_PRED             ] = ff_pred8x8l_dc_10_avx;
            h-&gt;pred8x8l[TOP_DC_PRED         ] = ff_pred8x8l_top_dc_10_avx;
            h-&gt;pred8x8l[DIAG_DOWN_RIGHT_PRED] = ff_pred8x8l_down_right_10_avx;
            h-&gt;pred8x8l[DIAG_DOWN_LEFT_PRED ] = ff_pred8x8l_down_left_10_avx;
            h-&gt;pred8x8l[VERT_RIGHT_PRED     ] = ff_pred8x8l_vertical_right_10_avx;
            h-&gt;pred8x8l[HOR_UP_PRED         ] = ff_pred8x8l_horizontal_up_10_avx;
        }
    }
}
</pre><br />从源代码可以看出，ff_h264_pred_init_x86()根据平台支持指令集的不同，将很多形如“XXX_mmx()”，“XXX_sse2()”，“XXX_ssse3()”，“XXX_avx()”的函数赋值给了H264PredContext中的帧内预测函数指针。在这里我们看2个针对16x16帧内预测Vertical模式优化的汇编函数：基于MMX指令集ff_pred16x16_vertical_8_mmx()和基于SSE指令集的ff_pred16x16_vertical_8_sse()。<br /><br /><h3>ff_pred16x16_vertical_8_mmx()</h3>ff_pred16x16_vertical_8_mmx()的函数定义位于libavcodec\x86\h264_intrapred.asm，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_15_12738" name="code" class="plain">;-----------------------------------------------------------------------------
; void ff_pred16x16_vertical_8(uint8_t *src, int stride)
; 注释：雷霄骅
; 16x16帧内预测-Vertical
;
; Vertical预测方式
;   |X1 X2 X3 X4
; --+-----------
;   |X1 X2 X3 X4
;   |X1 X2 X3 X4
;   |X1 X2 X3 X4
;   |X1 X2 X3 X4
;
;-----------------------------------------------------------------------------
;mmx指令优化
INIT_MMX mmx
cglobal pred16x16_vertical_8, 2,3
                           ;C语言调用汇编的时候，r0接收第1个参数（src），r1接收第2个参数（stride）......
    sub   r0, r1           ;r0=r0-r1。只有r0和r1可以作为地址寄存器，在这里里面存储的是地址（r2-r7不可以）
                           ;此时r0指向16x16块上面一行像素数据
    mov   r2, 8            ;r2=8;r2为循环计数器，每次循环减1，r2为0的时候，循环停止
    movq mm0, [r0+0]       ;类似于memcpy(&amp;mm0,r0,8)。movq传递64bit（8字节，对应8像素）数据。“[]”代表传送r0地址的数据.
                           ;即将宏块上面1行像素中前8个像素传入mm0（用于循环中的赋值）
                           ;注：MOV-1~2字节（word），MOVD-4字节（Dword），MOVQ-8字节（Qword）
    movq mm1, [r0+8]       ;类似于memcpy(&amp;mm1,r0+8,8)。2次movq传递128bit（16个像素）。mm0和mm1中存储了宏块上方一行像素的值
                           ;即将宏块上面1行像素中后8个像素传入mm1
.loop:                     ;循环
    movq [r0+r1*1+0], mm0  ;类似于memcpy(r0+r1,&amp;mm0,8)。第1次循环，拷贝mm0至宏块第1行前8个像素。
    movq [r0+r1*1+8], mm1  ;类似于memcpy(r0+r1+8,&amp;mm1,8)。第1次循环，拷贝mm1至宏块第1行后8个像素。
    movq [r0+r1*2+0], mm0  ;类似于memcpy(r0+r1*2,&amp;mm0,8)。第1次循环，拷贝mm0至宏块第2行前8个像素。
    movq [r0+r1*2+8], mm1  ;类似于memcpy(r0+r1*2+8,&amp;mm1,8)。第1次循环，拷贝mm1至宏块第2行后8个像素。
                           ;总而言之，一次处理2行，16行像素一共处理8次
    lea   r0, [r0+r1*2]    ;r0=r0+r1*2。r0前移2行。注意“lea”是传送地址的指令
    dec   r2               ;r2--;
    jg .loop               ;r2=0时候，不再跳转
    REP_RET
</pre><br />由于对汇编语言并不算很熟悉，因此对ff_pred16x16_vertical_8_mmx()中的每行函数都进行了注释并类比了C语言中等同的方法。从代码中可以看出，由于MMX指令集支持通过“MOVQ”指令一次性处理64bit（8字节，即8个像素点）数据，所以基于MMX指令集优化后的函数调用32次“MOVQ”即可完成16x16帧内预测Vertical模式的像素赋值工作（循环“loop”执行8次）。<br />下面再看一个针对SSE指令集优化过的函数ff_pred16x16_vertical_8_sse()。由于SSE指令集比MMX指令集更为先进，所以ff_pred16x16_vertical_8_sse()的效率比ff_pred16x16_vertical_8_mmx()还要高。<br /><br /><h3>ff_pred16x16_vertical_8_sse()</h3>ff_pred16x16_vertical_8_sse()的函数定义位于libavcodec\x86\h264_intrapred.asm，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_16_1535329" name="code" class="plain">;sse指令优化
INIT_XMM sse
cglobal pred16x16_vertical_8, 2,3
    sub   r0, r1           ;r0=r0-r1。r0取值为src；r1取值为stride。此时r0指向16x16块上面一行像素数据
    mov   r2, 4            ;r2=4;r2为循环计数器，每次循环减1，r2为0的时候，循环停止
    movaps xmm0, [r0]      ;类似于memcpy(&amp;xmm0,r0,16)。movaps传递128bit（16字节，对应16像素）数据
.loop:                     ;循环
    movaps [r0+r1*1], xmm0 ;类似于memcpy(r0+r1,&amp;xmm0,16)。第1次循环，拷贝xmm0至宏块第1行16个像素。
    movaps [r0+r1*2], xmm0 ;类似于memcpy(r0+r1*2,&amp;xmm0,16)。第1次循环，拷贝xmm0至宏块第2行16个像素。
    lea   r0, [r0+r1*2]    ;r0=r0+r1*2。r0前移2行。
    movaps [r0+r1*1], xmm0 ;类似于memcpy(r0+r1,&amp;xmm0,16)。第1次循环，拷贝xmm0至宏块第1行16个像素。
    movaps [r0+r1*2], xmm0 ;类似于memcpy(r0+r1*2,&amp;xmm0,16)。第1次循环，拷贝xmm0至宏块第2行16个像素。
    lea   r0, [r0+r1*2]    ;r0=r0+r1*2。r0再次前移2行。
                           ;注：一次循环处理了4行像素。16行像素一共处理4次
    dec   r2               ;r2--;
    jg .loop               ;r2=0时候，不再跳转
    REP_RET
</pre><br />从源代码可以看出，由于SSE指令集支持通过“MOVAPS”指令支持一次性处理128bit（16字节，即16个像素点）数据，所以基于MMX指令集优化后的函数调用16次“MOVAPS”即可完成16x16帧内预测Vertical模式的像素赋值工作（循环“loop”执行4次）。<br /><br />至此有关FFmpeg H.264解码器帧内预测的部分的源代码就基本分析完毕了。下面分析处理帧内预测宏块的第二个步骤：残差数据的DCT反变化和叠加。<br /><br /><br /><h2>hl_decode_mb_idct_luma()</h2>hl_decode_mb_idct_luma()对宏块的亮度残差进行进行DCT反变换，并且将残差数据叠加到前面阵内或者帧间预测得到的预测数据上（需要注意实际上“DCT反变换”和“叠加”两个步骤是同时完成的）。该函数的定义位于libavcodec\h264_mb.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_17_9677612" name="code" class="cpp">//亮度的IDCT
static av_always_inline void hl_decode_mb_idct_luma(H264Context *h, int mb_type,
                                                    int is_h264, int simple,
                                                    int transform_bypass,
                                                    int pixel_shift,
                                                    int *block_offset,
                                                    int linesize,
                                                    uint8_t *dest_y, int p)
{
	//用于IDCT
    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);
    int i;
    block_offset += 16 * p;
    //Intra4x4的DCT反变换在pred部分已经完成，这里就不需要处理了
    if (!IS_INTRA4x4(mb_type)) {
        if (is_h264) {
        	//Intra16x16宏块
            if (IS_INTRA16x16(mb_type)) {
            	//transform_bypass=0，不考虑
                if (transform_bypass) {
                    if (h-&gt;sps.profile_idc == 244 &amp;&amp;
                        (h-&gt;intra16x16_pred_mode == VERT_PRED8x8 ||
                         h-&gt;intra16x16_pred_mode == HOR_PRED8x8)) {
                        h-&gt;hpc.pred16x16_add[h-&gt;intra16x16_pred_mode](dest_y, block_offset,
                                                                      h-&gt;mb + (p * 256 &lt;&lt; pixel_shift),
                                                                      linesize);
                    } else {
                        for (i = 0; i &lt; 16; i++)
                            if (h-&gt;non_zero_count_cache[scan8[i + p * 16]] ||
                                dctcoef_get(h-&gt;mb, pixel_shift, i * 16 + p * 256))
                                h-&gt;h264dsp.h264_add_pixels4_clear(dest_y + block_offset[i],
                                                                  h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift),
                                                                  linesize);
                    }
                } else {
                	//Intra16x16的DCT反变换
                	//最后的“16”代表内部循环处理16次
                    h-&gt;h264dsp.h264_idct_add16intra(dest_y, block_offset,
                                                    h-&gt;mb + (p * 256 &lt;&lt; pixel_shift),
                                                    linesize,
                                                    h-&gt;non_zero_count_cache + p * 5 * 8);
                }
            } else if (h-&gt;cbp &amp; 15) {//15=1111，即残差全部传送了
            	//Inter类型的宏块


            	//transform_bypass=0，不考虑
                if (transform_bypass) {
                    const int di = IS_8x8DCT(mb_type) ? 4 : 1;
                    idct_add = IS_8x8DCT(mb_type) ? h-&gt;h264dsp.h264_add_pixels8_clear
                                                  : h-&gt;h264dsp.h264_add_pixels4_clear;
                    for (i = 0; i &lt; 16; i += di)
                        if (h-&gt;non_zero_count_cache[scan8[i + p * 16]])
                            idct_add(dest_y + block_offset[i],
                                     h-&gt;mb + (i * 16 + p * 256 &lt;&lt; pixel_shift),
                                     linesize);
                } else {
                	//8x8的IDCT
                    if (IS_8x8DCT(mb_type))
                        h-&gt;h264dsp.h264_idct8_add4(dest_y, block_offset,
                                                   h-&gt;mb + (p * 256 &lt;&lt; pixel_shift),
                                                   linesize,
                                                   h-&gt;non_zero_count_cache + p * 5 * 8);
                    //处理16x16宏块
                    //采用4x4的IDCT
                    //最后的“16”代表内部循环处理16次
                    //输出结果到dest_y
                    //h-&gt;mb中存储了DCT系数
                    else
                        h-&gt;h264dsp.h264_idct_add16(dest_y, block_offset,
                                                   h-&gt;mb + (p * 256 &lt;&lt; pixel_shift),
                                                   linesize,
                                                   h-&gt;non_zero_count_cache + p * 5 * 8);
                }
            }
        } else if (CONFIG_SVQ3_DECODER) {
            for (i = 0; i &lt; 16; i++)
                if (h-&gt;non_zero_count_cache[scan8[i + p * 16]] || h-&gt;mb[i * 16 + p * 256]) {
                    // FIXME benchmark weird rule, &amp; below
                    uint8_t *const ptr = dest_y + block_offset[i];
                    ff_svq3_add_idct_c(ptr, h-&gt;mb + i * 16 + p * 256, linesize,
                                       h-&gt;qscale, IS_INTRA(mb_type) ? 1 : 0);
                }
        }
    }
}
</pre><br />下面根据源代码简单梳理一下hl_decode_mb_idct_luma()的流程：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）判断宏块是否属于Intra4x4类型，如果是，函数直接返回（Intra4x4比较特殊，它的DCT反变换已经前文所述的“帧内预测”部分完成）。<br />（2）根据不同的宏块类型作不同的处理：<br /></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">a)Intra16x16：调用H264DSPContext的汇编函数h264_idct_add16intra()进行DCT反变换</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">b)Inter类型：调用H264DSPContext的汇编函数h264_idct_add16()进行DCT反变换</blockquote></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><span style="font-family:FangSong_GB2312;">PS：需要注意的是h264_idct_add16intra()和h264_idct_add16()只有微小的区别，它们的基本逻辑都是把16x16的块划分为16个4x4的块再进行DCT反变换。此外还有一点需要注意：函数名中的“add”的含义是将DCT反变换之后的残差像素数据直接叠加到已有数据之上。</span></blockquote><p><br /></p><p>下文记录DCT反变化函数相关的源代码。</p><br /><h3>DCT反变化小知识</h3>有关DCT变换的资料比较多，在这里不再重复叙述。DCT变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。二维8x8DCT变换常见的示意图如下所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420033202541" alt="" /></div><p>早期的DCT变换都使用了8x8的矩阵（变换系数为小数）。在H.264标准中新提出了一种4x4的矩阵。这种4x4 DCT变换的系数都是整数，一方面提高了运算的准确性，一方面也利于代码的优化。4x4整数DCT变换的示意图如下所示（作为对比，右侧为4x4块的Hadamard变换的示意图）。</p><p style="text-align: center;"><img src="https://img-blog.csdn.net/20150420164133725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></p><p>4x4整数DCT变换的公式如下所示。&nbsp;</p><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420033224974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>对该公式中的矩阵乘法可以转换为2次一维DCT变换：首先对4x4块中的每行像素进行一维DCT变换，然后再对4x4块中的每列像素进行一维DCT变换。而一维的DCT变换是可以改造成为蝶形快速算法的，如下所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420033406303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>同理，DCT反变换就是DCT变换的逆变换。DCT反变换的公式如下所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420033315347?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>同理，DCT反变换的矩阵乘法也可以改造成为2次一维IDCT变换：首先对4x4块中的每行像素进行一维IDCT变换，然后再对4x4块中的每列像素进行一维IDCT变换。而一维的IDCT变换也可以改造成为蝶形快速算法，如下所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420033345314?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div>下文记录的源代码正是实现了上述4x4整数DCT反变换。<br /><br /><h3>DCT反变换汇编函数的初始化</h3>FFmpeg H.264解码器中4x4DCT反变换（也称为“IDCT”）汇编函数指针位于H264DSPContext中。在FFmpeg H.264解码器初始化的时候，会调用ff_h264dsp_init()根据系统的配置对H264DSPContext中的这些IDCT函数指针进行赋值（H264DSPContext中实际上不仅仅包含DCT反变换函数，还包含了Hadamard反变换函数，环路滤波函数，在这里不详细讨论）。下面简单看一下ff_h264_pred_init()的定义。<br /><br /><h3>ff_h264dsp_init()</h3>ff_h264_pred_init()用于初始化DCT反变换函数，Hadamard反变换函数，环路滤波函数。该函数的定义位于libavcodec\h264dsp.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_18_8168561" name="code" class="cpp">//初始化DSP相关的函数。包含了IDCT、环路滤波函数等
av_cold void ff_h264dsp_init(H264DSPContext *c, const int bit_depth,
                             const int chroma_format_idc)
{
#undef FUNC
#define FUNC(a, depth) a ## _ ## depth ## _c

#define ADDPX_DSP(depth) \
    c-&gt;h264_add_pixels4_clear = FUNC(ff_h264_add_pixels4, depth);\
    c-&gt;h264_add_pixels8_clear = FUNC(ff_h264_add_pixels8, depth)

    if (bit_depth &gt; 8 &amp;&amp; bit_depth &lt;= 16) {
        ADDPX_DSP(16);
    } else {
        ADDPX_DSP(8);
    }

#define H264_DSP(depth) \
    c-&gt;h264_idct_add= FUNC(ff_h264_idct_add, depth);\
    c-&gt;h264_idct8_add= FUNC(ff_h264_idct8_add, depth);\
    c-&gt;h264_idct_dc_add= FUNC(ff_h264_idct_dc_add, depth);\
    c-&gt;h264_idct8_dc_add= FUNC(ff_h264_idct8_dc_add, depth);\
    c-&gt;h264_idct_add16     = FUNC(ff_h264_idct_add16, depth);\
    c-&gt;h264_idct8_add4     = FUNC(ff_h264_idct8_add4, depth);\
    if (chroma_format_idc &lt;= 1)\
        c-&gt;h264_idct_add8  = FUNC(ff_h264_idct_add8, depth);\
    else\
        c-&gt;h264_idct_add8  = FUNC(ff_h264_idct_add8_422, depth);\
    c-&gt;h264_idct_add16intra= FUNC(ff_h264_idct_add16intra, depth);\
    c-&gt;h264_luma_dc_dequant_idct= FUNC(ff_h264_luma_dc_dequant_idct, depth);\
    if (chroma_format_idc &lt;= 1)\
        c-&gt;h264_chroma_dc_dequant_idct= FUNC(ff_h264_chroma_dc_dequant_idct, depth);\
    else\
        c-&gt;h264_chroma_dc_dequant_idct= FUNC(ff_h264_chroma422_dc_dequant_idct, depth);\
\
    c-&gt;weight_h264_pixels_tab[0]= FUNC(weight_h264_pixels16, depth);\
    c-&gt;weight_h264_pixels_tab[1]= FUNC(weight_h264_pixels8, depth);\
    c-&gt;weight_h264_pixels_tab[2]= FUNC(weight_h264_pixels4, depth);\
    c-&gt;weight_h264_pixels_tab[3]= FUNC(weight_h264_pixels2, depth);\
    c-&gt;biweight_h264_pixels_tab[0]= FUNC(biweight_h264_pixels16, depth);\
    c-&gt;biweight_h264_pixels_tab[1]= FUNC(biweight_h264_pixels8, depth);\
    c-&gt;biweight_h264_pixels_tab[2]= FUNC(biweight_h264_pixels4, depth);\
    c-&gt;biweight_h264_pixels_tab[3]= FUNC(biweight_h264_pixels2, depth);\
\
    c-&gt;h264_v_loop_filter_luma= FUNC(h264_v_loop_filter_luma, depth);\
    c-&gt;h264_h_loop_filter_luma= FUNC(h264_h_loop_filter_luma, depth);\
    c-&gt;h264_h_loop_filter_luma_mbaff= FUNC(h264_h_loop_filter_luma_mbaff, depth);\
    c-&gt;h264_v_loop_filter_luma_intra= FUNC(h264_v_loop_filter_luma_intra, depth);\
    c-&gt;h264_h_loop_filter_luma_intra= FUNC(h264_h_loop_filter_luma_intra, depth);\
    c-&gt;h264_h_loop_filter_luma_mbaff_intra= FUNC(h264_h_loop_filter_luma_mbaff_intra, depth);\
    c-&gt;h264_v_loop_filter_chroma= FUNC(h264_v_loop_filter_chroma, depth);\
    if (chroma_format_idc &lt;= 1)\
        c-&gt;h264_h_loop_filter_chroma= FUNC(h264_h_loop_filter_chroma, depth);\
    else\
        c-&gt;h264_h_loop_filter_chroma= FUNC(h264_h_loop_filter_chroma422, depth);\
    if (chroma_format_idc &lt;= 1)\
        c-&gt;h264_h_loop_filter_chroma_mbaff= FUNC(h264_h_loop_filter_chroma_mbaff, depth);\
    else\
        c-&gt;h264_h_loop_filter_chroma_mbaff= FUNC(h264_h_loop_filter_chroma422_mbaff, depth);\
    c-&gt;h264_v_loop_filter_chroma_intra= FUNC(h264_v_loop_filter_chroma_intra, depth);\
    if (chroma_format_idc &lt;= 1)\
        c-&gt;h264_h_loop_filter_chroma_intra= FUNC(h264_h_loop_filter_chroma_intra, depth);\
    else\
        c-&gt;h264_h_loop_filter_chroma_intra= FUNC(h264_h_loop_filter_chroma422_intra, depth);\
    if (chroma_format_idc &lt;= 1)\
        c-&gt;h264_h_loop_filter_chroma_mbaff_intra= FUNC(h264_h_loop_filter_chroma_mbaff_intra, depth);\
    else\
        c-&gt;h264_h_loop_filter_chroma_mbaff_intra= FUNC(h264_h_loop_filter_chroma422_mbaff_intra, depth);\
    c-&gt;h264_loop_filter_strength= NULL;
    //根据颜色位深，初始化不同的函数
    //一般为8bit，即执行H264_DSP(8)
    switch (bit_depth) {
    case 9:
        H264_DSP(9);
        break;
    case 10:
        H264_DSP(10);
        break;
    case 12:
        H264_DSP(12);
        break;
    case 14:
        H264_DSP(14);
        break;
    default:
        av_assert0(bit_depth&lt;=8);
        H264_DSP(8);
        break;
    }
    //这个函数查找startcode的时候用到
    //在这里竟然单独列出
    c-&gt;startcode_find_candidate = ff_startcode_find_candidate_c;
    //如果系统支持，则初始化经过汇编优化的函数
    if (ARCH_AARCH64) ff_h264dsp_init_aarch64(c, bit_depth, chroma_format_idc);
    if (ARCH_ARM) ff_h264dsp_init_arm(c, bit_depth, chroma_format_idc);
    if (ARCH_PPC) ff_h264dsp_init_ppc(c, bit_depth, chroma_format_idc);
    if (ARCH_X86) ff_h264dsp_init_x86(c, bit_depth, chroma_format_idc);
}
</pre><br />从ff_h264dsp_init()的定义可以看出，该函数通过调用“H264_DSP(depth)”宏完成C语言版本的DCT反变换函数，Hadamard反变换函数，环路滤波函数的初始化。在函数的末尾还会判断系统的特性，如果允许的话会初始化效率更高的经过汇编优化的函数。<br />下面我们展开“H264_DSP(8)”宏看看C语言版本函数的初始化过程。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_19_5297089" name="code" class="cpp">c-&gt;h264_idct_add= ff_h264_idct_add_8_c;
    c-&gt;h264_idct8_add= ff_h264_idct8_add_8_c;
    c-&gt;h264_idct_dc_add= ff_h264_idct_dc_add_8_c;
    c-&gt;h264_idct8_dc_add= ff_h264_idct8_dc_add_8_c;
    c-&gt;h264_idct_add16     = ff_h264_idct_add16_8_c;
    c-&gt;h264_idct8_add4     = ff_h264_idct8_add4_8_c;
    if (chroma_format_idc &lt;= 1)
        c-&gt;h264_idct_add8  = ff_h264_idct_add8_8_c;
    else
        c-&gt;h264_idct_add8  = ff_h264_idct_add8_422_8_c;
    c-&gt;h264_idct_add16intra= ff_h264_idct_add16intra_8_c;
    c-&gt;h264_luma_dc_dequant_idct= ff_h264_luma_dc_dequant_idct_8_c;
    if (chroma_format_idc &lt;= 1)
        c-&gt;h264_chroma_dc_dequant_idct= ff_h264_chroma_dc_dequant_idct_8_c;
    else
        c-&gt;h264_chroma_dc_dequant_idct= ff_h264_chroma422_dc_dequant_idct_8_c;

    c-&gt;weight_h264_pixels_tab[0]= weight_h264_pixels16_8_c;
    c-&gt;weight_h264_pixels_tab[1]= weight_h264_pixels8_8_c;
    c-&gt;weight_h264_pixels_tab[2]= weight_h264_pixels4_8_c;
    c-&gt;weight_h264_pixels_tab[3]= weight_h264_pixels2_8_c;
    c-&gt;biweight_h264_pixels_tab[0]= biweight_h264_pixels16_8_c;
    c-&gt;biweight_h264_pixels_tab[1]= biweight_h264_pixels8_8_c;
    c-&gt;biweight_h264_pixels_tab[2]= biweight_h264_pixels4_8_c;
    c-&gt;biweight_h264_pixels_tab[3]= biweight_h264_pixels2_8_c;

    c-&gt;h264_v_loop_filter_luma= h264_v_loop_filter_luma_8_c;
    c-&gt;h264_h_loop_filter_luma= h264_h_loop_filter_luma_8_c;
    c-&gt;h264_h_loop_filter_luma_mbaff= h264_h_loop_filter_luma_mbaff_8_c;
    c-&gt;h264_v_loop_filter_luma_intra= h264_v_loop_filter_luma_intra_8_c;
    c-&gt;h264_h_loop_filter_luma_intra= h264_h_loop_filter_luma_intra_8_c;
    c-&gt;h264_h_loop_filter_luma_mbaff_intra= h264_h_loop_filter_luma_mbaff_intra_8_c;
    c-&gt;h264_v_loop_filter_chroma= h264_v_loop_filter_chroma_8_c;
    if (chroma_format_idc &lt;= 1)
        c-&gt;h264_h_loop_filter_chroma= h264_h_loop_filter_chroma_8_c;
    else
        c-&gt;h264_h_loop_filter_chroma= h264_h_loop_filter_chroma422_8_c;
    if (chroma_format_idc &lt;= 1)
        c-&gt;h264_h_loop_filter_chroma_mbaff= h264_h_loop_filter_chroma_mbaff_8_c;
    else
        c-&gt;h264_h_loop_filter_chroma_mbaff= h264_h_loop_filter_chroma422_mbaff_8_c;
    c-&gt;h264_v_loop_filter_chroma_intra= h264_v_loop_filter_chroma_intra_8_c;
    if (chroma_format_idc &lt;= 1)
        c-&gt;h264_h_loop_filter_chroma_intra= h264_h_loop_filter_chroma_intra_8_c;
    else
        c-&gt;h264_h_loop_filter_chroma_intra= h264_h_loop_filter_chroma422_intra_8_c;
    if (chroma_format_idc &lt;= 1)
        c-&gt;h264_h_loop_filter_chroma_mbaff_intra= h264_h_loop_filter_chroma_mbaff_intra_8_c;
    else
        c-&gt;h264_h_loop_filter_chroma_mbaff_intra= h264_h_loop_filter_chroma422_mbaff_intra_8_c;
    c-&gt;h264_loop_filter_strength= ((void *)0);
</pre><br />从“H264_DSP(8)”宏展开的结果可以看出：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">（1）4x4块的DCT反变换函数指针h264_idct_add()指向ff_h264_idct_add_8_c()<br />（2）只包含DC系数的4x4块的DCT反变换函数指针h264_idct_dc_add()指向ff_h264_idct_dc_add_8_c()<br />（3）16x16块的DCT反变换函数指针h264_idct_add16()指向ff_h264_idct_add16_8_c()<br />（4）16x16的Intra块的DCT反变换函数指针h264_idct_add16intra()指向ff_h264_idct_add16intra_8_c()</blockquote>下文将会简单分析上述几个函数。<br /><br /><h3>ff_h264_idct_add_8_c()</h3>ff_h264_idct_add_8_c()用于进行4x4整数DCT反变换，该函数的定义位于libavcodec\h264idct_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_20_9360954" name="code" class="cpp">/* IDCT
 *
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 * 参数：
 * _block：输入DCT系数
 * _dst：输出像素数据
 * stride：一行图像数据的大小
 *
 */
//IDCT反变换（4x4）
//“add”的意思是在像素数据（通过预测获得）上面叠加（而不是赋值）IDCT的结果
void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride)
{

	/*
	 *     | 1  1  1  1 |   | 1  2  1  1 |
	 *     | 2  1 -1 -2 |   | 1  1 -1 -2 |
	 * Y = | 1 -1 -1 -2 | X | 1 -1 -1  2 |
	 *     | 1 -2  2 -1 |   | 1 -2  1 -1 |
	 *
	 */
    int i;
    pixel *dst = (pixel*)_dst;
    dctcoef *block = (dctcoef*)_block;
    stride &gt;&gt;= sizeof(pixel)-1;

    block[0] += 1 &lt;&lt; 5;
    //蝶形算法（一维变换，纵向）
    //---+----------
    // 0 |   |   |   |
    // 4 |
    // 8 |
    // 12|
    //---+----------
    for(i=0; i&lt;4; i++){
    	//[0]和[2]
        const int z0=  block[i + 4*0]     +  block[i + 4*2];
        const int z1=  block[i + 4*0]     -  block[i + 4*2];
        //[1]和[3]
        const int z2= (block[i + 4*1]&gt;&gt;1) -  block[i + 4*3];
        const int z3=  block[i + 4*1]     + (block[i + 4*3]&gt;&gt;1);

        block[i + 4*0]= z0 + z3;
        block[i + 4*1]= z1 + z2;
        block[i + 4*2]= z1 - z2;
        block[i + 4*3]= z0 - z3;
    }
    //蝶形算法（另一维变换，横向）
    //---+----------
    // 0 | 1 | 2 | 3 |
    //   |
    //   |
    //   |
    //---+----------
    for(i=0; i&lt;4; i++){
        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];
        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];
        const int z2= (block[1 + 4*i]&gt;&gt;1) -  block[3 + 4*i];
        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]&gt;&gt;1);
        //av_clip_pixel(): 把一个整形转换取值范围为0-255的数值，用于限幅
        //注意是累加而不是赋值到dst上（所以函数名中包含“add”）

        //转置？！
        //一列一列处理
        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) &gt;&gt; 6));
        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) &gt;&gt; 6));
        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) &gt;&gt; 6));
        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) &gt;&gt; 6));
    }
    //清零
    memset(block, 0, 16 * sizeof(dctcoef));
}
</pre><br />从ff_h264_idct_add_8_c()的定义可以看出，该函数首先对4x4系数块中纵向的4列数据进行了一维DCT反变换，然后又对4x4系数块中横向的4行数据进行了DCT一维反变换，最后将变换后的残差图像数据叠加到了原有数据之上。<br />在这里一维DCT反变换采用了蝶形快速算法，如下图所示。<br /><div style="text-align: center;">&nbsp;<img src="https://img-blog.csdn.net/20150420033550661?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></div><p>下面分析上文提到的几个函数。</p><p><br /></p><h3>h264_idct_dc_add()</h3>ff_h264_idct_dc_add_8_c()用于对只有DC系数的4x4矩阵进行4x4整数DCT反变换，该函数的定义位于libavcodec\h264idct_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_21_5900055" name="code" class="cpp">// assumes all AC coefs are 0
//DCT反变换，特殊情况：
//AC系数全部为0（没有传递AC系数，只有DC系数）
void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *_block, int stride){
    int i, j;
    pixel *dst = (pixel*)_dst;
    dctcoef *block = (dctcoef*)_block;
    //DC系数
    int dc = (block[0] + 32) &gt;&gt; 6;
    stride /= sizeof(pixel);
    //设置为0
    block[0] = 0;
    //在4x4块的每个像素上面累加（注意不是赋值）dc系数
    for( j = 0; j &lt; 4; j++ )
    {
        for( i = 0; i &lt; 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + dc );//av_clip_pixel(): 把一个整形转换取值范围为0-255的数值，用于限幅
        dst += stride;//下一行
    }
}</pre><br />可以看出只有DC系数的DCT反变换相比前面“正式”的DCT反变换来说简单了很多，只需要把DC系数赋值到4x4块中的每个像素上就可以了。<br /><br /><h3>ff_h264_idct_add16_8_c()</h3>ff_h264_idct_add16_8_c()用于对16x16的块进行4x4整数DCT反变换，该函数的定义位于libavcodec\h264idct_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_22_662033" name="code" class="cpp">//处理16x16宏块
//采用4x4的IDCT
//最后的“16”代表内部循环处理16次
//输入为block，输出为dst
void FUNCC(ff_h264_idct_add16)(uint8_t *dst, const int *block_offset, int16_t *block, int stride, const uint8_t nnzc[15*8]){
    int i;
    //循环16次
    for(i=0; i&lt;16; i++){
    	//非零系数个数
        int nnz = nnzc[ scan8[i] ];
        //非零系数个数不为0才处理
        if(nnz){
        	//特殊：只有DC系数
            if(nnz==1 &amp;&amp; ((dctcoef*)block)[i*16]) FUNCC(ff_h264_idct_dc_add)(dst + block_offset[i], block + i*16*sizeof(pixel), stride);
            //一般的情况
            else                                  FUNCC(ff_h264_idct_add   )(dst + block_offset[i], block + i*16*sizeof(pixel), stride);
        }
    }
}</pre><br />从源代码可以看出，16x16块的4x4DCT反变换的实质就是把16x16的块分割为16个4x4的块，然后分别进行4x4DCT反变换。<br /><br /><h3>h264_idct_add16intra()</h3>h264_idct_add16intra()用于对16x16的帧内预测（Intra）的块进行4x4整数DCT反变换，该函数的定义位于libavcodec\h264idct_template.c，如下所示。<br /><pre code_snippet_id="648355" snippet_file_name="blog_20150420_23_3089695" name="code" class="cpp">//处理Intra16x16宏块
//采用4x4的IDCT
//最后的“16”代表内部循环处理16次
//输入为block，输出为dst
void FUNCC(ff_h264_idct_add16intra)(uint8_t *dst, const int *block_offset, int16_t *block, int stride, const uint8_t nnzc[15*8]){
    int i;
    for(i=0; i&lt;16; i++){
        if(nnzc[ scan8[i] ])             FUNCC(ff_h264_idct_add   )(dst + block_offset[i], block + i*16*sizeof(pixel), stride);
        else if(((dctcoef*)block)[i*16]) FUNCC(ff_h264_idct_dc_add)(dst + block_offset[i], block + i*16*sizeof(pixel), stride);
    }
}</pre><br />可以看出h264_idct_add16intra()的机制与ff_h264_idct_add16_8_c()是类似的，只是有一些细节的差别：它们都是把16x16的块分割为16个4x4的块，然后分别进行4x4DCT反变换。<br /><br />至此FFmpeg H.264解码器的帧内宏块（Intra）解码相关的代码就基本分析完毕了。总而言之帧内预测宏块的解码就是“预测+残差”的处理流程。下一篇文章分析帧间宏块（Inter）解码的代码。<br /><br /><br /><br /><strong><span style="color:#990000;">雷霄骅<br />leixiaohua1020@126.com<br />http://blog.csdn.net/leixiaohua1020</span></strong><br /><br /><br />            </div>
                </div>
				<div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
			<a class="btn btn-red-hollow" id="btn-readmore">阅读更多</a>
		</div>
        	</article>
	
		<div class="article-bar-bottom">
				<div class="article-copyright">
			版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/45143075		</div>
						<div class="tags-box artic-tag-box">
			<span class="label">文章标签：</span>
						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&t=blog" target="_blank">FFmpeg						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=宏块&t=blog" target="_blank">宏块						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=解码&t=blog" target="_blank">解码						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=帧内预测&t=blog" target="_blank">帧内预测						<a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=DCT&t=blog" target="_blank">DCT						</a>
		</div>
						<div class="tags-box">
			<span class="label">个人分类：</span>
						<a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795"  target="_blank">FFMPEG						</a>
		</div>
						<div class="tags-box">
			<span class="label">所属专栏：</span>
						<a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">FFmpeg</a>
						</a>
		</div>
			</div>
	
	<!-- !empty($pre_next_article[0]) -->
		</div>
<script>
    $(".MathJax").remove();
</script>

<script type="text/javascript" src="https://static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax@js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
			"HTML-CSS": {
					linebreaks: { automatic: true, width: "94%container" },
					imageFont: null
			},
			tex2jax: {
				preview: "none"
			},
			mml2jax: {
				preview: 'none'
			}
	});
</script>
<script>
	(function(){
		var btnReadmore = $("#btn-readmore");
		if(btnReadmore.length>0){
			var winH = $(window).height();
			var articleBox = $("div.article_content");
			var artH = articleBox.height();
			if(artH > winH*2){
				articleBox.css({
					'height':winH*2+'px',
					'overflow':'hidden'
				})
				btnReadmore.click(function(){
					articleBox.removeAttr("style");
					$(this).parent().remove();
				})
			}else{
				btnReadmore.parent().remove();
			}
		}
	})()
</script>        <div class="edu-promotion"></div>
<script type="text/javascript">
	var edu_ad_is_big_data = 0;
	var edu_ad_id_mapping = {"0":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"1":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"8":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"2":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"3":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"6":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"12":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"14":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcweb","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"15":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcjg","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"16":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"28":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcai","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"29":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"30":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"32":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcaq"],"33":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gccxrs","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1"],"35":["https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"37":["https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1"],"7":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=web1","https:\/\/edu.csdn.net\/sp\/blog.php?type=618"],"17":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1"],"34":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcbt"],"36":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=ai1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"31":["https:\/\/edu.csdn.net\/sp\/blog.php?type=python1","https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"19":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"],"20":["https:\/\/edu.csdn.net\/sp\/blog.php?type=bigdata1","https:\/\/edu.csdn.net\/sp\/blog.php?type=gcit"]};
</script>        <a id="commentBox"></a>
<div class="comment-box" style="display:none;">
	  	<div class="unlogin-box text-center">
		想对作者说点什么？
		<!-- $curl 当前地址 -->
		<a href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45143075#commentBox" class="btn btn-sm btn-red">我来说一句</a>
	</div>
			<div class="comment-list-container">
		<a id="comments"></a>
		<div class="comment-list-box">
		</div>
		<div id="commentPage" class="pagination-box d-none"></div>
		<div class="opt-box text-center">
			<button class="btn btn-sm btn-link-blue" id="btnMoreComment"></button>
		</div>
	</div>
</div>        <div class="recommend-box" style="display:none;">
            		<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367" target="_blank" strategy="BlogCommendFromGuangxin_0">
				x264<em>源代码</em><em>简单</em><em>分析</em>：编码器主干<em>部分</em>-1			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367" target="_blank" >
				本文<em>分析</em>x264编码器主干<em>部分</em>的<em>源代码</em>。“主干<em>部分</em>”指的就是libx264中最核心的接口函数——x264_encoder_encode()，以及相关的几个接口函数x264_encoder_open()...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-05-11 17:10:51</span>
			</p>
			<p>
				<span class="read-num">阅读数：12777</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45938927" target="_blank" strategy="BlogCommendFromGuangxin_1">
				x264<em>源代码</em><em>简单</em><em>分析</em>：<em>宏块</em>编码（Encode）<em>部分</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45938927" target="_blank" >
				本文记录x264的 x264_slice_write()函数中调用的x264_macroblock_encode()的<em>源代码</em>。x264_macroblock_encode()对应着x264中的<em>宏块</em>编码...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-05-24 13:47:40</span>
			</p>
			<p>
				<span class="read-num">阅读数：8151</span>
			</p>
		</div>
	</div>
								<!-- 第四范式广告开关 -->
<script>window.p4sdk_enable_recommendBox=true</script>
			
				<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/46451119" target="_blank" strategy="BlogCommendFromGuangxin_2">
				<em>FFmpeg</em>的HEVC<em>解码器</em><em>源代码</em><em>简单</em><em>分析</em>：CTU<em>解码</em>（CTU <em>Decode</em>）<em>部分</em>-TU			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/46451119" target="_blank" >
				本文<em>分析</em><em>FFmpeg</em>的libavcodec中的HEVC<em>解码器</em>的CTU<em>解码</em>（CTU <em>Decode</em>）<em>部分</em>的<em>源代码</em>。<em>FFmpeg</em>的HEVC<em>解码器</em>调用hls_<em>decode</em>_entry()函数完成了Slice解...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-06-16 17:14:42</span>
			</p>
			<p>
				<span class="read-num">阅读数：6812</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/50805395" target="_blank" strategy="BlogCommendFromGuangxin_3">
				x264代码剖析（二）：如何编译运行x264以及x264代码基本框架			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/FRD2009041510/article/details/50805395" target="_blank" >
				x264代码剖析（二）：如何编译运行x264以及x264代码基本框架
 
        x264工程在x265出现之前一直在更新，但是自x264-20091007（含）不再支持VC++平台，也就是说...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/FRD2009041510" title="FRD2009041510" target="_blank">
					<img src="https://avatar.csdn.net/6/9/9/3_frd2009041510.jpg" alt="FRD2009041510" class="avatar-pic">
					<span class="name">FRD2009041510</span>
				</a>
			</p>
			<p>
				<span class="date">2016-03-04 21:11:39</span>
			</p>
			<p>
				<span class="read-num">阅读数：2725</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/nonmarking/article/details/50730517" target="_blank" strategy="BlogCommendFromGuangxin_4">
				x264源码<em>分析</em>与应用示例（一）——视频编码基本流程			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/nonmarking/article/details/50730517" target="_blank" >
				打算写几篇文章记录一下学习x264源码的成果，主要包含两个方面的内容，一是基本的x264视频编码流程，二是x264中的码率控制，之前<em>分析</em>过JM和HM的码率控制，但是x264的码率控制一直没看，这回也算...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/nonmarking" title="nonmarking" target="_blank">
					<img src="https://avatar.csdn.net/8/6/9/3_nonmarking.jpg" alt="nonmarking" class="avatar-pic">
					<span class="name">nonmarking</span>
				</a>
			</p>
			<p>
				<span class="date">2016-02-25 13:56:39</span>
			</p>
			<p>
				<span class="read-num">阅读数：3380</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45114453" target="_blank" strategy="BlogCommendFromBaidu_5">
				<em>FFmpeg</em>的<em>H.264</em><em>解码器</em><em>源代码</em><em>简单</em><em>分析</em>：熵<em>解码</em>（Entropy Decoding）<em>部分</em>			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/leixiaohua1020/article/details/45114453" target="_blank" >
				本文<em>分析</em><em>FFmpeg</em>的<em>H.264</em><em>解码器</em>的熵<em>解码</em>（Entropy Decoding）<em>部分</em>的<em>源代码</em>。<em>FFmpeg</em>的<em>H.264</em><em>解码器</em>调用<em>decode</em>_slice()函数完成了<em>解码</em>工作。这些<em>解码</em>工作可以大体上...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/leixiaohua1020" title="leixiaohua1020" target="_blank">
					<img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" alt="leixiaohua1020" class="avatar-pic">
					<span class="name">leixiaohua1020</span>
				</a>
			</p>
			<p>
				<span class="date">2015-04-18 17:19:15</span>
			</p>
			<p>
				<span class="read-num">阅读数：11405</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box recommend-ad-box" id="a_d_feed_0"></div>
			<script>
				var width = $("div.recommend-box").outerWidth() - 48;
				NEWS_FEED({
					w: width,
					h: 90,
					showid: 'Afihld',
					placeholderId: 'a_d_feed_0',
					inject: 'define',
					define: {
						imagePosition: 'right',
						imageBorderRadius: 0,
						imageWidth: 120,
						imageHeight: 90,
						imageFill: 'clip',
						displayImage: true,
						displayTitle: true,
						titleFontSize: 20,
						titleFontColor: '#333',
						titleFontFamily: 'Microsoft Yahei',
						titleFontWeight: 'bold',
						titlePaddingTop: 0,
						titlePaddingRight: 0,
						titlePaddingBottom: 10,
						titlePaddingLeft: 0,
						displayDesc: true,
						descFontSize: 14,
						descFontColor: '#6b6b6b',
						descFontFamily: 'Microsoft Yahei',
						paddingTop: 0,
						paddingRight: 0,
						paddingBottom: 0,
						paddingLeft: 0,
						backgroundColor: '#fff',
						hoverColor: '#ca0c16'
					}
				})
			</script>
			<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/mandagod/article/details/51174480" target="_blank" strategy="BlogCommendFromBaidu_6">
				<em>H.264</em><em>解码</em>过程剖析-4			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/mandagod/article/details/51174480" target="_blank" >
				x264开源工程实现<em>H.264</em>的视频编码，但没有提供对应的<em>解码器</em>。<em>ffmpeg</em>开源多媒体编<em>解码</em>集合汇集了市面上几乎所有媒体格式的编<em>解码</em>的<em>源代码</em>。其中的H264.c就是一个能正常<em>解码</em>x264编码码流的独...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/mandagod" title="mandagod" target="_blank">
					<img src="https://avatar.csdn.net/1/0/3/3_mandagod.jpg" alt="mandagod" class="avatar-pic">
					<span class="name">mandagod</span>
				</a>
			</p>
			<p>
				<span class="date">2016-04-17 18:32:19</span>
			</p>
			<p>
				<span class="read-num">阅读数：8245</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/lanlanlan12345/article/details/50952554" target="_blank" strategy="BlogCommendFromBaidu_7">
				<em>ffmpeg</em>视频编码AV_CODEC_ID_H264 Codec not find解决方法			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/lanlanlan12345/article/details/50952554" target="_blank" >
				基于Cygwin平台，在Eclipse上建立C project，使用<em>FFmpeg</em>开源库进行视频编<em>解码</em>工作。可以将<em>H.264</em>编码格式的视频<em>解码</em>成YUV数据。但是对YUV数据编码为<em>H.264</em>时遇到了问题，...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/lanlanlan12345" title="lanlanlan12345" target="_blank">
					<img src="https://avatar.csdn.net/2/9/6/3_lanlanlan12345.jpg" alt="lanlanlan12345" class="avatar-pic">
					<span class="name">lanlanlan12345</span>
				</a>
			</p>
			<p>
				<span class="date">2016-03-22 10:24:18</span>
			</p>
			<p>
				<span class="read-num">阅读数：3606</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/PZ0605/article/details/52958918" target="_blank" strategy="BlogCommendFromBaidu_8">
				android 移植 <em>ffmpeg</em> (三) 测试用例(解决avcodec_find_encoder(AV_CODEC_ID_H264)返回为NULL的问题)			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/PZ0605/article/details/52958918" target="_blank" >
				使用ffmmpeg编译的时候，一般我们会用到H264编码，像这样使用的时候发现<em>ffmpeg</em>无法找到H264编码：
    AVCodec*  pCodec = avcodec_find_encoder...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/PZ0605" title="PZ0605" target="_blank">
					<img src="https://avatar.csdn.net/F/4/7/3_pz0605.jpg" alt="PZ0605" class="avatar-pic">
					<span class="name">PZ0605</span>
				</a>
			</p>
			<p>
				<span class="date">2016-10-28 19:31:25</span>
			</p>
			<p>
				<span class="read-num">阅读数：4723</span>
			</p>
		</div>
	</div>
					<div class="recommend-item-box csdn-tracking-statistics" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
		<h4 class="text-truncate">
			<a href="https://blog.csdn.net/maopig/article/details/6784379" target="_blank" strategy="BlogCommendFromBaidu_9">
				XVID基本参数解析			</a>
		</h4>
		<p class="content">
			<a href="https://blog.csdn.net/maopig/article/details/6784379" target="_blank" >
				XVID，X264等是MPEG4、H264标准的开源编码器，其中X264只有编码<em>部分</em>，<em>解码</em><em>部分</em>需要<em>FFMPEG</em>完成；XVID有编<em>解码</em><em>部分</em>，其中<em>解码</em>亦可以利用<em>FFMPEG</em>中的MPEG4完成<em>解码</em>。视频压缩...			</a>
		</p>
		<div class="info-box d-flex align-content-center">
			<p>
				<a class="avatar" src="https://blog.csdn.net/maopig" title="maopig" target="_blank">
					<img src="https://avatar.csdn.net/C/E/7/3_maopig.jpg" alt="maopig" class="avatar-pic">
					<span class="name">maopig</span>
				</a>
			</p>
			<p>
				<span class="date">2011-09-17 11:35:54</span>
			</p>
			<p>
				<span class="read-num">阅读数：2984</span>
			</p>
		</div>
	</div>
			            <!-- 第四范式SDK -->
<script src="https://nbrecsys.4paradigm.com/resource/js/sdk-csdn-smallflow@js" async defer></script>
            <div class="recommend-loading-box">
                <img src='https://csdnimg.cn/release/phoenix/images/feedLoading.gif'>
            </div>
            <div class="recommend-end-box">
                <p class="text-center">没有更多推荐了，<a href="https://blog.csdn.net/" class="c-blue c-blue-hover c-blue-focus">返回首页</a></p>
            </div>
        </div>
    <div style="border-bottom: dashed 1px #666;"><span style="font-size: 0.8em; font-weight: bold;">此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg">spygg</a>生成,请尊重原作者版权!!!<br/>我的邮箱:liushidc@163.com</span></div> </main>
    <aside style="display: none;">
		    <div id="asideProfile" class="aside-box">
    <h3 class="aside-title">个人资料</h3>
    <div class="profile-intro d-flex">
        <div class="avatar-box d-flex justify-content-center flex-column">
            <a href="https://blog.csdn.net/leixiaohua1020">
                <img src="https://avatar.csdn.net/A/7/6/3_leixiaohua1020.jpg" class="avatar_pic">
            </a>
        </div>
        <div class="user-info d-flex justify-content-center flex-column">
            <p class="name csdn-tracking-statistics tracking-click" data-mod="popu_379">
                <a href="https://blog.csdn.net/leixiaohua1020" target="_blank" class="text-truncate" id="uid">leixiaohua1020</a>
            </p>
                    </div>
                <div class="opt-box d-flex justify-content-center flex-column">
            <span  class="csdn-tracking-statistics tracking-click" data-mod="popu_379">
                                <a class="btn btn-sm btn-red-hollow" href="https://passport.csdn.net/account/login?from=https://blog.csdn.net/leixiaohua1020/article/details/45143075" target="_self">关注</a>
                            </span>
                    </div>
            </div>
    <div class="data-info d-flex item-tiling">
                <dl class="text-center" title="373">
                        <dt><a href="https://blog.csdn.net/leixiaohua1020?t=1">原创</a></dt>
            <dd><a href="https://blog.csdn.net/leixiaohua1020?t=1"><span class="count">373</span></a></dd>
                    </dl>
        <dl class="text-center" title="14088">
            <dt>粉丝</dt>
            <dd><span class="count" id="fan">1万+</span></dd>
        </dl>
        <dl class="text-center" title="460">
            <dt>喜欢</dt>
            <dd><span class="count">460</span></dd>
        </dl>
        <dl class="text-center" title="7317">
            <dt>评论</dt>
            <dd><span class="count">7317</span></dd>
        </dl>
    </div>
    <div class="grade-box clearfix">
        <dl>
            <dt>等级：</dt>
            <dd>
                <a href="https://blog.csdn.net/home/help.html#level" title="9级,点击查看等级说明" target="_blank">
                    <svg class="icon icon-level" aria-hidden="true">
                        <use xlink:href="#csdnc-bloglevel-9"></use>
                    </svg>
                </a>
            </dd>
        </dl>
        <dl>
            <dt>访问：</dt>
            <dd title="10421177">
                1042万+            </dd>
        </dl>
        <dl>
            <dt>积分：</dt>
            <dd title="62878">
                6万+            </dd>
        </dl>
        <dl title="49">
            <dt>排名：</dt>
            <dd>49</dd>
        </dl>
    </div>
        <div class="badge-box d-flex">
        <span>勋章：</span>
                <a class="icon-badge" title="专栏达人">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-columns"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item1">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-columns"></use>
                        </svg>
                        <p>专栏达人</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予成功创建个人博客专栏的用户。专栏中添加五篇以上博文即可点亮！撰写博客专栏浓缩技术精华，专栏达人就是你！
                    </div>
                </div>
            </div> 
        </a>  
                        <a class="icon-badge" title="持之以恒">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-lasting"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item2">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-lasting"></use>
                        </svg>
                        <p>持之以恒</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不积小流无以成江海，程序人生的精彩需要坚持不懈地积累！
                    </div>
                </div>
            </div>
        </a>
                                <a class="icon-badge" title="博客之星">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#csdnc-m-blogstar-l"></use>
            </svg>
            <div class="icon-arrow"></div>
            <div class="grade-detail-box item4">
                <div class="pos-box">
                    <div class="left-box d-flex justify-content-center align-items-center flex-column">
                        <svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-m-blogstar-l"></use>
                        </svg>
                        <p>博客之星</p>
                    </div>
                    <div class="right-box d-flex justify-content-center align-items-center">
                        授予通过"CSDN博客之星评选"中脱颖而出的十大博客之星称号的用户。
                    </div>
                </div>
            </div>
        </a>   
            </div>
    </div>		    <div class="csdn-tracking-statistics mb8 box-shadow" data-pid="blog" data-mod="popu_4" style="height:250px;">
    <div class="aside-content text-center" id="cpro_u2734133">
        <!-- 投放代码 -->
        <script type="text/javascript" src="//cee1.iteye.com/lgyyovfyh@js"></script>
    </div>
</div>
		    <!--自定义模块-->
<div id="asideCustom26787557" class="aside-box custom-box">
    <h3 class="aside-title">关于我</h3>
    <div class="aside-content clearfix">
        姓名：雷霄骅<br>
网名：leixiaohua1020<br>
本科：<br>
中国传媒大学-广播电视工程<br>
硕士：<br>
中国传媒大学-数字电视技术<br>
博士：<br>
中国传媒大学-数字视频技术<br>
Email：<br>
leixiaohua1020@126.com<br>
QQ：<br>
494085803<br>
<br>
[注1：QQ消息较多，难以一一回复，见谅]<br>
[注2：CSDN私信功能使用很少，有问题可以直接在博客评论处留言]<br>
<br>
奖项：<br>
<a href="http://vote.blog.csdn.net/Blogstar2014/List">2014年度 - CSDN博客之星</a><br>
<a href="https://mvp.microsoft.com/en-us/mvp/Xiaohua%20Lei-5001392">2015年度 - 微软MVP</a><br>
<a href="http://bss.csdn.net/m/topic/community_star/index">2015年度 - CSDN博客之星</a><br>
简介：<br>
主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。
<br>    </div>
</div>
		    <div id="asideNewArticle" class="aside-box">
    <h3 class="aside-title">最新文章</h3>
    <div class="aside-content">
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/51187668" target="_blank">[投稿] Speex回声消除原理深度解析</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789619" target="_blank">[投稿]房间声学原理与Schroeder混响算法实现</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50789503" target="_blank">[投稿]一个频域语音降噪算法实现及改进方法</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50618190" target="_blank">最简单的基于FFmpeg的AVfilter的例子-纯净版</a>
            </li>
                        <li class="clearfix">
                <a href="https://blog.csdn.net/leixiaohua1020/article/details/50535230" target="_blank">视音频数据处理入门：UDP-RTP协议解析</a>
            </li>
                    </ul>
    </div>
</div>
		    <div id="asideColumn" class="aside-box">
    <h3 class="aside-title">博主专栏</h3>
    <div class="aside-content">
        <ul class="column-box csdn-tracking-statistics tracking-click" data-mod="popu_520" >
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/videoquality.html">
                            <img src="https://img-blog.csdn.net/20151123175555036?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/videoquality.html">视频质量评价</a></p>
                        <div class="data">阅读量：<span>434203</span><span class="count">41 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/osmedia.html">
                            <img src="https://img-blog.csdn.net/20151123175559974?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/osmedia.html">开源多媒体项目源代码分析</a></p>
                        <div class="data">阅读量：<span>1158961</span><span class="count">91 篇</span></div>
                    </div>
                </li>
                            <li class="clearfix">
                    <div class="img-box float-left">
                        <a class="d-flex align-items-center" href="https://blog.csdn.net/column/details/ffmpeg-devel.html">
                            <img src="https://img-blog.csdn.net/20151123175857395?imageView2/5/w/120/h/120" alt="">
                        </a>
                    </div>
                    <div class="info">
                        <p class="title"><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html">FFmpeg</a></p>
                        <div class="data">阅读量：<span>4852475</span><span class="count">135 篇</span></div>
                    </div>
                </li>
                    </ul>
    </div>
    </div>
		    <div id="asideArchive" class="aside-box flexible-box">
    <h3 class="aside-title">归档</h3>
    <div class="aside-content">
        <ul class="archive-list">
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/04">
                    2016年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/03">
                    2016年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/02">
                    2016年2月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2016/01">
                    2016年1月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/12">
                    2015年12月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/11">
                    2015年11月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/08">
                    2015年8月                    <span class="count float-right">4篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/07">
                    2015年7月                    <span class="count float-right">17篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/06">
                    2015年6月                    <span class="count float-right">6篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/05">
                    2015年5月                    <span class="count float-right">12篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/04">
                    2015年4月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/03">
                    2015年3月                    <span class="count float-right">25篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/02">
                    2015年2月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2015/01">
                    2015年1月                    <span class="count float-right">11篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/12">
                    2014年12月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/11">
                    2014年11月                    <span class="count float-right">9篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/10">
                    2014年10月                    <span class="count float-right">20篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/09">
                    2014年9月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/08">
                    2014年8月                    <span class="count float-right">7篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/07">
                    2014年7月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/06">
                    2014年6月                    <span class="count float-right">8篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/05">
                    2014年5月                    <span class="count float-right">10篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/04">
                    2014年4月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/02">
                    2014年2月                    <span class="count float-right">5篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2014/01">
                    2014年1月                    <span class="count float-right">14篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/12">
                    2013年12月                    <span class="count float-right">21篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/11">
                    2013年11月                    <span class="count float-right">71篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/10">
                    2013年10月                    <span class="count float-right">161篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/09">
                    2013年9月                    <span class="count float-right">101篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/08">
                    2013年8月                    <span class="count float-right">1篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/06">
                    2013年6月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                        <!--归档统计-->
            <li>
                <a href="https://blog.csdn.net/leixiaohua1020/article/month/2013/03">
                    2013年3月                    <span class="count float-right">2篇</span>
                </a>
            </li>
                    </ul>
    </div>
        <p class="text-center">
        <a class="btn btn-link-blue flexible-btn" data-fbox="aside-archive">展开</a>
    </p>
    </div>
		    <div id="asideNewComments" class="aside-box">
    <h3 class="aside-title">最新评论</h3>
    <div class="aside-content">
        <ul class="newcomment-list">
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tanhuifang520" class="user-name" target="_blank">tanhuifang520</a>：含着敬畏的心情又看了遍这个文章                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/42105049#comments">最简单的基于librtmp的示例：...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_32245927" class="user-name" target="_blank">qq_32245927</a>：[reply]hjl19901012[/reply]
你们的是哪里有问题呢                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/46754977#comments">视频编码器评测系统：VideoCo...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/tqs_1220" class="user-name" target="_blank">tqs_1220</a>：天妒英才                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/38284961#comments">FFmpeg获取DirectSho...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/a137748099" class="user-name" target="_blank">a137748099</a>：[reply]liangqingzhi[/reply]
大佬，有的电脑使用regsvr32注册不成...                </p>
            </li>
                        <li>
                <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977#comments">[总结]FFMPEG视音频编解码零...</a>
                <p class="comment">
                    <a href="https://my.csdn.net/qq_17276615" class="user-name" target="_blank">qq_17276615</a>：每次视频编解码都会搜到你的文章，感谢您给我们这些菜鸡一些指引。谢谢！                </p>
            </li>
                    </ul>
    </div>
</div>
		<div id="asideFooter">
			
		<div class="aside-box">
						<script type="text/javascript" src="//cee1.iteye.com/avneunkwb@js"></script>
					</div>
				<div class="aside-box">
			<div class="persion_article">
			</div>
		</div>
	</div>
</aside>
<script src="https://csdnimg.cn/pubfooter/js/publib_footer-1.0.3@js" data-isfootertrack="false" type="text/javascript"></script>
<script>
	$("a.flexible-btn").click(function(){
		$(this).parents('div.aside-box').removeClass('flexible-box');
		$(this).remove();
	})
</script>
</div>
<div class="mask-dark"></div>
<div class="pulllog-box" style="display: none;">
	<div class="pulllog clearfix">
		<span class="text float-left">加入CSDN，享受更精准的内容推荐，与500万程序员共同成长！</span>
		<div class="pulllog-btn float-right clearfix">
            <button class="pulllog-login float-left csdn-tracking-statistics tracking-click" data-mod="popu_557">
                登录
            </button>
            <div class="pulllog-sigin float-left csdn-tracking-statistics tracking-click" data-mod="popu_558">
                <a href="https://passport.csdn.net/account/mobileregister" target="_blank">注册</a>
            </div>
            <button class="btn-close">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#csdnc-times"></use>
                </svg>
            </button>
		</div>
	</div>
</div>
<div id="loginWrap" style="display:none"></div>
<div class="tool-box">
	<ul class="meau-list">
		<li>
			<button class="btn-like " title="点赞">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-thumbsup"></use>
				</svg>
				<p>2</p>
			</button>
		</li>
		<li class="toc-container-box" id="liTocBox">
			<button class="btn-toc" title="目录">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-contents"></use>
				</svg><br>目录
			</button>
			<div class="toc-container">
				<div class="pos-box">
					<div class="icon-arrow"></div>
					<div class="scroll-box">
						<div class="toc-box"></div>
					</div>
				</div>
				<div class="opt-box">
					<button class="btn-opt prev nomore" title="向上">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevronup"></use>
						</svg>
					</button>
					<button class="btn-opt next">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#csdnc-chevrondown"></use>
						</svg>
					</button>
				</div>
			</div>
		</li>
		<li>
			<button class="btn-bookmark" title="收藏">
				<svg class="icon active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark-ok"></use>
				</svg><svg class="icon no-active" aria-hidden="true">
					<use xlink:href="#csdnc-bookmark"></use>
				</svg><br>收藏
			</button>
		</li>
		<li>
			<a class="btn-comments" title="评论" href="#commentBox">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-comments"></use>
				</svg><br>评论
			</a>
		</li>
				<li class="bdsharebuttonbox">
			<a class="btn-comments bds_weixin" data-cmd="weixin" title="微信分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-wechat"></use>
				</svg><br>微信
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_tsina" data-cmd="tsina" title="微博分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-weibo"></use>
				</svg><br>微博
			</a>
		</li>
		<li class="bdsharebuttonbox">
			<a class="btn-comments bds_qzone" data-cmd="qzone" title="QQ分享">
				<svg class="icon" aria-hidden="true">
					<use xlink:href="#csdnc-qq"></use>
				</svg><br>QQ
			</a>
		</li>
	</ul>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'https://csdnimg.cn/static/api/js/share@js?v=89860594'];</script>
<script>
    var recommendCount = 10;
    recommendCount = recommendCount > 1 ? (recommendCount + (recommendCount>6 ? 2 : 1)) : recommendCount;
    var articleTit = "FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）";
    var ChannelId = 16;
    var articleId = "45143075";
    var commentscount = 2;
    var islock = false;
    var curentUrl = "https://blog.csdn.net/leixiaohua1020/article/details/45143075";
    var myUrl = "https://my.csdn.net/";
    //1禁止评论，2正常
    var commentAuth = 2;
    //百度搜索
    var baiduKey = "getsimpledecode";
    var needInsertBaidu = false;
</script>
<script src="https://csdnimg.cn/public/sandalstrap/1.3/js/sandalstrap.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/vendor/pagination/paging@js"></script>

<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            showReport(false,"FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）");
        }
    })
</script>
<script src="https://csdnimg.cn/release/phoenix/template/js/common-bd54b21308.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min@js"></script>
<script src="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-46c7bd3d86.min@js"></script>
<script src="https://csdnimg.cn/search/baidu_search-1.1.2@js?v=201802071056&autorun=true&install=true&keyword=getsimpledecode"  type="text/javascript"></script>
</body>
<div class="box-box-default" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/mhzzjepzz@js"></script>
</div>
<div class="box-box-large" style="display:none;">
    <a class="btn-remove">
        关闭
    </a>
    <script type="text/javascript" src="//cee1.iteye.com/idvveasfs@js"></script>
</div>
</html>